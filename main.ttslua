---@diagnostic disable: lowercase-global
local C = require("constants")
local U = require("utilities")
local G = require("guids")
local Z = require("zones")

local M = {}

local function parseCode(val, isIncludingTraits)
  if (val == nil) then return "nil" end
  if (isIncludingTraits) then return JSON.encode_pretty(val.traits.Yellow) end
  return JSON.encode_pretty(U.filter(val, function(val, key) return key ~= "traits" end))
end
-- *** GAME STATE ***

-- local isLoaded = false
-- function onLoad() isLoaded = true end

function M.refreshStateDebug(stateData)
  if (stateData == nil) then
    stateData = Global.getTable("gameState")
  end
  -- stateData.traits = nil
  -- stateData.traits.Yellow[1].Wealth = 0
  -- M.setGameState(stateData)
  UI.setValue("debugState", parseCode(stateData))
  UI.setValue("debugTraitsRed", JSON.encode_pretty(stateData.traits.Red))
  UI.setValue("debugTraitsYellow", JSON.encode_pretty(stateData.traits.Yellow))
  UI.setValue("debugTraitsBlue", JSON.encode_pretty(stateData.traits.Blue))
end

function M.getGameState()
  M.refreshStateDebug()
  return Global.getTable("gameState")
end
function M.setGameState(data)
  Global.setTable("gameState", data)
  M.refreshStateDebug(data)
  return
end

function M.getStateVal(key, subKey)
  local state = Global.getTable("gameState")
  M.refreshStateDebug(state)
  if not state[key] then return state[key] end
  if subKey then return state[key][subKey] end
  return state[key]
end

function M.setStateVal(value, key, subKey)
  local state = Global.getTable("gameState")
  if (subKey) then
      if (state[key] == nil) then state[key] = {} end
      state[key][subKey] = value
  else
      state[key] = value
  end
  Global.setTable("gameState", state)
  M.refreshStateDebug(state)
end
function M.setStateVals(stateData)
  local state = Global.getTable("gameState")
  for key, val in pairs(stateData) do
    state[key] = val
  end
  Global.setTable("gameState", state)
  M.refreshStateDebug(state)
end
function M.resetGameState()
  local state = Global.getTable("gameState")

    -- state.traits = {
    --   Red = {
    --     {Kindred = 1, Mortals = 1, Wealth = 2},
    --     {Warfare = 0, Subterfuge = 0, Occult = 0},
    --     {Cruelty = 1, Mercy = 1, Detachment = 1},
    --     {Camarilla = 0, Anarchs = 0, Sabbat = 0},
    --     {Animalism = 0, Auspex = 0, Celerity = 0, Dominate = 0, Fortitude = 0, Obfuscate = 0, Oblivion = 0, Potence = 0, Presence = 2, Protean = 0, Blood_Sorcery = 0}
    --
    --   },
    --   Yellow = {
    --     {Kindred = 0, Mortals = 1, Wealth = 0},
    --     {Warfare = 0, Subterfuge = 0, Occult = 2},
    --     {Cruelty = 0, Mercy = 0, Detachment = 0},
    --     {Camarilla = 0, Anarchs = 0, Sabbat = 0},
    --     {Animalism = 0, Auspex = 0, Celerity = 0, Dominate = 0, Fortitude = 0, Obfuscate = 0, Oblivion = 1, Potence = 0, Presence = 0, Protean = 0, Blood_Sorcery = 1}
    --   },
    --   Blue = {
    --     {Kindred = 0, Mortals = 0, Wealth = 0},
    --     {Subterfuge = 3, Warfare = 1, Occult = 0},
    --     {Cruelty = 0, Mercy = 0, Detachment = 1},
    --     {Camarilla = 0, Anarchs = 0, Sabbat = 0},
    --     {Animalism = 0, Auspex = 0, Celerity = 0, Dominate = 0, Fortitude = 0, Obfuscate = 0, Oblivion = 0, Potence = 1, Presence = 0, Protean = 1, Blood_Sorcery = 0}
    --   }
    -- }


  Global.setTable("gameState", {
      turnOrder = nil,
      clans = nil,
      notes = nil,
      lastChapterStandings = state.lastChapterStandings,
      chapterData = state.chapterData,
      round = 0,
      turn = 0,
      traits = state.traits,
			playerZonesLocked = false
      -- isReadingMoralityBoard = true
  })
  M.refreshStateDebug()
end

-- *** GAME STATUS ***
local fallbackValues = {
  lastChapterStandings = {"Red", "Blue", "Yellow"}
}

function M.showHavens()
	for _, color in pairs(C.Colors) do
		local haven = getObjectFromGUID(G.playerSpaces[color].haven)
		if haven then
			local havenPos = haven.getPosition()
			if havenPos.y < -2 then
				havenPos.y = 2
				haven.setPosition(havenPos)
				havenPos.y = -0.40
				haven.setInvisibleTo({})
				haven.setPositionSmooth(havenPos)
				haven.tooltip = true
			end
		end
	end
end

function M.hideHavens()
	for _, color in pairs(C.Colors) do
		local haven = getObjectFromGUID(G.playerSpaces[color].haven)
		if haven then
			local havenPos = haven.getPosition()
			if havenPos.y > -2 then
				havenPos.y = 2
				haven.setPositionSmooth(havenPos)
				Wait.time(function()
					haven.setInvisibleTo(C.Colors)
					haven.tooltip = false
					havenPos.y = -10
					Wait.frames(function() haven.setPosition(havenPos) end)
				end, 0.5)
			end
		end
	end
end

function M.showPouches()
	for _, color in pairs(C.Colors) do
		local pouch = getObjectFromGUID(G.playerSpaces[color].pouch)
		if pouch then
			local pouchPos = pouch.getPosition()
			if pouchPos.y < -2 then
				pouchPos.y = 2
				pouch.setPosition(pouchPos)
				pouchPos.y = -0.13
				pouch.setInvisibleTo({})
				pouch.setPositionSmooth(pouchPos)
				pouch.tooltip = true
			end
		end
	end
end

function M.hidePouches()
	for _, color in pairs(C.Colors) do
		local pouch = getObjectFromGUID(G.playerSpaces[color].pouch)
		if pouch then
			local pouchPos = pouch.getPosition()
			if pouchPos.y > -2 then
				pouchPos.y = 2
				pouch.setPositionSmooth(pouchPos)
				Wait.time(function()
					pouch.setInvisibleTo(C.Colors)
					pouch.tooltip = false
					pouchPos.y = -10
					Wait.frames(function() pouch.setPosition(pouchPos) end)
				end, 0.5)
			end
		end
	end
end

-- === LastChapterStandings ===
function M.checkLastChapterStandings(data)
  if data == nil then data = M.getStateVal("lastChapterStandings") end
  if not (type(data) == "table" and #data == #Player.getPlayers()) then return false end
  if table.concat(table.sort(U.clone(data))) ~= "BlueRedYellow" then return false end
  return true
end
function M.getLastChapterStandings()
  if (M.checkLastChapterStandings()) then
    return M.getStateVal("lastChapterStandings")
  end
  -- broadcastToColor("[getLastChapterStandings] " .. logString(H.getStateVal("lastChapterStandings")) .. " is invalid state! Using fallback value.", "Red", "Red")
  return fallbackValues.lastChapterStandings
end
function M.getLastChapterVictor()
  return M.getLastChapterStandings()[1]
end
function M.getLastChapterMiddle()
  return M.getLastChapterStandings()[2]
end
function M.getLastChapterVanquished()
  return M.getLastChapterStandings()[3]
end
function M.determineLastChapterStandings(callback)
  if not M.checkLastChapterStandings() then
    M.askLastChapterStandings(function() M.determineLastChapterStandings(callback) end)
  end
end
function M.setLastChapterStandings(data)
  if (M.checkLastChapterStandings(data)) then
    M.setStateVal(data, "lastChapterStandings")
    return
  end
  broadcastToColor("[setLastChapterStandings] " .. logString(data) .. " is invalid data!", "Red", "Red")
end
function M.askLastChapterStandings(callback)
  local chapterStandings = {}
  local hostPlayer = U.getHost()
  local playerOptions = U.map(Player.getPlayers(), function(player) return player.color end)
  hostPlayer.showOptionsDialog("Who won the last chapter?", playerOptions, 1,
    function (color, index)
      table.insert(chapterStandings, color)
      hostPlayer.showOptionsDialog("Who came in second?", playerOptions, 1,
        function (color, index)
          table.insert(chapterStandings, color)
          hostPlayer.showOptionsDialog("Who came in last?", playerOptions, 1,
            function (color, index)
              table.insert(chapterStandings, color)
              M.setLastChapterStandings(chapterStandings)
              if (callback) then callback() end
            end
          )
        end
      )
    end
  )
end
function M.askChapterData(callback)
  local chapterData = {}
  local hostPlayer = U.getHost()

  hostPlayer.showInputDialog("Upcoming Chapter Number (Roman Numerals)",
      function (text)
        chapterData.chapterNum = text
        hostPlayer.showInputDialog("Last Chapter Number (Roman Numerals)",
            function (text)
              chapterData.lastChapterNum = text
              hostPlayer.showInputDialog("Upcoming Chapter Location",
                  function (text)
                    chapterData.location = text
                    hostPlayer.showInputDialog("Upcoming Chapter Years",
                        function (text)
                          chapterData.years = text
                          hostPlayer.showInputDialog("Upcoming Chapter Blurb",
                              function (text)
                                chapterData.chapterBlurb = text
                                M.setStateVal(chapterData, "chapterData")
                              end
                          )
                        end
                    )
                  end
              )
            end
        )
      end
  )
end

-- === Turn Order ===
-- This is strictly for the game's Turns object, not for clan selection --> use lastChapterStandings for that.
local turnOrderMap = {
  Red = {"Red", "Yellow", "Blue"},
  Yellow = {"Yellow", "Blue", "Red"},
  Blue = {"Blue", "Red", "Yellow"}
}
local function getColorOfClan(clan)
  local clans = M.getClans()
  if clans.Red == clan then return "Red" end
  if clans.Yellow == clan then return "Yellow" end
  if clans.Blue == clan then return "Blue" end
  return ""
end
local function getMoralityToken(playerColor)
	-- if not isLoaded then return false end
  local clan = M.getStateVal("clans")[playerColor]
  if (clan == nil) then return false end
  local tokenName = clan .. " Morality"
  local token = U.find(Global.getObjects(), function (obj) return obj.getName() == tokenName end)
  if (token == nil) then return false end
  return token
end
local function moveCurrentMoralityTokenToTop()
  local round, turn = M.getRoundAndTurn()
  if (round < 1 or round > 9) then return end
  local curMoralityToken = getMoralityToken(M.getCurrentPlayer())
	if curMoralityToken ~= nil then
		local tokenPos = curMoralityToken.getPosition()
		tokenPos.y = tokenPos.y + 1
		curMoralityToken.setPosition(tokenPos)
		Wait.time(M.highlightBattlegrounds, 2)
	end
end

function M.readTurnOrderFromBG()

  local turnOrder = M.getTurnOrder()
  local lastFirstPlayer = turnOrder[1]
  local bg = getObjectFromGUID(G.battlegrounds.b)
  local bgSnapPoints = U.getSnapPointPositions(bg)
  local pTokens = U.filter(U.findAboveObject(bg, "Tile"), function(tok) return string.find(tok.getName(), "Morality") ~= nil end)

  local function getTokenSlot(tk)
    local slot = U.findSnapPoint(bgSnapPoints, bg.positionToLocal(tk.getPosition()))
      local clan = U.findClanTag(tk)
      local color = getColorOfClan(clan)
    if (slot >= 6 and slot <= 9) then slot = 7 end
    if (color == lastFirstPlayer) then
      slot = slot + 0.5
    end
    return slot, color, clan
  end

  local curTopTokenSlot = 0
  local curTopTokenColors = {}
  for _, tok in pairs(pTokens) do
    local slot = U.findSnapPoint(bgSnapPoints, bg.positionToLocal(tok.getPosition()))
    local slot, color, clan = getTokenSlot(tok)
    if (slot > curTopTokenSlot) then
      curTopTokenSlot = slot
      curTopTokenColors = {}
      table.insert(curTopTokenColors, color)
    elseif (slot == curTopTokenSlot) then
      table.insert(curTopTokenColors, color)
    end
  end

  if (#curTopTokenColors == 1) then
    return turnOrderMap[curTopTokenColors[1]]
	end

	return lastFirstPlayer
end
function M.checkTurnOrder(data)
  if data == nil then data = M.getStateVal("turnOrder") end
  if not (type(data) == "table" and #data == 3) then return false end
  -- if not (table.concat(turnOrderMap[data[1]]) == table.concat(data)) then return false end
  return true
end
function M.getTurnOrder()
  if (M.checkTurnOrder()) then
    return M.getStateVal("turnOrder")
  end
  broadcastToColor("[getTurnOrder] " .. logString(M.getStateVal("turnOrder")) .. " is invalid state! Using order set in 'Turns'.", "Red", "Red")
  return Turns.order
end
function M.determineTurnOrder(callback)
  local turnOrder = {}
  local round, turn = M.getRoundAndTurn()
  if round > 1 and round < 10 then
    -- if M.getStateVal("isReadingMoralityBoard") then
      turnOrder = M.readTurnOrderFromBG()
      M.setTurnOrder(turnOrder)
    -- else
      -- M.askTurnOrder(function() M.determineTurnOrder(callback) end)
      -- return
    -- end
  else
    turnOrder = turnOrderMap[M.getLastChapterStandings()[3]]
    M.setTurnOrder(turnOrder)
  end
  if callback then callback() end
end
function M.setTurnOrder(data)
  if (M.checkTurnOrder(data)) then
    M.setStateVal(data, "turnOrder")
    return
  end
  broadcastToColor("[setTurnOrder] " .. logString(data) .. " is invalid data!", "Red", "Red")
end
function M.askTurnOrder(callback)
  -- M.setStateVal("isReadingMoralityBoard", false)
  local round, turn = M.getRoundAndTurn()
  if round == 0 then
    M.askLastChapterStandings(callback)
  else
    local turnOrder
    local hostPlayer = U.getHost()
    local playerOptions = U.map(Player.getPlayers(), function(player) return player.color end)
    hostPlayer.showOptionsDialog("Who is this round's first player?", playerOptions, 1,
      function (color)
        M.setTurnOrder(turnOrderMap[color])
        if callback then callback() end
      end
    )
  end
end
function M.syncTurnOrder()
  local round, turn = M.getRoundAndTurn()
  if round > 0 and round < 10 then
    local turnOrder = M.getTurnOrder()
    if (table.concat(Turns.order) ~= table.concat(turnOrder)) then
      Turns.order = M.getTurnOrder()
    end
    if (Turns.type ~= 2) then
      Turns.type = 2
    end
    M.setHighlighter("TurnIndicator", "faint", Turns.order[turn])
    if (Turns.turn_color ~= Turns.order[turn]) then
      Turns.turn_color = Turns.order[turn]
    end
    if (not Turns.enable) then
      Turns.enable = true
    end
    moveCurrentMoralityTokenToTop()
    M.syncTurnTracker()
  else
    UI.hide("turnTracker")
    Turns.enable = false
  end
end
function M.syncTurnTracker()
  local round, turn = M.getRoundAndTurn()
  local turnOrder = M.getTurnOrder()
  local curPlayer = turnOrder[turn]
  local colors = {
      hex = {
          past = "white",
          current = "white",
          future = "white"
      },
      turn = {
          past = "rgba(0.3, 0.3, 0.3, 0.75)",
          current = {
              Red = "rgba(1, 0.2, 0.2, 1)",
              Yellow = "rgba(1, 1, 0, 1)",
              Blue = "rgba(0, 0.4, 0.8, 1)"
          },
          future = {
              Red = "rgba(1, 0.2, 0.2, 0.5)",
              Yellow = "rgba(1, 1, 0, 0.5)",
              Blue = "rgba(0, 0.4, 0.8, 0.5)",
              none = "rgba(1, 1, 1, 0.5)"
          }
      },
  }

    if (round < 1 or round > 9) then
        UI.hide("turnTracker")
        return
    else
        UI.show("turnTracker")
        for _, clr in pairs({"Red", "Yellow", "Blue"}) do
          if (curPlayer == clr) then
            M.setHighlighter("TurnIndicator", "faint", clr)
          else
            M.setHighlighter("TurnIndicator", "inactive", clr)
          end
        end
    end

    for i = 1, 9, 1 do
        UI.setAttribute("tt-round-past-" .. i, "color", "clear")
        UI.setAttribute("tt-round-current-" .. i, "color", "clear")
        UI.setAttribute("tt-round-future-" .. i, "color", "clear")
        if (i < round) then
            UI.setAttribute("tt-round-past-" .. i, "color", colors.hex.past)
        elseif (i == round) then
            UI.setAttribute("tt-round-current-" .. i, "color", colors.hex.current)
        elseif (i > round) then
            UI.setAttribute("tt-round-future-" .. i, "color", colors.hex.future)
        end

        for j = 1, 3, 1 do
            UI.setAttribute("tt-round-past-" .. i .. "-turn-" .. j, "color", "clear")
            UI.setAttribute("tt-round-current-" .. i .. "-turn-" .. j, "color", "clear")
            UI.setAttribute("tt-round-future-" .. i .. "-turn-" .. j, "color", "clear")
            if (i < round) then
                UI.setAttribute("tt-round-past-" .. i .. "-turn-" .. j, "color", colors.turn.past)
            elseif (i == round) then
                if (j < turn) then
                    UI.setAttribute("tt-round-past-" .. i .. "-turn-" .. j, "color", colors.turn.past)
                elseif (j == turn) then
                    UI.setAttribute("tt-round-current-" .. i .. "-turn-" .. j, "color", colors.turn.current[turnOrder[j]])
                elseif (j > turn) then
                    UI.setAttribute("tt-round-future-" .. i .. "-turn-" .. j, "color", colors.turn.future[turnOrder[j]])
                end
            elseif (i > round) then
                UI.setAttribute("tt-round-future-" .. i .. "-turn-" .. j, "color", colors.turn.future.none)
            end
        end
    end
end

-- === Clans ===
function M.getClans()
  local clans = M.getStateVal("clans")
  if (clans == nil) then return {} end
  return clans
end
function M.displayClanSelectionRing()
    local masterStorage = getObjectFromGUID(G.mainStorage.id)
    local clanTokenObjs = {}
    local stagingPosition = masterStorage.getPosition()
    stagingPosition.x = stagingPosition.x + 5
    stagingPosition.z = stagingPosition.z - 5

    -- Extract clan token objects from storage.
    for _, obj in pairs(U.filter(masterStorage.getObjects(), function(objData) return U.isIn("ClanToken", objData.tags) end)) do
        stagingPosition.y = stagingPosition.y + 1
        masterStorage.takeObject({guid = obj.guid, position = stagingPosition})
    end

    -- Arrange in ring for player selection.
    Wait.time(function()
        U.makeRing(
            U.filter(getAllObjects(), function(obj) return obj.hasTag("ClanToken") end),
            G.tableSpots.highlighters.clanSelection.active,
            3,
            {
                scale = {x = 0.5, y = 1, z = 0.5}
            }
        )
    end, 0.5)

    -- Make clan selection highlight visible and position appropriately.
    M.setHighlighter("ClanSelection", "active")

end

function M.assignClan(clan, color)
  local clans = M.getStateVal("clans")
  local mainStorage = getObjectFromGUID(G.mainStorage.id)
  M.setStateVal(clan, "clans", color)
  UI.setValue(color .. "ClanChoice", C.Names[color] .. " Chooses Clan " .. clan)
  if (color == M.getLastChapterMiddle()) then
    U.splashUIElement("chooseStrandsOfTimeNotice", 5) -- Vanquished last Chapter, you may choose a Strand of time
    local strandOfTimeSpot = getObjectFromGUID(G.decks.strandOfTimeSpot)
    strandOfTimeSpot.highlightOn("Green")
    M.presentStrandsOfTimeToMiddle()
  end
  Wait.time(function()
    if (M.getNextPlayer()) then
      M.setHighlighter("TurnIndicator", "strong", M.getNextPlayer())
      M.setHighlighter("ClanSelection", "active")
      UI.setValue("chooseClanPlayer", C.Names[M.getNextPlayer()])
      UI.setAttribute("chooseClanPlayer", "color", M.getNextPlayer())
      U.splashUIElement("chooseClanNotice", 5)
    else
      M.setHighlighter("ClanSelection", "inactive")
      local unusedClanTokens = U.filter(
        getAllObjects(),
        function(obj)
          return obj and obj.hasTag("ClanToken")
            and string.gsub(obj.getName(), " Clan Token", "") ~= clans.Red
            and string.gsub(obj.getName(), " Clan Token", "") ~= clans.Yellow
            and string.gsub(obj.getName(), " Clan Token", "") ~= clans.Blue
            and string.gsub(obj.getName(), " Clan Token", "") ~= clan
        end
      )
      for _, token in pairs(unusedClanTokens) do
          mainStorage.putObject(token)
      end
    end
  end, 1)
  UI.show(color .. "ClanChoice")
end

-- === Round & Turn ===
function M.checkRoundAndTurn(dataRound, dataTurn)

  if dataRound == nil then dataRound = M.getStateVal("round") end
  if dataTurn == nil then dataTurn = M.getStateVal("turn") end

	dataRound = 1 * dataRound
	dataTurn = 1 * dataTurn
  -- if not (type(dataRound) == "number" and type(dataTurn) == "number") then return false end
  if dataRound < 0 or dataRound > 10 then return false end
  if dataTurn < 0 or dataTurn > 3 then return false end
  if dataRound > 0 and dataTurn == 0 then return false end
  if dataRound == 0 and dataTurn ~= 0 then return false end
  return true
end
function M.getRoundAndTurn()
  if (M.checkRoundAndTurn()) then
    return M.getStateVal("round"), M.getStateVal("turn")
  end
  local clans = M.getClans()
  if not (clans and clans.Red and clans.Yellow and clans.Blue) then
    M.setRoundAndTurn(0, 0)
    return 0, 0
  end
  broadcastToColor("[getRoundAndTurn] Round: " .. logString(M.getStateVal("round")) .. ", Turn: " .. logString(M.getStateVal("turn")) .. " is invalid state! Falling back to default!", "Red", "Red")
  local round = M.getStateVal("round")
  local turn = M.getStateVal("turn")
  if not (type(round) == "number" and round >= 0 and round <= 9) then -- Round is invalid, reset to 0, 0
    M.setRoundAndTurn(0, 0)
    return 0, 0
  end
  if (round == 0) then
    M.setRoundAndTurn(0, 0)
    return 0, 0
  end
  -- Round is valid: Extract turn number from turn order and current player
  local turnOrder = M.getTurnOrder()
  if (turnOrder[1] == Turns.turn_color) then turn = 1 end
  if (turnOrder[2] == Turns.turn_color) then turn = 2 end
  if (turnOrder[3] == Turns.turn_color) then turn = 3 end
  M.setRoundAndTurn(round, turn)
  return round, turn
end
function M.setRoundAndTurn(dataRound, dataTurn)
  if (M.checkRoundAndTurn(dataRound, dataTurn)) then
    M.setStateVal(dataRound, "round")
    M.setStateVal(dataTurn, "turn")
    return
  end
  broadcastToColor("[setRoundAndTurn] Round: " .. logString(dataRound) .. ", Turn: " .. logString(dataTurn) .. " is invalid data!", "Red", "Red")
end
function M.askRoundAndTurn(callback)
  local hostPlayer = U.getHost()
  hostPlayer.showOptionsDialog("What round is it?", {0,1,2,3,4,5,6,7,8,9}, 1,
    function(roundNum)
      hostPlayer.showOptionsDialog("What turn is it?", {0,1,2,3}, 2,
        function(turnNum)
					roundNum = roundNum * 1
					turnNum = turnNum * 1
					log({round = roundNum, turn = turnNum})
					local isAdvancingTurn = roundNum > 0 and turnNum > 0
					if roundNum > 0 and turnNum > 0 then
						if turnNum == 1 then
							turnNum = 3
							roundNum = roundNum - 1
						else
							turnNum = turnNum - 1
						end
					end
          M.setRoundAndTurn(roundNum, turnNum)
					M.advanceTurn()
          if (callback) then callback() end
        end
      )
    end
  )
end
function M.syncRoundAndTurn() M.syncTurnOrder() end

function M.advanceTurn()
  local round, turn = M.getRoundAndTurn()
  if (round == 0) then return end
  if (turn == 3) then return M.advanceRound() end
  UI.setValue("roundOverNotice", "")
  M.setRoundAndTurn(round, turn + 1)
  M.syncTurnOrder()
  -- Wait.time(H.syncTurnOrder, 1)
end
function M.advanceRound()
  local round, turn = M.getRoundAndTurn()
  if (round == 0) then return end
  local roundsLeft = 12 - #Player.getPlayers() - round
  if (roundsLeft <= 0) then
    M.setRoundAndTurn(10, 1)
    U.splashUIElement("splash-backdrop", 6)
    U.splashUIElement("gameOverNotice", 5, 0.5)
    -- UI.show("aftermathReminder")
    UI.hide("turnTracker")
    Wait.time(function()
      M.setHighlighter("TurnIndicator", "inactive", "Red")
      M.setHighlighter("TurnIndicator", "inactive", "Yellow")
      M.setHighlighter("TurnIndicator", "inactive", "Blue")
      M.setHighlighter("BGIndicator", "inactive", "left")
      M.setHighlighter("BGIndicator", "inactive", "center")
      M.setHighlighter("BGIndicator", "inactive", "right")
    end, 3)
    return
  end
	Wait.time(function() M.highlightBattlegrounds() end, 2)
  local lastRoundFirstPlayer = M.getRoundFirstPlayer()
  UI.setValue("roundOverNoticeText", "End of Round " .. round)
  if (roundsLeft == 1) then
    UI.setValue("roundsRemainingNoticeText", "FINAL ROUND!")
  elseif (roundsLeft <= 3) then
    UI.setValue("roundsRemainingNoticeText", roundsLeft .. " Rounds Remain...")
  else
    UI.setValue("roundsRemainingNoticeText", "")
  end
  UI.setValue("roundStartNoticeText", "Beginning Round " .. round + 1)

  M.setRoundAndTurn(round + 1, 1)
  M.determineTurnOrder(function()
    local initiativeElem
    local roundFirstPlayer = M.getRoundFirstPlayer()
    if (lastRoundFirstPlayer == roundFirstPlayer) then
        UI.setValue("retainInitiativeNotice", "(" .. C.Names[roundFirstPlayer] .. " Retains His Initiative)")
        UI.setValue("seizeInitiativeNotice", "")
        initiativeElem = "retainInitiativeNotice"
    else
        UI.setValue("seizeInitiativeNotice", C.Names[roundFirstPlayer] .. " Seizes Initiative!")
        UI.setValue("retainInitiativeNotice", "")
        initiativeElem = "seizeInitiativeNotice"
    end
    U.splashUIElement("splash-backdrop", 4.5)
    U.splashUIElement("roundOverNotice", 1)
    U.splashUIElement("roundsRemainingNoticeText", 1)
    U.splashUIElement("roundStartNotice", 2, 1.5)
    U.splashUIElement(initiativeElem, 1, 1.5)

    M.syncTurnOrder()
  end)
end

-- *** DERIVED GAME STATUSES ***
function M.getCurrentPlayer()
  local round, turn = M.getRoundAndTurn()
  if (round == 0) then
    return M.getNextPlayer() -- 'current' and 'next' player are both 'the player who is next to choose a clan'
  end
  if (round > 9) then return nil end
  return M.getTurnOrder()[turn]
end
function M.getNextPlayer()
  local round, turn = M.getRoundAndTurn()
  local clans = M.getClans()
  if (round == 0) then
    for _, color in ipairs(U.reverse(M.getLastChapterStandings())) do
      if (clans[color] == nil) then return color end
    end
    return nil
  end
  if (round == 9 and turn == 3) or round > 9 then return nil end
  if (turn == 3) then return M.getNextRoundFirstPlayer() end
  return M.getTurnOrder()[turn + 1]
end
function M.getRoundFirstPlayer()
  local round, turn = M.getRoundAndTurn()
  if (round == 0) then
    return M.getLastChapterStandings()[#Player.getPlayers()]
  end
  local curRoundTurnOrder = M.getTurnOrder()
  return curRoundTurnOrder[1]
end
function M.getNextRoundFirstPlayer()
  local round, turn = M.getRoundAndTurn()
  if (round == 0) then
    return M.getLastChapterStandings()[#Player.getPlayers()]
  end
  if (round >= 9) then return nil end
  -- if M.getStateVal("isReadingMoralityBoard") then
    local nextRoundTurnOrder = M.readTurnOrderFromBG()
    return nextRoundTurnOrder[1]
  -- end
  -- return nil
end




targetCard = false
function M.zoomCard(player)
  pcall(function()
    if targetCard then
      targetCard.setLock(false)
      targetCard.setRotationSmooth({x=0, y=180, z=0}, false, true)
      targetCard.setPositionSmooth({x=8.83, y=2, z=1.13}, false, true)
    end
  end)

  local sourceDeck = U.findAboveObject(getObjectFromGUID(G.decks.missionSpot), "Deck")[1]
  targetCard = sourceDeck.takeObject({
    position = {x=-0.5, y=5.47, z=2},
    rotation = {x=19.28, y=180, z=0},
    callback_function = function(obj) obj.setLock(true) end
   })
   -- H.setCamera()
   player.setCameraMode("ThirdPerson")
   player.lookAt({
     position = {x=-0.5,y=-2,z=4.75},
     pitch = 70.72,
     yaw = 0,
     distance = 11
   })
end
function M.clearZoom(player)
  pcall(function()
    if targetCard then
      targetCard.setLock(false)
      targetCard.setRotationSmooth({x=0, y=180, z=0}, false, true)
      targetCard.setPositionSmooth({x=8.83, y=2, z=1.13}, false, true)
    end
    targetCard = false
  end)
end

-- *** GAME PHASE ACTIONS ***
local chapterCard
local missionDeck
function M.gameSETUP()
  M.resetGameState()

	M.showHavens()

  local waitTime = 5

  missionDeck = U.findAboveObject(getObjectFromGUID(G.decks.missionSpot), "Deck")[1]
  chapterCard = missionDeck.takeObject({
    position = {x=-0.5, y=5.47, z=2},
    rotation = {x=19.28, y=180, z=0},
    callback_function = function(obj) obj.setLock(true) end
   })

   Wait.time(function()
     chapterCard.setPositionSmooth({x=-3.50, y=3.00, z=-0.50})
     chapterCard.setRotationSmooth({x=19.28, y=180, z=180})

     -- Populate character queue and missions
     getObjectFromGUID("afb371").call("Populate_Queue")
     getObjectFromGUID("afb371").call("Populate_Missions")
   end, waitTime)

   U.forEach({"Red", "Yellow", "Blue"}, function(color)
     Player[color].setCameraMode("ThirdPerson")
     Player[color].lookAt({
       position = {x=-0.5,y=-2,z=4.75},
       pitch = 70.72,
       yaw = 0,
       distance = 11
     })
   end)

  -- UI.show("setupReminder")

  -- Reset any tags set on player Leader Card spaces
  getObjectFromGUID(G.playerSpaces.Red.leaderCard).setTags({"Red"})
  getObjectFromGUID(G.playerSpaces.Yellow.leaderCard).setTags({"Yellow"})
  getObjectFromGUID(G.playerSpaces.Blue.leaderCard).setTags({"Blue"})
end
function M.gameINIT()
  if not M.checkLastChapterStandings() then
    M.determineLastChapterStandings(M.gameINIT)
    return
  end

  if not missionDeck then
    missionDeck = U.findAboveObject(getObjectFromGUID(G.decks.missionSpot), "Deck")[1]
  end

  M.syncState()

  local chapterData = M.getStateVal("chapterData")

  UI.setValue("lastChapterStandingsNotice-title", "Chapter " .. chapterData.lastChapterNum .. " Standings:")
  UI.setValue("logoIntro-title", "Chapter " .. chapterData.chapterNum .. " — " .. string.upper(chapterData.location))
  UI.setValue("logoIntro-subtitle", "(" .. chapterData.years .. ")")
  UI.setValue("logoIntro-body", chapterData.chapterBlurb)

  local timeOnScreen = 5
  local timePadding = 0.5
  local timeStep = 1

  U.splashUIElement("logoIntro", timeOnScreen)
  U.splashUIElement("logoIntro-title", 10, timePadding)
  U.splashUIElement("logoIntro-subtitle", 10, timePadding + timeStep)
  U.splashUIElement("logoIntro-body", 10, timePadding + (timeStep * 2))

  local timePassed = timeOnScreen + (2 * timePadding)

  timeOnScreen = 6

  U.splashUIElement("lastChapterStandingsNotice", timeOnScreen, timePassed)
  U.splashUIElement("lastChapterStandingsNotice-title", 10, timePassed)
  U.splashUIElement("lastChapterStandingsNotice-subtitle1", 10, timePassed + timeStep)
  U.splashUIElement("lastChapterStandingsNotice-subtitle2", 10, timePassed + timeStep * 1.5)
  U.splashUIElement("lastChapterStandingsNotice-subtitle3", 10, timePassed + timeStep * 2)
  U.splashUIElement("lastChapterStandingsNotice-subtitle4", 10, timePassed + timeStep * 3)
  U.splashUIElement("lastChapterStandingsNotice-subtitle5", 10, timePassed + timeStep * 3.5)
  U.splashUIElement("lastChapterStandingsNotice-subtitle6", 10, timePassed + timeStep * 4)

  timePassed = timePassed + timeOnScreen + timePadding

  U.splashUIElement("splash-backdrop", timePassed)

  Wait.time(function()
    if chapterCard then
      chapterCard.setLock(false)
      chapterCard.setRotationSmooth({x=0, y=180, z=0})
      missionDeck.putObject(chapterCard)
    end

		-- Deal out contents of players' havens to hand.
    for _, color in pairs({"Red", "Yellow", "Blue"}) do
        local haven = getObjectFromGUID(G.playerSpaces[color].haven)
        haven.deal(100, color)
    end
    local clanChooser = M.getNextPlayer()
    M.setHighlighter("TurnIndicator", "strong", clanChooser)
    UI.show("clanChoiceAlert")
    UI.setValue("chooseClanPlayer", C.Names[clanChooser])
    UI.setAttribute("chooseClanPlayer", "color", clanChooser)
    U.splashUIElement("chooseClanNotice", 5)
    M.displayClanSelectionRing()
    Player.Red.lookAt({position = {x=0,y=5,z=-15}, pitch = 63, yaw = 0, distance = 30})
    Player.Yellow.lookAt({position = {x=0,y=5,z=-15}, pitch = 63, yaw = 0, distance = 30})
    Player.Blue.lookAt({position = {x=0,y=5,z=-15}, pitch = 63, yaw = 0, distance = 30})

		M.hideHavens()
		M.showPouches()

  end, timePassed + (2 * timePadding))
end
local function getSchemesDeck(color)
  local deck = U.findAboveObject(getObjectFromGUID(G.playerSpaces[color].schemeDeck), "Deck")[1]
  if not deck then return false end
  return deck
end
local function getSchemesDiscard(color)
  local deck = U.findAboveObject(getObjectFromGUID(G.playerSpaces[color].schemeDiscard), "Deck")[1]
  if not deck then
    local card = U.findAboveObject(getObjectFromGUID(G.playerSpaces[color].schemeDiscard), "Card")[1]
    if not card then return false end
    return card
  end
  return deck
end
function M.initializeClanLeader(col)
  local leaderClan = M.getClans()[col]
  local leaderCard = Z.getClanLeader(col)
	local leaderZone = getObjectFromGUID(G.zones[col].bloodline[1][1])
	for _, powerToken in pairs(Z.getTaggedZoneObjects(leaderZone, "Power")) do
		powerToken.setLock(false)
	end
  local leaderName = leaderCard.getName()
  local leaderSchemes = leaderCard.getDescription()
  local leaderMorality
  if not leaderName then return false end
  if leaderCard.hasTag("DoubleSided") then
    local leaders = U.split(leaderName, "|")
    local schemes = U.split(leaderSchemes, "|")
    if (U.isFlipped(leaderCard)) then
      leaderName = leaders[2]
      leaderSchemes = schemes[2]
    else
      leaderName = leaders[1]
      leaderSchemes = schemes[1]
    end
  end
  if string.match(leaderName, ":M") ~= nil then
    leaderMorality = "M"
  else
    leaderMorality = "C"
  end
  local moralityToken = getMoralityToken(col)
	if moralityToken ~= nil then
		local moralityPosition = moralityToken.getPosition()
		moralityPosition.y = moralityPosition.y + 1
		local moralityRotation = moralityToken.getRotation()
		if C.MoralityTokens[leaderClan] == leaderMorality then
			moralityRotation.z = 0
		else
			moralityRotation.z = 180
		end
		moralityToken.setPosition(moralityPosition)
		moralityToken.setRotation(moralityRotation)
	end
  leaderName = string.gsub(leaderName, ":.", "")
  local schemesDeck = getSchemesDeck(col)
	if schemesDeck ~= nil then
		local schemesToDeal = {}
		for _, obj in pairs(schemesDeck.getObjects()) do
			if string.match(leaderSchemes, obj.name) ~= nil then
				table.insert(schemesToDeal, obj.guid)
			end
		end
		for i, cardID in pairs(schemesToDeal) do
			local pos = schemesDeck.getPosition()
			pos.x = pos.x - 2.5 + (2.5 * (i - 1))
			pos.z = pos.z + 4
			schemesDeck.takeObject({
				flip = true,
				position = pos,
				guid = cardID,
				callback_function = function(card)
					card.deal(1, col)
				end
			})
		end
  end
end
function M.clearUnusedClanLeaders()
  local usedClanLeaderIDs = {
    Z.getClanLeader("Red").guid,
    Z.getClanLeader("Yellow").guid,
    Z.getClanLeader("Blue").guid
  }
  local unusedClanLeaders = U.filter(getObjectsWithTag("ClanLeader"), function(obj) return not U.isIn(obj.guid, usedClanLeaderIDs) end)
  for _, obj in pairs(unusedClanLeaders) do
		local targetContainer
    if obj.hasTag("Red") then
			targetContainer = getObjectFromGUID(G.playerSpaces.Red.pouch)
    elseif obj.hasTag("Blue") then
      targetContainer = getObjectFromGUID(G.playerSpaces.Yellow.pouch)
    elseif obj.hasTag("Yellow") then
      targetContainer = getObjectFromGUID(G.playerSpaces.Blue.pouch)
    else
      local clan = U.findClanTag(obj)
      if (clan) then
        targetContainer = getObjectFromGUID(G.mainStorage.clanStorage[clan])
      end
    end
		targetContainer.putObject(obj)
  end
end

function M.removeUnusedClanRefs()
	local clans = M.getClans()
	local round, turn = M.getRoundAndTurn()
	if round > 0 and round < 10 then
		for _, clan in pairs(C.Clans) do
			if not U.isIn(clan, clans) then
				for _, color in pairs({"Red", "Yellow", "Blue"}) do
					UI.hide("hudRef" .. clan .. color)
					UI.hide("hudRef" .. clan .. color .. "Overlay")
				end
			end
		end
		for _, col in pairs(C.Colors) do
      UI.setAttributes("hudSidebar" .. col, {
        rectAlignment = "MiddleRight",
        height = "360",
        offsetXY = "0 0"
      })
    end
	end
end

function M.gameSTART()
  -- local mainStorage = getObjectFromGUID(G.mainStorage.id)
    -- UI.hide("setupReminder")
    UI.hide("RedClanChoice")
    UI.hide("YellowClanChoice")
    UI.hide("BlueClanChoice")
    UI.hide("clanChoiceAlert")
    UI.hide("chooseStrandsOfTimeNotice")

		M.hideHavens()
		M.hidePouches()

    -- H.boxStrandsOfTime()  -- Must wait until we have at least one more to keep it a deck!

    M.clearUnusedClanLeaders()
    for _, col in pairs(C.Colors) do
      M.initializeClanLeader(col)
    end

    U.splashUIElement("splash-backdrop", 4)
    U.splashUIElement("gameStartNotice", 3, 0.5)

    M.setRoundAndTurn(1, 1)
		M.removeUnusedClanRefs()
    M.determineTurnOrder(M.syncTurnOrder)
end

local function getSortedVictoryBoardSnapPoints(victoryBoard)
  local snapPointPositions = U.map(U.getSnapPointPositions(victoryBoard), function(posData) return U.roundTableVals(posData) end)
	snapPointPositions = U.getSnapPointPositions(victoryBoard)
  table.sort(snapPointPositions, function(a,b)
    if (math.abs(a.z - b.z) <= 0.2) then
      return a.x > b.x
    end
    return a.z < b.z
  end)
  return snapPointPositions
end

local function getClanToken(playerColor)
  local clan = M.getStateVal("clans", playerColor)
  if (clan == nil) then return false end
  local tokenName = clan .. " Clan Token"
  local token = U.find(Global.getObjects(), function (obj) return obj.getName() == clan .. " Clan Token" end)
  if (token == nil) then return false end
  return token
end

function M.updatePlayerScore(color)
	local playerName = C.Names[color]
	local playerScore = Z.scoreBloodline(color)
	UI.setValue(color .. "Score", playerName .. "'s Bloodline: " .. playerScore .. " points.")
	UI.show(color .. "Score")
	local token = getClanToken(color)
	local victoryBoard = getObjectFromGUID(G.victoryBoard)
	if (token and victoryBoard) then
		-- local positions = U.map(getSortedVictoryBoardSnapPoints(victoryBoard), function(pos) return victoryBoard.positionToWorld({
		-- 	x = pos.x,
		-- 	y = pos.y + 1,
		-- 	z = pos.z - 0.1
		-- }) end)
		-- local scorePos
		-- if playerScore > 0 then
		-- 	if playerScore > 60 then playerScore = 60 end
		-- 	scorePos = positions[playerScore]
		-- else
			scorePos = G.tableSpots.clanTokenVictory[color]
		-- end
		token.setPositionSmooth(scorePos, false, true)
		token.setRotationSmooth(G.tableSpots.clanTokenVictory.rotation, false, true)
		token.setScale(G.tableSpots.clanTokenVictory.scale)
		token.setColorTint(color)
	end
end

local function scoreBloodlines()
  Z.showScores()
  local waitStep = 2
  UI.show("scoreAlert")
  for i, color in pairs(C.Colors) do
		Wait.time(function() M.updatePlayerScore(color) end, waitStep * (i - 1))
  end
end
local function hideBloodlinesScore()
  Z.hideScores()
  UI.hide("scoreAlert")
  for _, color in pairs(C.Colors) do
    UI.hide(color .. "Score")
    Wait.time(function() UI.setValue(color .. "Score", "") end, 1)
  end
end

function M.showVictoryBoard()
  local mainStorage = getObjectFromGUID(G.mainStorage.id)
  local victoryTable = getObjectFromGUID(G.victoryTable)
  victoryTable.setInvisibleTo({})
  victoryTable.setPositionSmooth(G.tableSpots.victory.table, false, true)
  victoryTable.setRotationSmooth(G.tableSpots.victory.rotation, false, true)
  mainStorage.takeObject({
    position = G.tableSpots.victory.board,
    rotation = G.tableSpots.victory.rotation,
    guid = G.victoryBoard,
    smooth = false
  })
  for _, pColor in pairs(C.Colors) do
    local token = getClanToken(pColor)
    if (token) then
      token.setPositionSmooth(G.tableSpots.clanTokenVictory[pColor], false, true)
      token.setRotationSmooth(G.tableSpots.clanTokenVictory.rotation, false, true)
      token.setScale(G.tableSpots.clanTokenVictory.scale)
      token.setColorTint(pColor)
    end
  end
end

function M.getVictoryBoardTokenPositions()
  local victoryBoard = getObjectFromGUID(G.victoryBoard)
  local clanTokens = U.findAboveObject(victoryBoard, "Tile")
  local snapPointPositions = getSortedVictoryBoardSnapPoints(victoryBoard)
  local tokenPositions = U.map(clanTokens, function(token)
    return U.findSnapPoint(
      snapPointPositions,
      token.getPosition(),
      0.15
    )
  end)
  -- log({TOKENS = tokenPositions})
end

function M.hideVictoryBoard()
  local mainStorage = getObjectFromGUID(G.mainStorage.id)
  local victoryTable = getObjectFromGUID(G.victoryTable)
  local victoryBoard = getObjectFromGUID(G.victoryBoard)
  local clanTokens = U.filter(Global.getObjects(), function (obj) return string.match(obj.getName(), "Clan Token") ~= nil end)
  -- log({TOKENS = clanTokens})
  mainStorage.putObject(victoryBoard)
  for _, token in pairs(clanTokens) do
    token.setColorTint("White")
    token.setScale({x = 0.24, y = 1, z = 0.24})
    mainStorage.putObject(token)
  end
  victoryTable.setInvisibleTo({"Red", "Yellow", "Blue"})
  victoryTable.setPosition({x = 0, y = 50, z = 0})
end

function M.gameSCORE()
  M.showVictoryBoard()
  scoreBloodlines()
  M.recallSchemeDiscard()
  M.recallStrandsOfTime()
end

function M.recallSchemeDiscard()
  for _, color in pairs(C.Colors) do
    local sDiscardDeck = getSchemesDiscard(color)
    if (sDiscardDeck) then
      local schemeDeckPos = getObjectFromGUID(G.playerSpaces[color].schemeDeck).getPosition()
      schemeDeckPos.y = schemeDeckPos.y + 1
      sDiscardDeck.setPosition(schemeDeckPos)
      sDiscardDeck.setRotation({x = 0, y = 180, z = 180})
    end
  end
end

function M.recallStrandsOfTime()
  local strand = U.findAboveObject(getObjectFromGUID(G.decks.strandOfTimeSpot), "Card")[1]
  local strandStaging = getObjectFromGUID(G.decks.unusedStrandsOfTime)
  local strandStagingPos = strandStaging.getPosition()
  strandStagingPos.y = strandStagingPos.y + 1
  strand.setRotation({x = 0, y = 180, z = 0})
  strand.setPosition(strandStagingPos)
  Wait.time(function()
    local strandsDeck = U.findAboveObject(strandStaging, "Deck")[1]
    local mainStorage = getObjectFromGUID(G.mainStorage.id)
    mainStorage.putObject(strandsDeck)
  end, 1)
end

function M.recallSchemes()
  -- Get table of all scheme cards and decks both in hands and globally
  -- MUST DO THIS BEFORE PRESENTING UNLOCKED SCHEME DECK TO VANIQUISHED

  local schemeDecks = {}
  local schemeDeckGUIDs = {}
  for color, clan in pairs(M.getClans()) do
    schemeDecks[clan] = getSchemesDeck(color)
    if (schemeDecks[clan]) then
      table.insert(schemeDeckGUIDs, schemeDecks[clan].guid)
    end
  end

  -- Clan Schemes on Table (excluding scheme deck itself)
  local clanSchemes = U.filter(getObjectsWithTag("ClanScheme"), function(obj) return not U.isIn(obj.guid, schemeDeckGUIDs) end)

  -- Clan Schemes in Hand
  for _, player in ipairs(Player.getPlayers()) do
    local handSchemes = U.filter(player.getHandObjects(), function(obj) return obj.hasTag("ClanScheme") end)
    clanSchemes = U.concat(clanSchemes, handSchemes)
  end

  -- For each scheme, return it to proper scheme deck
  for _, schemeObj in pairs(clanSchemes) do
    local thisClan = U.findClanTag(schemeObj)
    local thisSchemeDeck = schemeDecks[thisClan]
		if thisSchemeDeck then
    	thisSchemeDeck.putObject(schemeObj)
		end
  end
  -- -- Create table mapping CLAN to SCHEME DECK STAGING setPosition
  -- -- as well as getting clan schemes in players' hands
  -- local posMap = {}
  -- for color, clan in pairs(H.getClans()) do
  --   local schemeDeckPos = getObjectFromGUID(G.playerSpaces[color].schemeDeck).getPosition()
  --   schemeDeckPos.y = schemeDeckPos.y + 1
  --   posMap[clan] = schemeDeckPos
  -- end
  --
  -- -- Recursively iterate through found schemes, rotate them properly, return to schemes deck Location
  -- function recurScheme()
  --   local thisScheme = table.remove(clanSchemes, 1)
  --   if not thisScheme then return end
  --   local thisClan = U.findClanTag(thisScheme)
  --   local thisPos = posMap[thisClan]
  --   log("======")
  --   log(thisClan)
  --   log(thisPos)
  --   log(thisScheme.guid)
  --   thisScheme.setPosition(thisPos)
  --   thisScheme.setRotation({x = 0, y = 180, z = 180})
  --   Wait.time(recurScheme, 0.25)
  -- end
  --
  -- recurScheme()
  -- Also Strands of Time
end

function M.gameMISSIONS()
  M.askLastChapterStandings(function()
    hideBloodlinesScore()
    M.recallSchemes()
    M.presentObligationsToVictor()
    M.presentLockedSchemesToVanquished()
    M.clearPlayerZones(1)
		Z.discardTorporedVamps()
    M.hideVictoryBoard()
		M.showHavens()
		M.showPouches()
    for _, color in pairs({"Red", "Yellow", "Blue"}) do
      M.showUpdatedTraits(color)
    end
  end)
end

function M.gameAFTERMATH()
  M.boxObligations()
  M.boxLockedSchemes()
	M.hidePouches()
  Wait.time(function() M.clearPlayerZones(2) end, 1)
end

function M.gameEND()
  M.clearPlayerZones(3)
  Wait.time(function() M.packClanStorageBoxes() end, 1)
  Wait.time(function() M.resetGameState() end, 2)
  Wait.time(function()
		M.showHavens()
		M.showPouches()
	end, 2.5)
end

function M.packClanStorageBoxes()
  local mainStorage = getObjectFromGUID(G.mainStorage.id)
  for color, clan in pairs(M.getClans()) do
    local clanChest = getObjectFromGUID(G.mainStorage.clanStorage[clan])
    mainStorage.putObject(clanChest)
  end
end

local function clearAllTokens()
  U.forEach(U.filter(getAllObjects(), function (obj) return
    obj.getName() == "Power"
    or obj.getName() == "Infamy"
    or obj.getName() == "Torpor/Exhaustion"
  end), function(obj) obj.destruct() end)
end

function M.clearPlayerZones(clearanceLevel)
  -- Clearance Level 1 (default) --> Power, Infamy, Exhaustion, Boons, Morality, Ankhs
  -- Clearance Level 2 --> Clan Leader
  -- Clearance Level 3 --> Torpor, Characters
  if (not clearanceLevel) then clearanceLevel = 1 end
  local characterDeckSpot = getObjectFromGUID(G.decks.characterSpot)
  local characterDeck = U.findAboveObject(characterDeckSpot, "Deck")[1]
  local characterDiscardDeck = U.findAboveObject(getObjectFromGUID(G.decks.characterDiscardSpot), "Deck")[1]
  if (characterDiscardDeck) then
    if (characterDeck) then
      characterDeck.putObject(characterDiscardDeck)
    else
      local charDeckPos = characterDeckSpot.getPosition()
      charDeckPos.y = charDeckPos.y + 1
      characterDiscardDeck.setRotation({x = 0, y = 180, z = 180})
      characterDiscardDeck.setPosition(charDeckPos)
      characterDeck = characterDiscardDeck
    end
  else
    local charDiscard = U.findAboveObject(getObjectFromGUID(G.decks.characterDiscardSpot), "Card")[1]
    if (charDiscard) then
      characterDeck.putObject(charDiscard)
    end
  end
  local charQueueZone = getObjectFromGUID(G.zones.charQueueArea)
  for _, obj in pairs(charQueueZone.getObjects()) do
    if (obj.hasTag("Character")) then
      characterDeck.putObject(obj)
    end
  end
  for _, color in pairs(C.Colors) do
    local aftermathZone = getObjectFromGUID(G.zones[color].aftermath)
    local moralityToken = getMoralityToken(color)
    if (moralityToken) then
      local playerChest = getObjectFromGUID(G.mainStorage.clanStorage[M.getClans()[color]])
      playerChest.putObject(moralityToken)
    end
    for _, obj in pairs(aftermathZone.getObjects()) do
      if string.find(obj.getName(), "Power")
        or string.find(obj.getName(), "Infamy")
				or obj.hasTag("Ankh")
        or string.find(obj.getName(), "Torpor") and (clearanceLevel == 3 or not U.isFlipped(obj)) then
          obj.destruct()
      end
      if string.find(obj.getName(), "Boon") then
        local boonClan = string.gsub(obj.getName(), " Boon", "")
        local clanChest = getObjectFromGUID(G.mainStorage.clanStorage[boonClan])
        clanChest.putObject(obj)
      end
      if (clearanceLevel > 1) then
        if (obj.hasTag("ClanLeader")) then
          if obj.hasTag("Red") then
            obj.setPosition(G.tableSpots.claimedClanLeader.Red)
          elseif obj.hasTag("Blue") then
            obj.setPosition(G.tableSpots.claimedClanLeader.Blue)
          elseif obj.hasTag("Yellow") then
            obj.setPosition(G.tableSpots.claimedClanLeader.Yellow)
          else
            local clan = M.getClans()[color]
            local clanChest = getObjectFromGUID(G.mainStorage.clanStorage[clan])
            clanChest.putObject(obj)
          end
        end
        if (clearanceLevel > 2) then
          if (obj.hasTag("Character")) then
            characterDeck.putObject(obj)
          end
          if (obj.hasTag("ClanScheme")) then
            local playerChest = getObjectFromGUID(G.mainStorage.clanStorage[M.getClans()[color]])
            playerChest.putObject(obj)
          end
        end
      end
    end

  end
  if clearanceLevel == 3 then
    clearAllTokens()
  end
	Wait.time(function() Z.refreshUI() end, 1)
end

function M.highlightBattlegrounds()
	for _, loc in pairs({"left", "center", "right"}) do
		M.setHighlighter("BGIndicator", "active", loc)
	end
end

-- *** GAME STATE VALUE CONTROL ***

function M.syncState()
    function parseInt(val)
        if (val == nil) then return 0 end
        return val * 1
    end
    function parseString(val)
        if (val == nil) then return "" end
        return val
    end
    function parseBool(val)
        if (val == true) then return "true" end
        return "false"
    end

    local clans = M.getClans()
    if (clans == nil) then M.setStateVal("clans", {Red = nil, Yellow = nil, Blue = nil}) end
    clans = M.getClans()

    M.determineTurnOrder(function()
      M.syncTurnOrder()
      local lastChapterStandings = M.getLastChapterStandings()
      local round, turn = M.getRoundAndTurn()
      local clans = M.getClans()
      local turnOrder = M.getTurnOrder()
      if (round > 0 and round < 10) then
        M.readTurnOrderFromBG()
      end

      for i = 1, 3, 1 do
        UI.setValue("lastChapterStandingsNotice-subtitle" .. i, parseString(C.Names[parseString(lastChapterStandings[i])]))
        UI.setAttribute("lastChapterStandingsNotice-subtitle" .. i, "color", parseString(lastChapterStandings[i]))
      end

      for _, color in ipairs(turnOrder) do
        if (clans[color] ~= nil) then
          UI.setValue(color .. "ClanChoice", C.Names[color] .. " chooses Clan " .. clans[color])
        end
      end
      UI.setValue("lastChapterStandingsNotice-subtitle5", parseString(C.Names[lastChapterStandings[3]]))
      UI.setAttribute("lastChapterStandingsNotice-subtitle5", "color", parseString(lastChapterStandings[3]))

      -- M.refreshStateDebug(state)

      M.setHighlighter("ClanSelection", "inactive")
      M.setHighlighter("TurnIndicator", "inactive", "Red")
      M.setHighlighter("TurnIndicator", "inactive", "Yellow")
      M.setHighlighter("TurnIndicator", "inactive", "Blue")

      if (round == 0) then
        if (clans.Red or clans.Yellow or clans.Blue) then
          local clanChooser = M.getNextPlayer()
          if (clanChooser ~= nil) then
            M.setHighlighter("ClanSelection", "active")
            M.setHighlighter("TurnIndicator", "strong", clanChooser)
            UI.setValue("chooseClanPlayer", C.Names[clanChooser])
            UI.setAttribute("chooseClanPlayer", "color", clanChooser)
            U.splashUIElement("chooseClanNotice", 5)
          end
          for color, clan in pairs(clans) do
            if (clan ~= nil) then
              UI.show(color .. "ClanChoice")
            else
              UI.hide(color .. "ClanChoice")
            end
          end
          UI.show("clanChoiceAlert")
        end
      else
        -- UI.hide("setupReminder")
        UI.hide("clanChoiceAlert")
      end

      if (round >= 1 and round <= 9) then
        UI.show("turnTracker")
        M.syncTurnTracker()
      else
        UI.hide("turnTracker")
      end
  end)
end

function M.refresh() M.syncState() end

function M.setHighlighter(ref, mode, subRef)
  -- local round, turn = H.getRoundAndTurn()
    local obj
    if (ref == "ClanSelection") then
        obj = getObjectFromGUID(G.highlighters.clanSelection)
        obj.setPosition(G.tableSpots.highlighters.clanSelection[mode])
    elseif (ref == "TurnIndicator") then
      -- if round > 9 then
        -- mode = "inactive"
      -- end
      if not subRef then
        for _, color in pairs({"Red", "Yellow", "Blue"}) do
          M.setHighlighter(ref, mode, color)
          return
        end
      end
      obj = getObjectFromGUID(G.highlighters.turnIndicator[subRef])
      obj.setPosition(G.tableSpots.highlighters.turnIndicator[subRef][mode])
    elseif (ref == "BGIndicator") then
      -- if round > 9 then
        -- mode = "inactive"
      -- end
      if not subRef then
        for _, loc in pairs({"left", "center", "right"}) do
          M.setHighlighter(ref, mode, loc)
          return
        end
      end
      obj = getObjectFromGUID(G.highlighters.bgIndicator[subRef])
      obj.setPosition(G.tableSpots.highlighters.bgIndicator[subRef][mode])
    end

    if (mode == "inactive") then
        obj.setInvisibleTo({"Red","Blue","Yellow"})
    else
        obj.setInvisibleTo({})
    end
end

local decksOnBoard = {}

function M.presentDeck(deckTags, playerColor, position, options)
  local mainStorage = getObjectFromGUID(G.mainStorage.id)
  if (position == nil) then
    position = G.tableSpots.staging[playerColor]
  end
  local deckData = U.find(mainStorage.getObjects(), function (obj)
    for _, tag in pairs(deckTags) do
      if not U.isIn(tag, obj.tags) then return false end
    end
    return true
  end)
	local rotation = {x = 0, y = 180, z = 180}
	if options and options.isFlipped then
		rotation.z = 0
	end

  decksOnBoard[deckTags[1]] = mainStorage.takeObject({
      position = position,
      rotation = rotation,
			smooth = false,
      guid = deckData.guid,
			callback_function = function(deck)
				Wait.frames(function()
					if options and options.spread then
						decksOnBoard[deckTags[1]].spread(options.spread)
					end
				end)
			end
    })
end
function M.presentObligationsToVictor() M.presentDeck({"Obligation"}, M.getLastChapterVictor()) end
function M.presentLockedSchemesToVanquished() M.presentDeck({"ClanScheme", M.getStateVal("clans", M.getLastChapterVanquished())}, M.getLastChapterVanquished()) end
function M.presentStrandsOfTimeToVanquished()
  M.presentDeck({"StrandsOfTime"}, M.getLastChapterVanquished(), G.tableSpots.strandsOfTime, {spread = -2.5})
end
function M.presentStrandsOfTimeToMiddle()
  M.presentDeck({"StrandsOfTime"}, M.getLastChapterMiddle(), G.tableSpots.strandsOfTime, {spread = -2.5})
end

function M.boxDeck(deck)
  if not deck then return false end
  local mainStorage = getObjectFromGUID(G.mainStorage.id)
  mainStorage.putObject(deck)
end

function M.hideUnusedStrandsOfTime(usedGuid)
  local round, turn = M.getRoundAndTurn()
  if (round ~= 0) then return end
  local strandObjs = getObjectsWithTag("StrandsOfTime")
  local cardPos = getObjectFromGUID(G.decks.unusedStrandsOfTime).getPosition()
  cardPos.y = cardPos.y + 1
  for _, card in pairs(strandObjs) do
    if card.guid ~= usedGuid then
      card.setRotation({x = 0, y = 180, z = 0})
      card.setPosition(cardPos)
    end
  end
end

function M.boxObligations() return M.boxDeck(decksOnBoard.Obligation) end
function M.boxLockedSchemes() return M.boxDeck(decksOnBoard.ClanScheme) end
function M.boxStrandsOfTime() return M.boxDeck(decksOnBoard.StrandsOfTime) end

function M.ignorePlayerTurn(currentTurnColor)
  local round, turn = M.getRoundAndTurn()
    if (round == 0) then return true end
    local turnOrder = M.getTurnOrder()
    local curColor = turnOrder[turn] or "NULL"
    if (M.getTurnOrder()[turn] == currentTurnColor) then return true end
    return false
end

function M.setCamera(player, zoomTarget)
  Player[player.color].setCameraMode("ThirdPerson")
  Player[player.color].lookAt(C.CameraAngles[zoomTarget])
  Wait.time(function() Player[player.color].setCameraMode("ThirdPerson") end, 0.5)
end

function M.askTraitsUpdate()
  local hostPlayer = U.getHost()
  local playerOptions = {"Gaius Marcellus", "Baron Samedi", "Jalan-Aayav"}
  local traitOptions = {"Kindred", "Mortals", "Wealth", "Subterfuge", "Warfare", "Occult", "Cruelty", "Mercy", "Detachment", "Camarilla", "Sabbat", "Anarchs", "Animalism", "Auspex", "Celerity", "Dominate", "Fortitude", "Obfuscate", "Oblivion", "Potence", "Presence", "Protean", "Blood_Sorcery"}
  hostPlayer.showOptionsDialog("Whose trait is increasing?", playerOptions, 1,
    function (playerName, _)
      hostPlayer.showOptionsDialog("What trait has increased?", traitOptions, 1,
        function (trait, index)
          local color
          if (playerName == "Gaius Marcellus") then color = "Red" end
          if (playerName == "Baron Samedi") then color = "Yellow" end
          if (playerName == "Jalan-Aayav") then color = "Blue" end
          M.addTraitDot(color, trait)
        end
      )
    end
  )
end

function M.addTraitDot(color, trait, rowNum)
  local playerData = M.getStateVal("traits", color)
  -- log("Player Data for " .. color .. ", Adding to '" .. trait .. "'")
  -- log(playerData)
  for i = 1, 5, 1 do
    -- log(playerData[i])
    for traitName, traitVal in pairs(playerData[i]) do
      -- log("... traitName = " .. traitName .. ", traitVal = " .. traitVal)
      if (trait == traitName) then
        -- log("MATCH!")
        playerData[i][traitName] = playerData[i][traitName] + 1
        M.setStateVal(playerData, "traits", color)
        M.showUpdatedTraits(color)
        return
      end
    end
  end
end

local function parseTraitsToXMLTable(traitsTable)
  function countTraitRows(ttable)
    local rowCount = 0
    for _, rowData in pairs(ttable) do
      if (U.count(U.filter(rowData, function(tVal) return tVal > 0 end)) > 0) then
        rowCount = rowCount + 1
      end
    end
    return rowCount
  end

  local XMLTable = {
    {
      tag = "Defaults",
      children = {
        {
          tag = "Panel",
          attributes = {
            class = "traits",
            color = "#000000",
            height = tostring(countTraitRows(traitsTable) * 60),
            width = "740",
            scale = "0.25 0.25 0.25 0.25",
            position = "45 35 -15",
            rotation = "0 0 180",
            -- active = "false",
            showAnimation = "FadeIn",
            hideAnimation = "FadeOut",
            animationDuration = "2"
          }
        },
        {
          tag = "Text",
          attributes = {
            color = "#999999",
            fontSize = "32",
            fontStyle = "Bold",
            flexibleWidth = "0"
          }
        },
        {
          tag = "Text",
          attributes = {
            class = "gold",
            color = "#FFFF00"
          }
        }
      }
    },
    {
      tag = "Panel",
      attributes = {
        class = "traits"
      },
      children = {
        {
          tag = "VerticalLayout",
          children = {}
        }
      }
    }
  }

  function parseRow(rowTable, class)
    local rowXMLTable = {
      tag = "HorizontalLayout",
      children = {}
    }
    if class == nil then class = "" end
    for traitName, traitNum in pairs(rowTable) do
      if (traitNum > 0) then
        hasNonZeroChildren = true
        table.insert(rowXMLTable.children,
          {
            tag = "Text",
            value = string.gsub(traitName, "_", " ") .. " " .. traitNum,
            attributes = {class = class}
          })
      end
    end
    if (hasNonZeroChildren) then return rowXMLTable end
    return false
  end

  for index, rowData in pairs(traitsTable) do
    local class
    if (index < #traitsTable) then
      class = "gold"
    else
      class = ""
    end
    local rowXML = parseRow(rowData, class)
    if (rowXML) then
      table.insert(XMLTable[2].children[1].children, parseRow(rowData, class))
    end
  end

  return XMLTable
end

function M.showUpdatedTraits(playerColor)
  local playerBoard = getObjectFromGUID(G.playerCards[playerColor])
  local playerData = M.getStateVal("traits", playerColor)
  local playerXML = parseTraitsToXMLTable(playerData)
  -- log(JSON.encode_pretty(playerXML))
  playerBoard.UI.setXmlTable(playerXML)
  Wait.time(function() playerBoard.UI.show("traits") end, 1)
end

function M.hideUpdatedTraits(playerColor)
  local playerBoard = getObjectFromGUID(G.playerCards[playerColor])
  playerBoard.UI.setXmlTable({{}})
end

return M
