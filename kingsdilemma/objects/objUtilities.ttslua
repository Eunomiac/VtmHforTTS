local U = require("lib.utilities")
local C = require("kingsdilemma.lib.constants")
local OU = {}

function OU.foldTransform(objOrTransform, positionDelta, rotationDelta)
	if U.Type(objOrTransform) == "userdata" and objOrTransform.getData ~= nil then
		objOrTransform = objOrTransform.getData().Transform
	end
	if U.Type(objOrTransform) ~= "table" then return end
	if U.Type(objOrTransform.Transform) == "table" then
		objOrTransform = objOrTransform
	end
	objOrTransform = U.clone(objOrTransform)

	if objOrTransform.posX ~= nil then
		if objOrTransform.rotX == nil then
			objOrTransform.rotX = 0
			objOrTransform.rotY = 0
			objOrTransform.rotZ = 0
		end
		if objOrTransform.scaleX == nil then
			objOrTransform.scaleX = 1
			objOrTransform.scaleY = 1
			objOrTransform.scaleZ = 1
		end
		objOrTransform = {
			position = Vector({objOrTransform.posX, objOrTransform.posY, objOrTransform.posZ}),
			rotation = Vector({objOrTransform.rotX, objOrTransform.rotY, objOrTransform.rotZ}),
			scale = Vector({objOrTransform.scaleX, objOrTransform.scaleY, objOrTransform.scaleZ}),
		}
	end

	if U.Type(objOrTransform.position) == "table" then
		if positionDelta ~= nil then
			objOrTransform.position = objOrTransform.position:add(positionDelta)
		end
		if rotationDelta ~= nil then
			objOrTransform.rotation = objOrTransform.rotation:add(rotationDelta)
		end
		return {
			position = Vector(objOrTransform.position),
			rotation = Vector(objOrTransform.rotation or {0, 0, 0}),
			scale = Vector(objOrTransform.scale or {1, 1, 1})
		}
	end
end

function OU.unfoldTransform(objOrTransform, positionDelta, rotationDelta)
	if positionDelta ~= nil or rotationDelta ~= nil then
		objOrTransform = OU.foldTransform(objOrTransform, positionDelta, rotationDelta)
	end
	if U.Type(objOrTransform) == "userdata" and objOrTransform.getData ~= nil then
		return objOrTransform.getData().Transform
	end
	if U.Type(objOrTransform) ~= "table" then return end
	if U.Type(objOrTransform.Transform) == "table" then
		return U.clone(objOrTransform.Transform)
	end

	if objOrTransform.position ~= nil then
		local position = Vector(objOrTransform.position)
		local rotation = Vector(objOrTransform.rotation or {0, 0, 0})
		local scale = Vector(objOrTransform.scale or {1, 1, 1})
		return {
			posX = position.x,
			posY = position.y,
			posZ = position.z,
			rotX = rotation.x,
			rotY = rotation.y,
			rotZ = rotation.z,
			scaleX = scale.x,
			scaleY = scale.y,
			scaleZ = scale.z
		}
	end

	if objOrTransform.posX ~= nil then
		return {
			posX = objOrTransform.posX,
			posY = objOrTransform.posY,
			posZ = objOrTransform.posZ,
			rotX = objOrTransform.rotX or 0,
			rotY = objOrTransform.rotY or 0,
			rotZ = objOrTransform.rotZ or 0,
			scaleX = objOrTransform.scaleX or 1,
			scaleY = objOrTransform.scaleY or 1,
			scaleZ = objOrTransform.scaleZ or 1
		}
	end
end
function OU.SpawnFromSourceObj(sourceObj, tags, transformData, positionDelta, rotationDelta)
	local spawnData = sourceObj.getData()
	local token
	spawnData.Transform = OU.unfoldTransform(transformData, positionDelta, rotationDelta)
	spawnData.Tags = tags
	spawnObjectData({
		data = spawnData,
		callback_function = function(obj)
			obj.setLock(false)
			token = obj
		end
	})
	return function() return token ~= nil and token.resting and not token.loading_custom end
end
function OU.TransferObjects(fromZone, toZone, tag)
	local objs = fromZone.getObjects()
	if tag ~= nil then
		objs = U.filter(objs, function(obj) return obj.hasTag(tag) end)
	end
	local toZoneBounds = toZone.getBounds()
	toZoneBounds.size = toZone.getScale()

	local function transferObj(obj)
		obj.setPosition(obj.getPosition():add(Vector(0, 1, 0)))
		obj.addForce(Vector(0, 50, 0), 3)
		Wait.time(function()
			obj.setPosition(U.getScatterPosition(toZoneBounds, 6, 0.4))
		end, 0.5)
	end

	U.sequence(U.map(objs, function(obj)
		return function() transferObj(obj) end
	end), 0.15)

end
function OU.getAngleOf(objOrTransform)
	local posData = OU.foldTransform(objOrTransform).position
	local zeroPos = Vector(0, 0, C.TableRadius)
	local angle = posData:angle(zeroPos)
	if posData.x < 0 then
		angle = 360 - angle
	end
	return angle
end

function OU.GetNearestAngle(objOrTransform, seatAngles)
	local objAngle = OU.getAngleOf(objOrTransform)
	table.insert(seatAngles, 1, 0)
	local nearestAngle = 1000
	U.forEach(seatAngles, function(pAngle)
		if math.abs(pAngle - objAngle) < math.abs(nearestAngle - objAngle) then
			nearestAngle = pAngle
		end
	end)
	return nearestAngle
end

function OU.RotateByAngle(objOrTransform, angleDelta)
	local objTransform = OU.foldTransform(objOrTransform)
	if objTransform == nil then return end
	return {
		position = Vector(objTransform.position):rotateOver("y", angleDelta),
		rotation = Vector(objTransform.rotation):add(Vector(0, angleDelta, 0)),
		scale = objTransform.scale
	}
end

function OU.GetStepsBetween(startVector, endVector, numSteps)
	-- Vector 5 -> Vector 3, 3 steps.  Distance = 2.  StepSize = Distance/(steps - 1)
	-- Vector 25 -> 20, 6 steps.  Distance = 5. StepSize = Distance/(steps - 1)
	local distVector = Vector(endVector):sub(Vector(startVector))
	local vectorDelta = Vector(distVector):scale(Vector(1/(numSteps - 1), 1/(numSteps - 1), 1/(numSteps - 1)))
	local steps = {}
	local curVector = Vector(startVector)
	while #steps < numSteps do
		table.insert(steps, Vector(curVector))
		curVector:add(Vector(vectorDelta))
	end

	-- log(steps)

	return steps
end

function OU.FindNearestSnapPoint(objOrTransform, obj, includeAll)
	local position = OU.foldTransform(objOrTransform).position

	local snapPoints, unfilteredSnaps
	if obj == nil then
		snapPoints = Global.getSnapPoints()
		unfilteredSnaps = Global.getSnapPoints()
	else
		snapPoints = obj.getSnapPoints()
		unfilteredSnaps = obj.getSnapPoints()
	end

	if U.isGameObject(objOrTransform) then
		local objTags = objOrTransform.getTags()
		snapPoints = U.filter(snapPoints, function(snap)
			-- log(snap)
			-- log({tags = U.join(snap.tags, ", "), objTags = U.join(objOrTransform.getTags(), ", "), hasAnyTags = objOrTransform.hasAnyTags(snap.tags)})
			if #U.getValues(snap.tags) == 0 then return true end
			return U.find(snap.tags, function(tag) return U.isIn(tag, objTags) end)
		end)
	end

	-- log({isGameObject = U.isGameObject(objOrTransform), objOrTransform = U.ToString(objOrTransform), numSnaps = #snapPoints, numUnfiltered = #unfilteredSnaps})

	local snapPositions = U.iMap(snapPoints, function(snap) return obj.positionToWorld(snap.position) end)
	local sortedPositions = U.clone(snapPositions)

	table.sort(sortedPositions, function(a, b) return Vector(a):distance(position) < Vector(b):distance(position) end)

	local distTolerance = 0.25 * (sortedPositions[1]:distance(sortedPositions[2]))

	-- log({sorted = sortedPositions})

	local nearestSnapPos = sortedPositions[1]

	if includeAll then
		return U.findIndex(unfilteredSnaps, function(objSnap)
			local snapPos = obj.positionToWorld(objSnap.position)
			return snapPos:distance(nearestSnapPos) < distTolerance
		end)
	else
		return U.findIndex(snapPoints, function(objSnap)
			local snapPos = obj.positionToWorld(objSnap.position)
			return snapPos:distance(nearestSnapPos) < distTolerance
		end)
	end
end

function OU.SetBoardSnapPoints()
	local board = O.UninteractableObjs.Board()
	local resourceHorizSteps = U.iMap(OU.GetStepsBetween(
		Vector(C.Spots.Board.ResourceTokens.Influence.center.position),
		Vector(C.Spots.Board.ResourceTokens.Knowledge.center.position),
		5
	), function(pos) return pos.x end)
	local cCardHorizSteps = U.iMap(OU.GetStepsBetween(
		Vector(C.Spots.Board.ChronicleStickers.top.position),
		Vector(C.Spots.Board.ChronicleStickers.bottom.position),
		3
	), function(pos) return pos.x end)
	local cCardVertSteps = U.iMap(OU.GetStepsBetween(
		Vector(C.Spots.Board.ChronicleStickers.top.position),
		Vector(C.Spots.Board.ChronicleStickers.bottom.position),
		5
	), function(pos) return pos.z end)

	-- log({horiz = cCardHorizSteps, vert = cCardVertSteps})

	local snapPoints = {}
	U.iForEach(OU.GetStepsBetween(
		C.Spots.Board.StabilityToken.bottom.position,
		C.Spots.Board.StabilityToken.top.position,
		19), function(pos)
			table.insert(snapPoints, {
				position = U.roundVector(board.positionToLocal(pos)),
				rotation = U.roundVector(Vector(C.Spots.Board.StabilityToken.top.rotation):sub(board.getRotation())),
				rotation_snap = true,
				tags = {"StabilityMarker"}
			})
		end)

	U.iForEach(C.Resources, function(resName, i)
		local startPos = Vector(C.Spots.Board.ResourceTokens[resName].bottom.position):setAt("x", resourceHorizSteps[i])
		local endPos = Vector(C.Spots.Board.ResourceTokens[resName].top.position):setAt("x", resourceHorizSteps[i])
		U.iForEach(OU.GetStepsBetween(
			startPos,
			endPos,
			17), function(pos)
				table.insert(snapPoints, {
					position = U.roundVector(board.positionToLocal(pos)),
					rotation = U.roundVector(Vector(C.Spots.Board.ResourceTokens[resName].top.rotation):sub(board.getRotation())),
					rotation_snap = false,
					tags = {resName}
				})
			end)
		end)


	U.iForEach(C.Resources, function(resName, i)
		for j = 1, 3 do
			local pos = Vector(C.Spots.Board.ChronicleStickers.top.position)
			pos.x = cCardHorizSteps[j]
			pos.z = cCardVertSteps[i]

			table.insert(snapPoints, {
				position = U.roundVector(board.positionToLocal(pos)),
				rotation = U.roundVector(Vector(C.Spots.Board.ChronicleStickers.top.rotation):sub(board.getRotation())),
				rotation_snap = true,
				tags = {"ChronicleSticker"}
			})
		end
	end)

	board.setSnapPoints(snapPoints)
	-- log(JSON.encode_pretty(snapPoints))
end

function OU.SetGlobalSnapPoints()

	Global.setSnapPoints({
		{
			position = Vector({9.15, 1.46, 19.00}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = true,
			tags = {"StoryCard"}
		},
		{
			position = Vector({9.15, 1.46, 12.81}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = true,
			tags = {"StoryCard"}
		},
		{
			position = Vector({9.15, 1.46, 6.61}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = true,
			tags = {"StoryCard"}
		},
		{
			position = Vector({9.15, 1.46, 0.41}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = true,
			tags = {"StoryCard"}
		},
		{
			position = Vector({9.15, 1.46, -5.78}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = true,
			tags = {"StoryCard"}
		},
		{
			position = Vector({9.15, 1.46, -11.98}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = true,
			tags = {"StoryCard"}
		},
		{
			position = Vector({9.15, 1.46, -18.17}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = true,
			tags = {"EventCard", "TriggerCard"}
		},
		{
			position = Vector({-7.4, 1.46, 8.05}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, 3.63}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -0.80}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -5.23}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -9.65}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -14.08}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -14.08}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -18.50}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -18.74}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -18.99}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -19.23}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -19.47}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		}
	})



end

function OU.FindContainedObjGUID(container, findFunc)
	U.Val("OU.FindContainedObjGUID", container, U.isGameObject(container), "'container' param is not a Game Object")
	U.Val("OU.FindContainedObjGUID", findFunc, U.Type(findFunc) == "function", "'findFunc' param is not a Function")
	local objData = U.find(container.getObjects(), findFunc)
	if objData == nil then return false end
	return objData.guid
end

return OU