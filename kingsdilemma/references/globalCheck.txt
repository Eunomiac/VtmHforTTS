-- Bundled by luabundle {"rootModuleName":"Global.-1.lua","version":"1.6.0"}
local __bundle_require, __bundle_loaded, __bundle_register, __bundle_modules = (function(superRequire)
	local loadingPlaceholder = {[{}] = true}

	local register
	local modules = {}

	local require
	local loaded = {}

	register = function(name, body)
		if not modules[name] then
			modules[name] = body
		end
	end

	require = function(name)
		local loadedModule = loaded[name]

		if loadedModule then
			if loadedModule == loadingPlaceholder then
				return nil
			end
		else
			if not modules[name] then
				if not superRequire then
					local identifier = type(name) == 'string' and '\"' .. name .. '\"' or tostring(name)
					error('Tried to require ' .. identifier .. ', but no such module has been registered')
				else
					return superRequire(name)
				end
			end

			loaded[name] = loadingPlaceholder
			loadedModule = modules[name](require, loaded, register, modules)
			loaded[name] = loadedModule
		end

		return loadedModule
	end

	return require, loaded, register, modules
end)(nil)
__bundle_register("Global.-1.lua", function(require, _LOADED, __bundle_register, __bundle_modules)
require("kingsdilemma")
end)
__bundle_register("kingsdilemma", function(require, _LOADED, __bundle_register, __bundle_modules)
-- DEVELOPMENT
require("vscode/console") -- *DEBUGLINE*

-- MODULES
-- U = require("lib.utilities")
-- C = require("kingsdilemma.lib.constants")
-- O = require("kingsdilemma.lib.objects")
-- S = require("kingsdilemma.core.state")
-- L = require("kingsdilemma.core.lighting")
-- V = require("kingsdilemma.core.voting")

-- gameState Variable Initialization
gameState = {}

-- COMPONENTS
-- require("kingsdilemma.debug")
require("kingsdilemma.hud")
require("kingsdilemma.listeners")
end)
__bundle_register("kingsdilemma.listeners", function(require, _LOADED, __bundle_register, __bundle_modules)
-- require("vscode/console")
local U = require("lib.utilities")
local OU = require("kingsdilemma.objects.objUtilities")
local S = require("kingsdilemma.core.state")
local C = require("kingsdilemma.lib.constants")
local L = require("kingsdilemma.core.lighting")
local P = require("kingsdilemma.core.players")
local MSG = require("kingsdilemma.core.messaging")
local DIR = require("kingsdilemma.core.director")


-- function GetSelectedObject()
-- 	for _, player in pairs(Player.getPlayers()) do
-- 		local selObjs = player.getSelectedObjects()
-- 		if selObjs and #selObjs > 0 then
-- 			return selObjs[1]
-- 		end
-- 	end
-- 	return getObjectFromGUID("e19593")
-- end

-- local autoExecString = {
-- 	">",
-- 	"alias list ls -a",
-- 	"alias show list -r"
-- }

-- U.forEach({
-- 	oFocus = {
-- 		"add /objectFocus Player",
-- 		"call /GetSelectedObject",
-- 		"set /objectFocus ~",
-- 		"call /stringColorToRGB Pink",
-- 		"add /hColor ~",
-- 		"call /objectFocus/highlightOn /hColor 5",
-- 		"echo 'Changing focus to highlighted object.'"
-- 	}
-- }, function (arrStr, name)
-- 	console[name] = U.join(arrStr, ";")
-- 	table.insert(autoExecString, "alias " .. name .. " exec -s /console/" .. name)
-- end)


-- console.autoexec = U.join(autoExecString, ";")


-- alias pFocus exec -q "`set pFocus Turns/turn_color; echo Focus changed; ls pFocus"
function onLoad(save_data)
	S.InitializeGameState(save_data)
	DIR.InitPreflight()
end

function onSave() return JSON.encode(S.getGameState()) end

-- function onUpdate() console.update() end

function onPlayerTurnStart(pColor)

	P.SetCamera("BehindScreen", pColor, "Brown")
end

function onPlayerAction(player, action, targets)
	if #targets == 0 then return true end
	if action == Player.Action.FlipOver then
		U.forEach(targets, function(target)
			if U.hasAnyTag(target, {"PowerToken", "CoinToken"}) then
				OU.SplitObjByValue(target)
			else
				target.flip()
			end
		end)
		return false
	elseif action == Player.Action.Group then
		if U.find(targets, function(target) return U.hasAnyTag(target, {"PowerToken", "CoinToken"}) end) then
			OU.CombineObjsByValue(targets)
		else
			return true
		end
		return false
	elseif action == Player.Action.Delete then
		if player.host then return true end
		U.forEach(targets, function(target)
			if U.hasAnyTag(target, {"PowerToken", "CoinToken"}) then
				target.destruct()
			end
		end)
		return false
	end
	-- 	local coinOrPower = U.filter(
	-- 		targets,
	-- 		function(obj) return U.hasAnyTag(obj, {"PowerToken", "CoinToken"}) end
	-- 	)

	-- 	if #coinOrPower == 0 then return false end

	-- 	if #coinOrPower == 1 then
	-- 		OU.SplitObjByValue(coinOrPower[1])
	-- 	else
	-- 		OU.CombineObjsByValue(coinOrPower)
	-- 	end

	-- 	return false
	-- end

	return true
end

function tryObjectEnterContainer(container, object)
	if container.hasTag("StoryCard") and object.hasTag("StoryCard") then return false end
	if container.hasTag("Played") and object.hasTag("Played") then return false end
	return true
end

function onObjectEnterZone(zone, obj)
	if zone.hasTag("EventCard") and obj.type == "Card" and U.hasAnyTag(obj, {"EventCard", "StoryCard"}) then
		obj.drop()
		U.waitUntil(
			function()
				if obj.hasTag("NotPlayed") then
					obj.setTags({"EventCard", "NotPlayed"})
				else
					obj.setTags({"EventCard", "Played"})
				end
				local playedEventCards = U.filter(getObjectsWithAllTags({"EventCard", "Played"}), function(o) return not o.hasTag("NotPlayed") end)
				local snapSpot = U.filter(C.SnapPoints.Global, function(sPoint) return U.isIn("EventCard", sPoint.tags) end)[#playedEventCards]

				U.setPositionSlow(obj, snapSpot.position, 1, nil, false)
				U.setRotationSlow(obj, Vector(snapSpot.rotation):setAt("z", U.pAngle(obj.getRotation().z, 90)), 1, nil, false)
			end,
			{0.3, obj}
		)
	end
end

local function getBoundedPos(obj, xMin, xMax, zMin, zMax)
	local pos = obj.getPosition()
	if pos.x > xMax then pos.x = xMax end
	if pos.x < xMin then pos.x = xMin end
	if pos.z > zMax then pos.z = zMax end
	if pos.z < zMin then pos.z = zMin end
	return Vector(pos)
end

function onObjectDrop(pColor, obj)
	if obj.hasTag("DebugObj") then return end
	if S.isInPhase({C.Phases.GAMESETUP.SecretAgendas, C.Phases.END.SecretAgendas}) and obj.hasTag("SecretAgenda") then
		local player = S.getPlayer(pColor)
		local handObjs = player.getHandObjects()
		if U.find(handObjs, function(o) return o.guid == obj.guid end) then return end
		DIR.AssignSecretAgenda(player, obj)
	elseif obj.hasTag("StabilityMarker") then
		U.RunSequence({
			function()
				return {obj, 0.1}
			end,
			function()
				obj.setPosition(getBoundedPos(
					obj,
					C.Spots.Board.StabilityToken.center.position.x,
					C.Spots.Board.StabilityToken.center.position.x,
					C.Spots.Board.StabilityToken.bottom.position.z,
					C.Spots.Board.StabilityToken.top.position.z
				))
				return obj
			end,
			function() L.SetLightMode("lightStability", "on") end
		})
	elseif obj.hasTag("ResourceMarker") then
		local resource = U.find({"Influence", "Wealth", "Morale", "Welfare", "Knowledge"}, function(res) return obj.hasTag(res) end)
		if resource == nil then return end

		U.RunSequence({
			function() return {obj, 0.1} end,
			function()
				obj.setPosition(getBoundedPos(
					obj,
					C.Spots.Board.ResourceTokens[resource].center.position.x,
					C.Spots.Board.ResourceTokens[resource].center.position.x,
					C.Spots.Board.ResourceTokens[resource].bottom.position.z,
					C.Spots.Board.ResourceTokens[resource].top.position.z
				))
				if S.isInMode(C.Modes.PLAY) then
					DIR.BumpToken("Stability", DIR.GetStabilityBump())
				end
				return obj
			end,
			function()
				if S.isInMode(C.Modes.PLAY) then
					DIR.UpdateTokenLight("Stability")
				end
				return DIR.UpdateTokenLight(resource)
			end
		})
	end
end

end)
__bundle_register("kingsdilemma.core.director", function(require, _LOADED, __bundle_register, __bundle_modules)
local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
local C = require("kingsdilemma.lib.constants")
local P = require("kingsdilemma.core.players")
local O = require("kingsdilemma.lib.objects")
local OU = require("kingsdilemma.objects.objUtilities")
local V = require("kingsdilemma.core.voting")
local L = require("kingsdilemma.core.lighting")
local MSG = require("kingsdilemma.core.messaging")
local HouseScreen = require("kingsdilemma.objs.p3screen")

local DIR = {}
local HOUSE_SELECTION, newPlayerColors = {}, {}

local ISDEBUGGING = false

-- #region Token Object Getters~
local function getBoardTokens()
	local tokens = {
		Stability = getObjectsWithTag("StabilityMarker")[1],
		resource = {}
	}
	local rTokens = getObjectsWithTag("ResourceMarker")
	table.sort(rTokens, function(a, b) return a.getPosition().x < b.getPosition().x end)
	tokens.resource.Influence = rTokens[1]
	tokens.resource.Wealth = rTokens[2]
	tokens.resource.Morale = rTokens[3]
	tokens.resource.Welfare = rTokens[4]
	tokens.resource.Knowledge = rTokens[5]
	return tokens
end

function DIR.GetTokenPositionsFromBoard()
	local board = O.UninteractableObjs.Board()
	local boardTokens = getBoardTokens()
	return {
		Stability = OU.FindNearestSnapPoint(boardTokens.Stability, board),
		Influence = OU.FindNearestSnapPoint(boardTokens.resource.Influence, board),
		Wealth = OU.FindNearestSnapPoint(boardTokens.resource.Wealth, board),
		Morale = OU.FindNearestSnapPoint(boardTokens.resource.Morale, board),
		Welfare = OU.FindNearestSnapPoint(boardTokens.resource.Welfare, board),
		Knowledge = OU.FindNearestSnapPoint(boardTokens.resource.Knowledge, board)
	}
end

local function getTokenMomentums()
	local boardTokens = getBoardTokens()
	local function getTokenMomentum(resource)
		local startTurnData = S.getStateVal("roundState", "boardTokens")
		if startTurnData == nil or startTurnData.momentum == nil or startTurnData.momentum[resource] == nil then
			local token = boardTokens.resource[resource]
			-- U.Assert("getTokenMomentum", token, "Object")
			return U.isFlipped(token) and -1 or 1
		else
			return startTurnData.momentum[resource]
		end
	end
	return {
		Influence = getTokenMomentum("Influence"),
		Wealth = getTokenMomentum("Wealth"),
		Morale = getTokenMomentum("Morale"),
		Welfare = getTokenMomentum("Welfare"),
		Knowledge = getTokenMomentum("Knowledge")
	}
end

local function getStickerData(stickerObj)
	if not stickerObj or not stickerObj.hasTag("ChronicleSticker") then return U.error("Not a Chronicle Sticker!") end
	local decalData = stickerObj.getDecals()
	local signDecal = U.find(decalData, function(dData) return string.match(dData.name, " Pos$") or string.match(dData.name, " Neg$") end)
	local house, status = unpack(U.split(signDecal.name, " "))
	local snapSlot = OU.FindNearestSnapPoint(stickerObj, O.UninteractableObjs.Board())
	local resource = C.Resources[math.ceil(snapSlot / 3)]
	local column = snapSlot % 3
	return {
		name = stickerObj.getName(),
		obj = stickerObj,
		age = #U.filter(decalData, function(dData) return dData.name == "z Black Box" end) + (column / 10),
		house = house,
		status = status,
		resource = resource,
		snapSlot = snapSlot
	}

	-- x = 1.695, y = 0.125, z = -0.247, 0.062, 0.356
end

function DIR.GetStickerData()
	local stickerData = U.map(getObjectsWithTag("ChronicleSticker"), function(obj) return getStickerData(obj) end)
	table.sort(stickerData, function(a, b) return a.snapSlot < b.snapSlot end)
	return stickerData
end




-- #endregion

-- #region INITIALIZATION FUNCTIONS
local agendaDeck, agendaCard
local displayCard
local queryResponse

INITFUNCS = {
	NONE = function() return {
		function()
			P.ClearSeats()
			S.resetGameState()
			MSG.Hide("refHUDControls")
			return 1
		end,
		function()
			DIR.InitPreflight()
			return 1
		end
	} end,
	SESSIONINIT = {
		SeatPlayers = function() return {
			S.UpdatedSeatedPlayerData,
			function()
				U.forEach(getObjectsWithTag("Capture"), function(obj) obj.destruct() end)
				return 0.5
			end,
			DIR.ADVANCE
		} end,
		HouseSelection = function() return {
			function()
				if #DIR.GetUnselectedPlayers() == 0 then return 0 end
				return U.RunSequence({
					function() return MSG.Splash("House Selection", nil, 2) end,
					function()
						HOUSE_SELECTION = {}
						DIR.InitHouseSelectionHUD()
						return function() return HOUSE_SELECTION.isComplete == true end
					end
				})
			end,
			function()
				newPlayerColors = {}
				U.forEach(HOUSE_SELECTION, function(houseName, color)
					if not color or not houseName then return end
					if not U.isIn(color, C.SeatColors) then return end
					local player = S.getPlayer(color)
					table.insert(newPlayerColors, color)
					S.setPlayerVal(houseName, player, "house")
					S.setPlayerVal(nil, player, "houseName")
				end)
				UI.setAttribute("houseSelectionHUD", "active", "false")
				MSG.Splash("Setting Up Play Spaces", nil, 5)
				return 0.5
			end,
			function()
				return U.map(S.getPlayers(), function(player)
					return HouseScreen.Spawn(
						player,
						S.getPlayerVal(player, "house"),
						U.isIn(player.color, newPlayerColors)
					)
				end)
			end,
			function() return 2 end,
			function()
				L.LoadLights({"lightBehind"}, "ambient", 1.5)
				return 0.75
			end,
			function()
				P.ActivatePlayerScreenHUD()
				L.LoadLights({ "lightFront", "lightMapAnkist", "lightMapWorld" }, "ambient")
				return 2
			end,
			DIR.ADVANCE
		} end
	},
	CHRONSETUP = function()
		return {
			function()
				U.Assert("INITFUNCS.CHRONSETUP", S.getStateVal("gameState", "gameCount") == 0)
				queryResponse = {Prologue = "D1", ["Main Story"] = "0"}
				return MSG.SplashQuery(
					"How do you want to start your\nChronicle of The King's Dilemma?",
					"Host",
					queryResponse,
					U.getHost()
				)
			end,
			function()
				MSG.Splash(P.GetLeaderName() .. " Is Most Prestigious")
				return L.SetLightMode("lightLeader", "on", nil, 0.5)
			end,
			P.AssignLeader,
			function()
				MSG.Splash(P.GetModeratorName() .. " Is Least Prestigious")
				return L.SetLightMode("lightModerator", "on", nil, 0.5)
			end,
			P.AssignModerator,
			function() return P.SetCamera("Lectern") end,
			function()
				L.LoadLights({ "lightLectern" }, "default")
				return MSG.Splash("Chronicle Setup")
			end,
			function()
				S.setStateVal(queryResponse.response, "gameState", "chronicleType")
				S.setStateVal(({
					["D1"] = "Harald IV",
					["0"] = "Harald V"
				})[queryResponse.response], "gameState", "kingName")
				return DIR.FetchEnvelope(queryResponse.response)
			end
		}
	end, -- a = function() log("a") end; nA = a; a = function() log("b"); nA() end; a()
	GAMESETUP = {
		InitializeState = function() return {
			function()
				MSG.Show("refHUDControls")
				L.SetLightMode("lightLectern", "default")
				S.LogGameStartTime()
				S.setStateVal(S.getStateVal("gameState", "gameCount") + 1, "gameState", "gameCount")
				return 0
			end,
			DIR.ADVANCE
		} end,
		MainBoard = function() return {
			function()
				P.SetCamera("MainBoard")
				DIR.AddToDilemmaDeck()
				L.SetLightMode({"lightMainTop", "lightMainBottom"}, "ambient")
				L.SetLightMode("lightFeature", "on")
				return MSG.Splash("Board Setup")
			end,
			DIR.SpawnBoardTokens,
			function()
				V.ElevateBalance()
				return L.SetLightMode("lightBalance", "bright", nil, 0.5)
			end,
			function()
				DIR.InitCountZones()
				V.SpawnBalanceTokens(3)
				L.SetLightMode("lightBalance", "on", nil, 3)
				return 1.5
			end,
			function() return P.SetCamera("BehindScreen") end,
			function()
				MSG.Splash("Distributing Power & Coin")
				return {
					DIR.SpawnStartingPlayerPower(),
					DIR.SpawnStartingPlayerCoins()
				}
			end,
			DIR.ADVANCE
		} end,
		LeaderModerator = function()
			if S.getStateVal("gameState", "leader") ~= nil then
				return {DIR.ADVANCE}
			else
				return {
					function()
						MSG.Splash(P.GetLeaderName() .. " Is Most Prestigious")
						return L.SetLightMode("lightLeader", "on", nil, 0.5)
					end,
					P.AssignLeader,
					function()
						MSG.Splash(P.GetModeratorName() .. " Is Least Prestigious")
						return L.SetLightMode("lightModerator", "on", nil, 0.5)
					end,
					P.AssignModerator,
					DIR.ADVANCE
				}
			end
		end,
		LegacySetup = function()
			local stickerData
			return {
				function()
					P.SetCamera("Stickers")
					stickerData = DIR.GetStickerData()
					return MSG.Splash("Legacy Effects")
				end,
				function()
					MSG.Splash("Chronicle Aging")
					return 1
				end,
				function()
					local function ageChronicleSticker(sData)
						local stickerObj = sData.obj
						local curAge = math.floor(sData.age)
						local decalData
						if curAge < 3 then
							curAge = curAge + 1
							decalData = U.clone(C.Decals.BlackBox)
							decalData.position = Vector(C.ObjectSpots.ChronicleSticker[curAge])
						end

						return U.RunSequence({
							function()
								stickerObj.highlightOn(C.RootColors.Amber)
								return 0.5
							end,
							function()
								if decalData ~= nil then
									stickerObj.addDecal(decalData)
								end
								return 0.5
							end,
							function()
								stickerObj.highlightOff()
								return 0.5
							end
						})
					end
					return U.RunSequence(U.iMap(stickerData, function(sData) return function()
						return ageChronicleSticker(sData)
					end end))
				end,
				function()
					P.SetCamera("MainBoard")
					MSG.Splash("Resource Legacy")
					return 1
				end,
				function()
					local function applyResourceLegacy(sData)
						local stickerObj = sData.obj
						return U.RunSequence({
							function()
								stickerObj.highlightOn(sData.status == "Pos" and Color.Blue or Color.Red)
								return 0.5
							end,
							function()
								return DIR.BumpToken(sData.resource, sData.status == "Pos" and 1 or -1)
							end,
							function()
								stickerObj.highlightOff()
								return 0.5
							end
						})
					end
					return U.RunSequence(U.iMap(stickerData, function(sData) return function()
						return applyResourceLegacy(sData)
					end end))
				end,
				function()
					P.SetCamera("BehindScreen")
					MSG.Splash("Power Legacy")
					return 1
				end,
				function()
					local function applyPowerLegacy(sData)
						local stickerObj = sData.obj
						local statusColor = sData.status == "Pos" and Color.Blue or Color.Red
						local player = S.getPlayerOfHouse(sData.house)
						return U.RunSequence({
							function()
								stickerObj.highlightOn(statusColor)
								return 0.5
							end,
							function()
								L.PulseLight("lightFront", S.getPlayerOfHouse(sData.house), statusColor)
								-- L.PulseLight("lightBehind", S.getPlayerOfHouse(sData.house), statusColor)
								if sData.status == "Pos" then
									return P.SpawnPower(player, 1)
								else
									return P.TakePower(player, 1)
								end
							end,
							function()
								stickerObj.highlightOff()
								return 0.5
							end
						})
					end
					return U.RunSequence(U.iMap(stickerData, function(sData) return function()
						return applyPowerLegacy(sData)
					end end))
				end,
				function()
					P.SetCamera("Stickers")
					MSG.Splash("Open Agendas")
					return 1
				end,
				function()
					local function assignOpenAgenda(sData)
						return U.RunSequence({
							function()
								stickerObj.highlightOn(sData.status == "Pos" and Color.Blue or Color.Red)
								return 0.5
							end,
							function()
								return DIR.BumpToken(sData.resource, sData.status == "Pos" and 1 or -1)
							end,
							function()
								stickerObj.highlightOff()
								return 0.5
							end
						})

					end


						-- OpAgendas = function(button)
	-- 	local isNegative = button == "-2"
	-- 	local player = U.getHost()
	-- 	local playerOptions = U.iMap(S.getPlayers(), function(player) return player.color end)
	-- 	local resOptions = C.Resources
	-- 	player.showOptionsDialog("Which Player?", playerOptions, 1, function(_, i)
	-- 		local targetPlayer = S.getPlayer(playerOptions[i])
	-- 		player.showOptionsDialog(isNegative and "Which Negative Agenda?" or "Which Positive Agenda?", resOptions, 1, function(_, i)
	-- 			local targetRes = resOptions[i]
	-- 			local openAgendas = S.getPlayerVal(targetPlayer, "openAgendas")
	-- 			if openAgendas == nil then openAgendas = {positive = {}, negative = {}} end
	-- 			if openAgendas[isNegative and "negative" or "positive"] == nil then
	-- 				openAgendas[isNegative and "negative" or "positive"] = {}
	-- 			end
	-- 			table.insert(openAgendas[isNegative and "negative" or "positive"], targetRes)
	-- 			S.setPlayerVal(openAgendas, targetPlayer, "openAgendas")
	-- 		end)
	-- 	end)
	-- end,


				end,
				DIR.ADVANCE
			}
		end,
		SecretAgendas = function()
			return {
				function()
					local assignedSAs = U.map(S.getPlayers(), function(player) return {
						color = player.color,
						secretAgenda = S.getPlayerVal(player, "PreAssignedSecretAgenda")
					} end)
					if #U.filter(assignedSAs, function(pData) return pData.secretAgenda ~= nil end) == #S.getPlayers() then
						return DIR.DealPreassignedSecretAgendas(assignedSAs)
					else
						return DIR.InitSecretAgendas()
					end
				end
			}
		end,
		PrepareFirstRound = function()
			return {
				function()
					S.setStateVal(0, "roundState", "roundNum")
					S.setStateVal(getTokenMomentums(), "roundState", "boardTokens", "momentum")
					DIR.GetDilemmaDeck().shuffle()
					return DIR.ADVANCE()
				end
			}
		end
	},
	PLAY = {
		StartRound = function() return {
				function()
					S.setStateVal(S.getStateVal("roundState", "roundNum") + 1, "roundState", "roundNum")
					S.setStateVal(DIR.GetTokenPositionsFromBoard(), "roundState", "boardTokens", "positions")
					S.setStateVal(P.GetLeader().color, "roundState", "currentTurn")
					S.setStateVal(false, "roundState", "passModClaimed")
					S.setStateVal(0, "roundState", "ayeTotal")
					S.setStateVal(0, "roundState", "nayTotal")
					U.forEach(S.getPlayers(), function(player)
						S.setPlayerTurnVal(false, player, "vote")
						S.setPlayerTurnVal(0, player, "powerCommitted")
					end)
					return DIR.ADVANCE()
				end
			}
		end,
		DrawDilemma = function() return {
				function()
					S.setStateVal({}, "roundState", "consequences")
					return {
						P.SetCamera("DilemmaDraw"),
						MSG.Splash("The Dilemma")
					}
				end,
				function()
					L.SetLightMode("lightLectern", "spotlightDilemmaDeck")
					return DIR.DrawDilemmaCard()
				end,
				function()
					displayCard = getObjectsWithTag("OnDisplay")[1]
					if displayCard.hasTag("Dilemma") then
					DIR.InitConsequencesQuery()
					end
					L.SetLightMode("lightLectern", "off", nil, 0.5)
					L.SetLightMode("lightDilemmaMain", "on", nil, 2)
					L.SetLightMode("lightDilemmaRef", "on")
					DIR.SpawnReferenceDilemmas(displayCard)
					return {
						U.setPositionSlow(displayCard, C.Spots.Main.Dilemma.faceDown.position, 2, "speedUp"),
						U.setRotationSlow(displayCard, C.Spots.Main.Dilemma.faceDown.rotation, 2, "speedUp"),
						U.setScaleSlow(displayCard, C.Spots.Main.Dilemma.faceDown.scale, 2, "speedUp")
					}
				end,
				function()
					if displayCard.hasTag("TriggerCard") then
						U.RunSequence({
							function()
								return MSG.SplashQuery(
									"Reveal Trigger Card Back?",
									P.GetLeaderName(),
									queryResponse,
									P.GetLeader()
								)
							end,
							function()
									return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.DisplayOutcome)
							end
						})
					else
					MSG.Splash(P.GetLeaderName() .. ", the Dilemma Card is Yours", P.GetLeader())
					return {
						L.SetLightMode("lightDilemmaAye", "on", nil, 1),
						L.SetLightMode("lightDilemmaNay", "on", nil, 1)
					}
				end
				end
			}
		end,
		Vote = function()
			local queryResponse = {Yes = "true", No = "false"}
			return {
				function()
					U.forEach(S.getPlayers(), function(player)
						-- if string.lower(UI.getAttribute("consequencesQuery_" .. player.color, "active")) == "true" then
							MSG.Hide("consequencesQuery_" .. player.color)
						-- end
						-- Wait.time(function() UI.setAttribute("consequencesQuery_" .. player.color, "active", "false") end, 1)
					end)
					P.SetCamera("BehindScreen")
					return MSG.SplashQuery(
						"Is a vote required this round?",
						P.GetLeaderName(),
						queryResponse,
						P.GetLeader()
					)
				end,
				function()
					if queryResponse.response == "true" then
						return U.RunSequence({
							function()
								MSG.Splash("The Vote")
								V.InitCountZones()
								return V.SetVotingLights()
							end,
							function()
								DIR.DisplayPassHUD(P.GetLeader())
								return V.StartTurn(P.GetLeader())
							end
						})
					else
						return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.EndRound)
					end
				end
			}
		end,
		VoteResolution = function()
			return {
				function()
					MSG.Hide("consequencesSidebar")
					U.forEach(getObjectsWithTag("RefDilemma"), function(obj) obj.destruct() end)
					L.SetLightMode("lightDilemmaRef", "off")
					return {
						L.SetLightMode({"lightBehind"}, "ambient"),
						L.SetLightMode({"lightFront"}, "dim"),
						L.SetLightMode({"lightPlayerSpotlight"}, "off")
					}
				end,
				function()
					local nayTotal = S.getStateVal("roundState", "nayTotal")
					local ayeTotal = S.getStateVal("roundState", "ayeTotal")
					if ayeTotal == nayTotal then
						local query = {Aye = "Aye", Nay = "Nay"}
						return U.RunSequence({
							function()
								return L.SetLightMode({"lightPlayerSpotlight"}, "player" .. S.getPlayerNum(P.GetModerator()), nil, 1)
							end,
							function()
								if ayeTotal == 0 then
									MSG.Splash("Leadership falls to the Moderator, " .. P.GetModeratorName() .. ".")
									P.AssignLeader(P.GetModerator())
									return MSG.SplashQuery(
										"Does the proposed resolution succeed?",
										P.GetModeratorName(),
										query,
										P.GetModerator()
									)
								else
									MSG.Splash({
										"Tie.",
										"The Moderator will cast the deciding vote."
									})
									return MSG.SplashQuery(
										"Cast the tie-breaking vote.",
										P.GetModeratorName(),
										query,
										P.GetModerator()
									)
								end
							end,
							function()
								L.SetLightMode({"lightPlayerSpotlight"}, "off")
								S.setStateVal(query.response, "roundState", "voteResult")
								return 0
							end
						})
					elseif ayeTotal > nayTotal then
						S.setStateVal("Aye", "roundState", "voteResult")
					else
						S.setStateVal("Nay", "roundState", "voteResult")
					end
					return 0
				end,
				function()
					if S.getStateVal("roundState", "voteResult") == "Aye" then
						return MSG.Splash("The Resolution is Approved", "AllMid", nil, {color = U.GetHex(Color.Blue)})
					else
						return MSG.Splash("The Resolution is Rejected", "AllMid", nil, {color = U.GetHex(Color.Red)})
					end
				end,
				function()
					if S.getPlayerVoteStatus(P.GetLeader()) ~= S.getStateVal("roundState", "voteResult") then
						local winningPlayers = U.filter(S.getPlayers(), function(player) return S.getPlayerVoteStatus(player) == S.getStateVal("roundState", "voteResult") end)
						if #winningPlayers == 0 then return 0 end
						table.sort(winningPlayers, function(playerA, playerB) return S.getPlayerPowerCommitted(playerA) > S.getPlayerPowerCommitted(playerB) end)
						if #winningPlayers > 1 and S.getPlayerPowerCommitted(winningPlayers[1]) == S.getPlayerPowerCommitted(winningPlayers[2]) then
							local tiedPlayers = U.filter(winningPlayers, function(player) return S.getPlayerPowerCommitted(player) == S.getPlayerPowerCommitted(winningPlayers[1]) end)
							local queryResponse = {}
							U.forEach(tiedPlayers, function(player) queryResponse[P.GetPlayerName(player)] = player end)
							return U.RunSequence({
								function()
									return MSG.SplashQuery(
										"Pass Leadership to which player?",
										P.GetModeratorName(),
										queryResponse,
										P.GetModerator()
									)
								end,
								function()
									if P.GetModeratorName() == P.GetPlayerName(queryResponse.response) then
										MSG.Splash(P.GetModeratorName() .. " retains Leadership.")
									else
										MSG.Splash(P.GetModeratorName() .. " assigns Leadership to " .. P.GetPlayerName(queryResponse.response) .. ".")
									end
									return P.AssignLeader(queryResponse.response)
								end
							})
						else
							return U.RunSequence({
								function()
									MSG.Splash(P.GetPlayerName(winningPlayers[1]) .. " claims Leadership.")
									return P.AssignLeader(winningPlayers[1])
								end
							})
						end
					else
						return 0
					end
				end,
				function()
					local passPlayers = U.filter(S.getPlayers(), function(player) return U.isIn(S.getPlayerVoteStatus(player), {"Pass", "PassMod"}) end)
					if #passPlayers > 0 then
						MSG.Splash("Granting Coin for Abstaining")
						return U.RunSequence(U.iMap(passPlayers, function(player) return function()
							P.SpawnCoins(player, 1)
							L.PulseLight("lightFront", player)
							return 0.5
						end end))
					end
					return 0
				end,
				function()
					local passPowerPlayers = U.filter(S.getPlayers(), function(player) return S.getPlayerVoteStatus(player) == "Pass" end)
					local balanceZone = getObjectsWithTag("zoneBalance")[1]
					local balancePower = OU.GetTotalValue(balanceZone, "PowerToken")
					if #passPowerPlayers > 0 then
						local powerPerPlayer = math.floor(balancePower / #passPowerPlayers)
						if powerPerPlayer > 0 then
							MSG.Splash("Gathering Power")
							OU.TransferValue(
								balanceZone,
								U.iMap(passPowerPlayers, function(player) return P.GetPlayerZone(player, "Power") end),
								powerPerPlayer,
								"PowerToken"
							)
							return U.RunSequence(U.iMap(passPowerPlayers, function(player) return function()
								L.PulseLight("lightFront", player)
								return 0.75
							end end))
						end
					end
					return 0
				end,
				function()
					local losingPlayers = U.filter(S.getPlayers(), function(player) return U.isIn(S.getPlayerVoteStatus(player), {"Aye", "Nay"}) and S.getPlayerVoteStatus(player) ~= S.getStateVal("roundState", "voteResult") end)
					if #losingPlayers > 0 then
						MSG.Splash("Returning Power to Losing Players")
						return U.RunSequence(U.iMap(losingPlayers, function(player) return function()
							OU.TransferValue(
								P.GetPlayerZone(player, "Public"),
								P.GetPlayerZone(player, "Power"),
								OU.GetTotalValue(P.GetPlayerZone(player, "Public"), "PowerToken"),
								"PowerToken"
							)
							Wait.time(function() V.LowerRiser(player) end, 2)
							L.PulseLight("lightFront", player)
							return 0.75
						end end))
					end
					return 0
				end,
				function()
					local winningPlayers = U.filter(S.getPlayers(), function(player) return S.getPlayerVoteStatus(player) == S.getStateVal("roundState", "voteResult") end)
					if #winningPlayers > 0 then
						MSG.Splash("Moving Committed Power to Balance")
						local balanceZone = getObjectsWithTag("zoneBalance")[1]
						return U.RunSequence(U.iMap(winningPlayers, function(player) return function()
							OU.TransferValue(
								P.GetPlayerZone(player, "Public"),
								balanceZone,
								OU.GetTotalValue(P.GetPlayerZone(player, "Public"), "PowerToken"),
								"PowerToken"
							)
							Wait.time(function() V.LowerRiser(player) end, 2)
							L.PulseLight("lightFront", player)
							return 0.75
						end end))
					end
					return 0
				end,
				function() return L.SetLightMode("lightVote", "off") end,
				DIR.ADVANCE
			}
		end,
		DisplayOutcome = function() return {
			function()
				V.InitCountZones()
				displayCard = getObjectsWithTag("OnDisplay")
				if #displayCard > 1 then return U.AlertGM("Too Many 'OnDisplay' Cards!") end
				displayCard = displayCard[1]
				if displayCard == nil then return U.AlertGM("No Card Displayed!") end

					L.SetLightMode("lightDilemmaAye", "off", nil, 0.5)
					L.SetLightMode("lightDilemmaNay", "off", nil, 0.5)

				if S.getStateVal("roundState", "displayedCardType") == "dilemma" then
					U.Assert("Displayed Card is a Dilemma?", displayCard.hasTag("Dilemma"))

					local voteResult = S.getStateVal("roundState", "voteResult")
					if voteResult == nil then
						return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.EnvelopeCheck, false)
					end

					P.SetCamera("DilemmaResult")
					MSG.Splash("Rewards & Consequences")
					L.SetLightMode("lightDilemmaMain", voteResult or "off", nil, 2)

					if voteResult == "Nay" then
						displayCard.alt_view_angle = Vector(0, 180, 180)
					else
						displayCard.alt_view_angle = Vector(0, 0, 0)
					end

					return {
						U.setPositionSlow(displayCard, C.Spots.Main.Dilemma["faceUp" .. voteResult].position, 0.5),
						U.setRotationSlow(displayCard, C.Spots.Main.Dilemma["faceUp" .. voteResult].rotation, 0.5),
						displayCard
					}
				elseif S.getStateVal("roundState", "displayedCardType") == "trigger" then
					U.Assert("Displayed Card is a Trigger Card?", displayCard.hasTag("TriggerCard"))

					P.SetCamera("DilemmaDraw")
					L.SetLightMode("lightDilemmaMain", "on", nil, 2)

					MSG.Splash("Resolve Triggered Event")

					DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.ApplyMomentum, false)

					return {
						U.setPositionSlow(displayCard, C.Spots.Main.Trigger.faceUp.position, 0.5),
						U.setRotationSlow(displayCard, C.Spots.Main.Trigger.faceUp.rotation, 0.5),
						displayCard
					}
				end
			end
		} end,
		ApplyChanges = function()
			return {
				function()
					local voteResult = S.getStateVal("roundState", "voteResult")
					U.setPositionSlow(displayCard, C.Spots.Main.Dilemma["faceUp" .. voteResult .. "Resolve"].position, 2)
					U.setRotationSlow(displayCard, C.Spots.Main.Dilemma["faceUp" .. voteResult .. "Resolve"].rotation, 2)
					return MSG.Splash("Apply Changes to Resources") end
			}
		end,
		ApplyMomentum = function()

			local tokenPositionsFromState, tokenPositionsFromBoard
			local resourceTokens, resourceDeltas, resourceBumps
			local unboundPosAfterMomentum
			local stabilityBumps

			-- unboundPositionsAfterApplyingMomentum,

			-- local function getTokenPositionsFromState()
			-- 	return {
			-- 		Influence = S.getStateVal("roundState", "boardTokens", "positions", "Influence"),
			-- 		Wealth = S.getStateVal("roundState", "boardTokens", "positions", "Wealth"),
			-- 		Morale = S.getStateVal("roundState", "boardTokens", "positions", "Morale"),
			-- 		Welfare = S.getStateVal("roundState", "boardTokens", "positions", "Welfare"),
			-- 		Knowledge = S.getStateVal("roundState", "boardTokens", "positions", "Knowledge"),
			-- 	}
			-- end

			local function getTokenPositionDeltas(startPositions, endPositions)
				return {
					Influence = endPositions.Influence - startPositions.Influence,
					Wealth = endPositions.Wealth - startPositions.Wealth,
					Morale = endPositions.Morale - startPositions.Morale,
					Welfare = endPositions.Welfare - startPositions.Welfare,
					Knowledge = endPositions.Knowledge - startPositions.Knowledge
				}
			end

			-- local function getUnboundTokenPositionsAfterApplyingMomentum()
			-- 	local tokenMomentums = getTokenMomentums()
			-- 	local curTokenPositions = getTokenPositionsFromBoard()

			-- 	local positionDeltas = getTokenPositionDeltas(getTokenPositionsFromState(), curTokenPositions)
			-- 	local newTokenPositions = U.clone(curTokenPositions)

			-- 	U.iForEach(C.Resources, function(resource)
			-- 		if tokenMomentums[resource] * positionDeltas[resource] > 0 then
			-- 			-- moving in same direction: apply momentum
			-- 			newTokenPositions[resource] = newTokenPositions[resource] + tokenMomentums[resource]
			-- 		end
			-- 	end)

			-- 	return newTokenPositions
			-- end

			-- local resourceTokens = getBoardTokens().resource
			-- local resourceDeltas = getTokenPositionDeltas(getTokenPositionsFromState(), getTokenPositionsFromBoard())
			-- local resourceBumps = getTokenPositionDeltas(getTokenPositionsFromBoard(), getUnboundTokenPositionsAfterApplyingMomentum())
			-- local stabilityBumps = getTokenPositionDeltas(getTokenPositionsFromBoard(), getUnboundTokenPositionsAfterApplyingMomentum())
			return {
				function()
					tokenPositionsFromState = {
						Influence = S.getStateVal("roundState", "boardTokens", "positions", "Influence"),
						Wealth = S.getStateVal("roundState", "boardTokens", "positions", "Wealth"),
						Morale = S.getStateVal("roundState", "boardTokens", "positions", "Morale"),
						Welfare = S.getStateVal("roundState", "boardTokens", "positions", "Welfare"),
						Knowledge = S.getStateVal("roundState", "boardTokens", "positions", "Knowledge"),
					}
					tokenPositionsFromBoard = DIR.GetTokenPositionsFromBoard()
					unboundPosAfterMomentum = U.clone(tokenPositionsFromBoard)
					resourceDeltas = getTokenPositionDeltas(tokenPositionsFromState, tokenPositionsFromBoard)
					return MSG.Splash("Applying Momentum")
				end,
				function()
					local tokenMomentums = getTokenMomentums()

					U.iForEach(C.Resources, function(resource)
						if tokenMomentums[resource] * resourceDeltas[resource] > 0 then
							-- moving in same direction: apply momentum
							unboundPosAfterMomentum[resource] = unboundPosAfterMomentum[resource] + tokenMomentums[resource]
						end
					end)

					resourceTokens = getBoardTokens().resource
					resourceBumps = getTokenPositionDeltas(tokenPositionsFromBoard, unboundPosAfterMomentum)
					stabilityBumps = getTokenPositionDeltas(tokenPositionsFromBoard, unboundPosAfterMomentum)

					return U.RunSequence(U.iMap(C.Resources, function(resource)
						if resourceDeltas[resource] == 0 then return function() return 0 end end
						if resourceBumps[resource] == 0 then
							-- Token moved, but opposite direction to momentum: flip momentum
							return function()
								S.setStateVal(resourceDeltas[resource] > 0 and 1 or -1, "roundState", "boardTokens", "momentum", resource)
								return U.RunSequence({
									function()
										resourceTokens[resource].flip()
										DIR.UpdateTokenLight(resource, tokenMomentums[resource])
										return resourceTokens[resource]
									end
								})
							end
						else
							-- Token moved in same direction to momentum: bump by momentum, bump stability, set momentum to 2
							return function()
								return U.RunSequence({
									function()
										local tokenMomentum = resourceDeltas[resource] > 0 and 2 or -2
										S.setStateVal(tokenMomentum, "roundState", "boardTokens", "momentum", resource)
										return {
											DIR.BumpToken("Stability", stabilityBumps[resource]),
											DIR.BumpToken(resource, resourceBumps[resource]),
											DIR.UpdateTokenLight(resource, tokenMomentum),
											DIR.UpdateTokenLight("Stability")
										}
									end,
									-- function()
									-- 	S.setStateVal(resourceDeltas[resource] > 0 and 2 or -2, "roundState", "boardTokens", "momentum", resource)
									-- 	return {
									-- 		DIR.UpdateTokenLight(resource),
									-- 		DIR.UpdateTokenLight("Stability")
									-- 	}
									-- end
								})
							end
						end
					end))
				end,
				DIR.ADVANCE
			}
		end,
		StickerCheck = function() return {
			function()
				MSG.Splash("Checking for Chronicle Stickers")
				queryResponse = {Yes = "true", No = "false"}
				return MSG.SplashQuery(
					"Unlock a Chronicle Sticker?",
					P.GetLeaderName(),
					queryResponse,
					P.GetLeader()
				)
			end,
			function()
				if queryResponse.response == "true" then
					return DIR.PromptForSticker(P.GetLeader())
				end
				return DIR.ADVANCE()
			end
		} end,
		EnvelopeCheck = function() return {
			function()
				MSG.Splash("Checking for Chronicle Envelopes")
				queryResponse = {Yes = "true", No = "false"}
				return MSG.SplashQuery(
					"Unlock a Chronicle Envelope?",
					P.GetLeaderName(),
					queryResponse,
					P.GetLeader()
				)
			end,
			function()
				if queryResponse.response == "true" then
					return DIR.PromptForEnvelope(P.GetLeader())
				end
				return DIR.ADVANCE()
			end
		} end,
		EndRound = function()
			return {
				function()

					displayCard = getObjectsWithTag("OnDisplay")[1]
					if displayCard == nil then return U.AlertGM("No Card Displayed!") end

					L.SetLightMode({"lightMapAnkist", "lightLectern", "lightMapWorld"}, "ambient")
					L.SetLightMode({"lightMapFocusA", "lightMapFocusB", "lightDilemmaMain"}, "off", nil, 2)

					displayCard.removeTag("OnDisplay")
					displayCard.addTag("Played")

					if S.getStateVal("roundState", "displayedCardType") == "dilemma" then
						U.Assert("Displayed Card is a Dilemma?", displayCard.hasTag("Dilemma"))
						DIR.AddToDilemmaDeck()

						local voteResult = S.getStateVal("roundState", "voteResult")
						local playedDilemmas = getObjectsWithAllTags({ "Dilemma", "Played" })
						local dilemmaTransform = C.Spots.Main.Dilemma["board" .. voteResult][#playedDilemmas]

						return U.RunSequence({
							function()
									displayCard.setLock(false)
								return {
										U.setPositionSlow(displayCard, Vector(dilemmaTransform.position):add(Vector(-3, 0, 0)), 2),
										U.setRotationSlow(displayCard, dilemmaTransform.rotation, 2),
										U.setScaleSlow(displayCard, dilemmaTransform.scale, 1),
										displayCard
								}
							end,
							function()
									displayCard.setLock(true)
									return U.setPositionSlow(displayCard, Vector(dilemmaTransform.position):setAt("y", C.TableHeight), 1)
							end,
							function()
								-- Check Abdication
								local stabilityToken = getObjectsWithTag("StabilityMarker")[1]
								local stabilityZPos = stabilityToken.getPosition().z
								if stabilityZPos > 9 or stabilityZPos < -15 then
									return DIR.EndGame("Abdication")
								end

								-- Check King Death
								local playedDilemmas = getObjectsWithAllTags({ "Dilemma", "Played" })
									if #playedDilemmas == 11 then
									return DIR.EndGame("Death")
								elseif #playedDilemmas > 6 then
									local queryResponse = {Yes = "true", No = "false"}
									return U.RunSequence({
										function()
											return MSG.SplashQuery(
												"Does the dilemma bear a skull icon?",
												P.GetLeaderName(),
												queryResponse,
												P.GetLeader()
											)
										end,
										function()
											if queryResponse.response == "true" then
												return DIR.EndGame("Death")
											end
												return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.StartRound)
										end
									})
								else
										return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.StartRound)
									end
								end
							})
					elseif S.getStateVal("roundState", "displayedCardType") == "trigger" then
						U.Assert("Displayed Card is a Trigger Card?", displayCard.hasTag("TriggerCard"))

						return U.RunSequence({
							function()
								displayCard.setLock(false)
								return {
									U.setPositionSlow(displayCard, C.Spots.Main.Trigger.aboveDeck.position, 1),
									U.setRotationSlow(displayCard, C.Spots.Main.Trigger.aboveDeck.rotation, 1),
									U.setScaleSlow(displayCard, C.Spots.Main.Trigger.aboveDeck.scale, 1),
									displayCard
								}
							end,
							DIR.AddToDilemmaDeck,
							function()
								return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.StartRound)
						end
					})
					end
				end
			}
		end
	},
	END = {
		Score = function()
			local scoreData, tokenData
			return {
				function()
					tokenData = DIR.GetTokenPositionsFromBoard()
					local stabilityPos = tokenData.Stability
					local kingName = S.getStateVal("gameState", "kingName")

					if stabilityPos == 19 then
						S.setStateVal("AbdicatedTop", "gameState", "endState")
						return MSG.Splash("A Treasonous Plot Forces King " .. kingName .. " to Abdicate!", "AllMid", 3)
					elseif stabilityPos == 1 then
						S.setStateVal("AbdicatedBottom", "gameState", "endState")
						return MSG.Splash("Popular Unrest Forces the King " .. kingName .. " to Abdicate!", "AllMid", 3)
					else
						S.setStateVal("Death", "gameState", "endState")
						return MSG.Splash("King " .. kingName .. "  Is Dead!", "AllMid", 3)
					end

				end,
				function()
					scoreData = DIR.GetFinalStandings()
					S.RecordFinishedGame(scoreData, tokenData)
					MSG.Show("scoringSplashScreen")
					return 5
				end,
				function()
					DIR.InitScoringHUD(scoreData)
				end
			}
		end,
		Realm = function()
			return {
				function()
					MSG.Hide("scoringHUD")
					return 4
				end,
				function()
					UI.setAttributes("scoringHUD", {
						active = "false",
						scale = "0.4 0.4 0.4",
						color = "Clear",
						offsetXY = "300 450"
					})
					MSG.Show("scoringHUD")
					return 1
				end,
				function()
					MSG.Splash("Record Earned Prestige & Crave on Your House Card", "AllLow", 5)
					local query = {Yes = "true"}
					return MSG.SplashQuery(
						"Proceed to Achievements?",
						"Host",
						query,
						U.getHost()
					)
				end,
				DIR.ADVANCE
			}
		end,
		Achievements = function()
			return {
				function()
					local query = {Yes = "true"}
					MSG.Splash("Tick Boxes for Any Earned Achievements", "AllLow", 5)
					return MSG.SplashQuery(
						"Proceed to Alignment?",
						"Host",
						query,
						U.getHost()
					)
				end,
				DIR.ADVANCE
			}
		end,
		Alignments = function()
			return {
				function()
					local query = {Yes = "true"}
					MSG.Splash("Tick the Box for the Secret Agenda You Played", "AllLow", 5)
					return MSG.SplashQuery(
						"Proceed to Cleanup?",
						"Host",
						query,
						U.getHost()
					)
				end,
				DIR.ADVANCE
			}
		end,
		Cleanup = function() return {
			function()
				MSG.Splash("Cleanup")
				S.LogGameEndTime()
				local tokenData = DIR.GetTokenPositionsFromBoard()
				local scoreData = DIR.GetFinalStandings()
				S.RecordFinishedGame(scoreData, tokenData)
				return 0.5
			end,
			function()
				local playedDilemmaCards = getObjectsWithAllTags({"Dilemma", "Played"})
				local numPlayedDilemmas = #playedDilemmaCards
				table.sort(playedDilemmaCards, function(a, b) return a.getPosition().z < b.getPosition().z end)
				local tempStagingPos = Vector(C.Spots.Main.CoverCard.Closed.position):add(Vector(-10, -3, 0))

				return {
					U.sequence(U.iMap(playedDilemmaCards, function(card, i) return function()
						DIR.SpawnDilemmaForCapture(card, numPlayedDilemmas + 1 - i)
						tempStagingPos:add(Vector(0, 0.2, 0))
						if Vector(card.alt_view_angle).y > 90 then
							card.setDescription("Vote: NAY")
						else
							card.setDescription("Vote: AYE")
						end
						card.setPosition(tempStagingPos)
						card.setRotation(Vector(0, 180, 180))
						card.setTags({"DilemmaOld"})
						card.setLock(false)
					end end), 0.15),
					function() return #getObjectsWithTag("DilemmaOld") == 1 end
				}
			end,
			function()
				local storyCards = getObjectsWithTag("StoryCard")
				table.sort(storyCards, function(a, b) return a.getPosition().y < b.getPosition().y end)
				local storyCardSpots = U.iMap(U.slice(U.clone(C.SnapPoints.Global), 1, 6), function(tData) return Vector(tData.position) end)
				local storyCardDatas = U.iMap(storyCards, function(sCard) return {
					obj = sCard,
					spot = U.findIndex(storyCardSpots, function(pos)
						return Vector.equals(sCard.getPosition(), Vector(pos), 1)
					end)
				} end)
				-- log(storyCardDatas)
				local storyArcs = {}
				U.iForEach(storyCardDatas, function(sData)
					if storyArcs[sData.spot] == nil then storyArcs[sData.spot] = 0 end
					storyArcs[sData.spot] = storyArcs[sData.spot] + 1
					DIR.SpawnStoryCardForCapture(sData.obj, sData.spot, storyArcs[sData.spot])
				end)


				local oldDilemmaDeck = getObjectsWithTag("DilemmaOld")[1]
				oldDilemmaDeck.setName("Game " .. S.getStateVal("gameState", "gameCount") .. " Dilemmas")
				O.MainStorage().putObject(oldDilemmaDeck)
				local tokens = getBoardTokens()
				tokens.Stability.destruct()
				U.forEach(tokens.resource, function(token) token.destruct() end)
				U.forEach(U.filter(getObjects(), function(obj)
					return U.hasAnyTag(obj, {"PowerToken", "CoinToken"}) and obj.type == "Generic" and not obj.hasTag("SourceObj")
						or U.hasAnyTag(obj, {"ResourceMarker", "StabilityMarker"}) and obj.type == "Tile" and not obj.hasTag("SourceObj")
				end), function(token) token.destruct() end)
				U.forEach({"Stability", unpack(C.Resources)}, function(lightRef) L.SetLightMode("light" .. lightRef, "off", nil, 0.5) end)
				V.LowerBalance()
				U.setPositionSlow(O.Leader.Figure(), C.Spots.Storage.LeaderFigure.position, 1)
				U.setRotationSlow(O.Leader.Figure(), C.Spots.Storage.LeaderFigure.rotation, 1)
				U.setPositionSlow(O.Moderator.Figure(), C.Spots.Storage.ModeratorFigure.position, 1)
				U.setRotationSlow(O.Moderator.Figure(), C.Spots.Storage.ModeratorFigure.rotation, 1)
				U.setPositionSlow(O.Leader.Light(), C.Spots.Storage.LeaderLight.position, 1)
				U.setRotationSlow(O.Leader.Light(), C.Spots.Storage.LeaderLight.rotation, 1)
				U.setPositionSlow(O.Moderator.Light(), C.Spots.Storage.ModeratorLight.position, 1)
				U.setRotationSlow(O.Moderator.Light(), C.Spots.Storage.ModeratorLight.rotation, 1)
				L.SetLightMode({"lightLeader", "lightModerator"}, "off", nil, 1)
				S.setStateVal(nil, "gameState", "leader")
				S.setStateVal(nil, "gameState", "moderator")
			end,
			DIR.RecallSecretAgendas,
			DIR.PromptForKingName,
			DIR.ADVANCE
		} end,
		SecretAgendas = function() return {
			DIR.InitSecretAgendas
		} end,
		SignOff = function() return {
			DIR.RecallSecretAgendas,
			function()
				return U.sequence(U.iMap(S.getPlayers(), function(player) return function()
					return U.RunSequence({
						function()
							return L.SetLightMode({"lightBehind", "lightFront", "lightVote"}, "off", player, 2)
						end,
						function()
							P.ClearSeat(player.color)
							return 0
						end
					})
				end end), 1)
			end,
			function()
				return {
					L.SetLightMode({"lightMainTop", "lightMainBottom", "lightLectern", "lightMapAnkist", "lightMapWorld", "lightMapFocusA", "lightMapFocusB", "lightFeature"}, "off", nil, 2)
				}
			end,
			function()
				return MSG.Splash("See You Next Week!", "AllMid")
			end,
			function()
				return MSG.HideAll()
			end,
			DIR.ADVANCE
		} end
	}
}
-- #endregion

-- #region Session Setup & Phase Control~
function DIR.InitPreflight()
	MSG.Hide("sessionPreflightDisplay")
	MSG.Show("sessionInitDisplay")

	Global.call("UpdatePhaseDisplay")
	U.forEach(getObjectsWithTag("Private"), function(obj)
		local color = U.findColorTag(obj)
		if color then
			obj.setInvisibleTo(S.getOtherColors(color))
		end
	end)
	L.PrimeLights()
	U.forEach(O.UninteractableObjs, function(oFunc)
		oFunc().interactable = false
		oFunc().gizmo_selectable = false
	end)

	-- #region DEBUG
	Global.call("InitTestFuncButtons") -- Assign names to test function buttons
	if ISDEBUGGING then
		console.load()
	end
	-- #endregion

	U.forEach(U.getKeys(O.SpawnSources), function(spawnSourceRef)
		O.SpawnSources[spawnSourceRef]().addTag("SourceObj")
	end)

	UI.setValue("gameNumText", "~ During the Reign of " .. S.getStateVal("gameState", "kingTitle") .. " " .. S.getStateVal("gameState", "kingName") .. " ~")

	-- if S.isInMode(C.Modes.NONE) then
	-- 	UI.setValue("gameNumText", "Game " .. S.getStateVal("gameState", "gameCount") + 1)
	-- else
	-- 	UI.setValue("gameNumText", "Game " .. S.getStateVal("gameState", "gameCount"))
	-- end
end

function DIR.InitSession(isNotShuffling)
	MSG.Hide("sessionInitDisplay")
	MSG.Show("gameStatusDisplay")
	return U.RunSequence({
		MSG.HideAll,
		function()
			MSG.Hide("splashScreen")
			MSG.Splash("Seating Players", nil, 3)
			return P.AssignPlayerColors(isNotShuffling)
		end,
		function()
			P.InitializeSeatHandZones()
			local players = S.getPlayers()
			return {
				function() return #U.filter(players, function(pl) return pl.getHandCount() == 0 end) == 0 end
			}
		end,
		function()
			DIR.InitCountZones()
			return P.SetCamera("BehindScreen")
		end,
		function()
			if S.isInMode(C.Modes.NONE) then
				return DIR.ADVANCE()
			end
			return DIR.JumpToStatePhase()
		end
	})
end

function DIR.InitCountZones()
	U.forEach(S.getPlayers(), function(player)
		-- Player Private Power
		local powerZone = P.GetPlayerZone(player, "Power")
		if powerZone then
			powerZone.call("SetCountTag", "PowerToken")
			powerZone.call("SetColor", Color.Yellow)
			powerZone.call("SetIcon", "powerIcon")
			powerZone.call("SetIconColor", Color(C.RootColors.Amber):setAt("a", 0.6))
			powerZone.call("Activate")
		end

		-- Player Private Coin
		local coinZone = P.GetPlayerZone(player, "Coin")
		if coinZone then
			coinZone.call("SetCountTag", "CoinToken")
			coinZone.call("SetColor", Color.Yellow)
			coinZone.call("SetIcon", "coinIcon")
			coinZone.call("SetIconColor", Color(C.RootColors.Amber):setAt("a", 0.6))
			coinZone.call("Activate")
		end

		V.InitCountZones(player)
	end)

	-- Balance Plinth
	local balanceZone = getObjectsWithTag("zoneBalance")[1]
	if balanceZone then
		balanceZone.call("SetCountTag", "PowerToken")
		balanceZone.call("SetColor", Color.Yellow)
		balanceZone.call("SetIcon", "powerIcon")
		balanceZone.call("SetIconColor", Color(C.RootColors.Amber):setAt("a", 0.6))
		balanceZone.call("Activate")
	end
end

function DIR.ADVANCE(waitFunc)
	local mode, phase = S.getNextPhase()
	local function startPhase()
		S.setStateVal(mode, "gameState", "gameMode")
		S.setStateVal(phase, "gameState", "gamePhase")
		U.waitUntil(DIR.InitializePhase, MSG.HideAll, true)
	end

	if waitFunc then
		U.waitUntil(startPhase, waitFunc, false)
	else
		startPhase()
	end
end

function DIR.InitializePhase()
	Global.call("UpdatePhaseDisplay")
	local mode = S.getStateVal("gameState", "gameMode")
	local phase = S.getStateVal("gameState", "gamePhase")
	local seqFuncs = INITFUNCS[mode]
	if U.Type(seqFuncs) == "table" then
		seqFuncs = seqFuncs[phase]
	end
	if U.Type(seqFuncs) == "function" then
		seqFuncs = seqFuncs()
	end
	U.RunSequence(seqFuncs)
end

function DIR.JumpToStatePhase(mode, phase, isInitializing)
	if isInitializing == nil and (mode ~= nil or phase ~= nil) then
		isInitializing = true
	end
	if mode ~= nil then
		S.setStateVal(mode, "gameState", "gameMode")
		S.setStateVal(mode, "gameState", "gamePhase")
	end
	if phase ~= nil then
		S.setStateVal(phase, "gameState", "gamePhase")
	end

	return U.waitUntil(function()
		if isInitializing == true then return DIR.InitializePhase() end
		if isInitializing == false then return 0 end

		if S.isInPhase({C.Phases.PLAY.DrawDilemma, C.Phases.PLAY.Discussion, C.Phases.PLAY.Vote}) then
			DIR.InitConsequencesQuery()
		end
		if S.isInMode({C.Modes.CHRONSETUP, C.Modes.GAMESETUP, C.Modes.PLAY, C.Modes.END}) then
			MSG.Show("refHUDControls")
		end

		-- ... further logic to resync game environment to whatever point in the game we're at.
		P.ActivatePlayerScreenHUD()
		return L.InitLights()
	end, MSG.HideAll)
end
-- #endregion

-- #region House Selection ~

function DIR.GetUnselectedPlayers()
	return U.filter(S.getPlayers(), function(player)
		return not HOUSE_SELECTION[player.color] and not S.getPlayerVal(player, "house")
	end)
end

local function isHouseClaimed(houseName) return S.getPlayerOfHouse(houseName) ~= false end
local function getSelectingPlayer(houseName) return U.findIndex(HOUSE_SELECTION, function(hName) return houseName == hName end) end

function DIR.InitHouseSelectionHUD()

	if #DIR.GetUnselectedPlayers() == 0 then
		HOUSE_SELECTION.isComplete = true
		else
		U.forEach(C.Houses, function(houseName)
			if isHouseClaimed(houseName) then
				local claimColor = S.getPlayerOfHouse(houseName)
				if U.isIn(claimColor, Player.getAvailableColors()) then
					claimColor = Color[claimColor]
					UI.setAttribute("houseHUD_Dark_" .. houseName, "color", U.GetHex(Color(claimColor):lerp(Color(C.RootColors.PureBlack):setAt("a", 1), 0.5)))
					UI.setAttribute("houseHUD_Dark_" .. houseName, "active", "true")
				else
					claimColor = Color.Black
					UI.setAttribute("houseHUD_Dark_" .. houseName, "color", U.GetHex(Color(C.RootColors.PureBlack):setAt("a", 0.85)))
					UI.setAttribute("houseHUD_Dark_" .. houseName, "active", "true")
				end
				UI.setAttribute("houseHUD_BannerBW_" .. houseName, "color", U.GetHex(claimColor))
			end
		end)
		MSG.Show("houseSelectionHUD")
	end

end

function DIR.UnselectHouse(houseName)
	HOUSE_SELECTION[U.findIndex(HOUSE_SELECTION, function(hName) return houseName == hName end)] = nil
	UI.setAttribute("houseHUD_BannerBW_" .. houseName, "color", U.GetHex(Color.White))
	UI.setAttribute("houseHUD_Overlay_" .. houseName, "color", U.GetHex(Color.White))
	UI.setAttribute("houseHUD_Dark_" .. houseName, "active", "false")
	UI.setAttribute("houseHUD_Overlay_" .. houseName, "active", "false")
end

function DIR.SelectHouse(player, houseName)
	HOUSE_SELECTION[player.color] = houseName
	UI.setAttribute("houseHUD_BannerBW_" .. houseName, "color", U.GetHex(Color[player.color]))
	UI.setAttribute("houseHUD_Overlay_" .. houseName, "color", U.GetHex(Color[player.color]:setAt("a", 0.5)))
	UI.setAttribute("houseHUD_Dark_" .. houseName, "color", U.GetHex(Color[player.color]:setAt("a", 0.5)))
	UI.setAttribute("houseHUD_Dark_" .. houseName, "active", "true")
	UI.setAttribute("houseHUD_Overlay_" .. houseName, "active", "true")
	if #DIR.GetUnselectedPlayers() == 0 then
		Wait.time(function() HOUSE_SELECTION.isComplete = true end, 1.5)
		end
end

function DIR.HouseHUDClick(player, houseName)
	if isHouseClaimed(houseName) then return end
	if S.getPlayerHouse(player) then return end
	if not U.isIn(houseName, C.Houses) then return end
	local curSelection = getSelectingPlayer(houseName)
	if curSelection ~= nil and curSelection ~= player.color then return end
	local curHouse = HOUSE_SELECTION[player.color]
	if curHouse ~= nil then DIR.UnselectHouse(curHouse) end
	if curHouse ~= houseName then DIR.SelectHouse(player, houseName) end
end

function DIR.HouseHUDHoverOn(player, houseName)
	UI.setAttribute("houseHUD_Bright_" .. houseName .. "_" .. player.color, "active", "false")
	UI.setAttribute("houseHUD_Info_" .. houseName .. "_" .. player.color, "active", "false")
	MSG.Show("houseHUD_Bright_" .. houseName .. "_" .. player.color)
	MSG.Show("houseHUD_Info_" .. houseName .. "_" .. player.color)
end

function DIR.HouseHUDHoverOff(player, houseName)
	UI.setAttribute("houseHUD_Bright_" .. houseName .. "_" .. player.color, "active", "true")
	UI.setAttribute("houseHUD_Info_" .. houseName .. "_" .. player.color, "active", "true")
	MSG.Hide("houseHUD_Bright_" .. houseName .. "_" .. player.color)
	MSG.Hide("houseHUD_Info_" .. houseName .. "_" .. player.color)
end

-- #endregion

-- #region Game Setup~
function DIR.SpawnBoardTokens()
	local seqFuncs = {}

	table.insert(seqFuncs, function()
		Wait.time(function() L.SetLightMode("lightStability", "on") end, 1)
		return OU.SpawnFromSourceObj(O.SpawnSources.stabilityToken(), { "StabilityMarker" }, C.Spots.Board.StabilityToken.center, Vector(0, 1, 0))
	end)

	U.iForEach(C.Resources, function(resName)
		table.insert(seqFuncs, function()
			return U.RunSequence({
				function()
					return OU.SpawnFromSourceObj(
						O.SpawnSources[string.lower(resName) .. "Token"](),
						{ "ResourceMarker", resName },
						C.Spots.Board.ResourceTokens[resName].center,
						Vector(0, 1, 0)
					)
				end,
				function()
					local tk = getBoardTokens().resource[resName]
					tk.setRotation(Vector(0, 180, U.randBetween(0, 1, true) * 180))
					tk.addForce(Vector(-0.07, 30, 0), 3)
					tk.addTorque(Vector(0, 0, 1.9), 3)
					U.waitUntil(function() DIR.UpdateTokenLight(resName) end, {1, tk})
					return tk
				end
			})
		end)
	end)

	return U.RunSequence(seqFuncs, 1000, 1)
end

-- #region Secret Agendas~
function DIR.InitSecretAgendas()
	return U.RunSequence({
		function()
			agendaDeck = getObjectsWithTag("SecretAgenda")[1]
			U.Val("SecretAgendas", agendaDeck, U.isGameObject(agendaDeck) and agendaDeck.type == "Deck")
			P.SetCamera("Lectern")
			if S.isInMode(C.Modes.END) then
				return MSG.Splash("Preassigning Secret Agendas")
			else
				return MSG.Splash("Secret Agendas")
			end
		end,
		function()
			agendaDeck.setLock(true)
			L.SetLightMode("lightLectern", "spotlightDilemmaDeck", nil, 1)
			return {
				U.setPositionSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.High.position), 1),
				U.setRotationSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.High.rotation), 1)
			}
		end,
		function()
			U.setPositionSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.Low.position), 0.5)
			U.setRotationSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.Low.rotation), 0.5)
			return 0.25
		end,
		function()
			agendaDeck.shuffle()
			return 0.5
		end,
		function() return DIR.BurnTopAgenda(agendaDeck) end,
		function()
			P.SetCamera("BehindScreen")
			L.SetLightMode("lightLectern", "off")
			L.SetLightMode("lightFront", "dim")
			return 1
		end,
		function() return DIR.DealSecretAgendas(P.GetLeastPrestigious(), agendaDeck) end
	})
end

function DIR.BurnTopAgenda(agendaDeck)
	local agendaCard
	return U.RunSequence({
		function()
			local isSpawned = false
			agendaCard = agendaDeck.takeObject({
				position = Vector({ -0.01, 6.95, 24.41 }),
				rotation = Vector({ 0, 0, 180 }),
				callback_function = function(obj)
					obj.setLock(true)
					obj.addTag("Burnt")
					isSpawned = true
				end
			})
			return function() return isSpawned == true end
		end,
		function()
			agendaCard.addTag("Burnt")
			return {
				U.setRotationSlow(agendaCard, Vector(C.Spots.Staging.SecretAgenda.Burnt.rotation), 2),
				U.setPositionSlow(agendaCard, Vector(C.Spots.Staging.SecretAgenda.Burnt.position), 2, "speedUp")
			}
		end
	})
end

function DIR.GetUnassignedSecretAgendas()
	local unassignedAgendas = U.filter(
		getObjectsWithTag("SecretAgenda"),
		function(agenda) return not U.hasAnyTag(agenda, {"Private", "Burnt"}) end
	)
	U.forEach(S.getPlayers(), function(player)
		U.forEach(player.getHandObjects(), function(obj)
			if obj.hasTag("SecretAgenda") then
				table.insert(unassignedAgendas, obj)
			end
		end)
	end)
	return unassignedAgendas
end

function DIR.DealSecretAgendas(playerRef, agendaSource)
	if agendaSource == nil then
		agendaSource = DIR.GetUnassignedSecretAgendas()
	end
	return U.RunSequence({
		function() return P.DealAll(agendaSource, playerRef) end,
		function()
			L.SetLightMode("lightPlayerSpotlight", "player" .. S.getPlayerNum(playerRef))
			return MSG.Splash("Choose Your Secret Agenda", playerRef)
		end
	})
end

function DIR.AssignSecretAgenda(playerRef, agendaCard, isDealingToNext)
	if isDealingToNext == nil then isDealingToNext = true end
	local player = S.getPlayer(playerRef)
	agendaCard.setLock(true)
	S.setPlayerVal(nil, player, "PreAssignedSecretAgenda")
	local agendaPos = P.getRotatedPlayerTransform(C.Spots.Player.SecretAgenda, player, 0)
	agendaCard.setInvisibleTo(S.getOtherColors(player))
	agendaCard.setTags({"SecretAgenda", player.color, "Private", U.findTag(agendaCard, U.map(C.SecretAgendas, function(sa) return "SA_" .. sa end))})
	U.setPositionSlow(agendaCard, agendaPos.position, 1)
	U.setRotationSlow(agendaCard, agendaPos.rotation, 1)

	if isDealingToNext then
		local nextPlayer = P.GetNextLeastPrestigious(player.color)
		if not nextPlayer then return DIR.EndSecretAgendas() end
		return DIR.DealSecretAgendas(nextPlayer)
	else
		return 1
	end
end

function DIR.GetAssignedAgendas()
	local assignedAgendas = {}
	U.forEach(S.getPlayers(), function(player)
		local agenda = getObjectsWithAllTags({"SecretAgenda", "Private", player.color})[1]
		if agenda == nil then return end
		local agendaTag = U.findTag(agenda, U.map(C.SecretAgendas, function(sa) return "SA_" .. sa end))
		assignedAgendas[player.color] = string.gsub(agendaTag, "^SA_", "")
	end)
	return assignedAgendas
end

function DIR.DealPreassignedSecretAgendas(agendaData)
	local aDeck = getObjectsWithTag("SecretAgenda")[1]
	U.Val("SecretAgendas", aDeck, U.isGameObject(aDeck) and aDeck.type == "Deck")
	local seqFuncs = {}

	local takenAgendaGUIDs = {}

	U.forEach(agendaData, function(aData)
		local agendaObj = U.find(aDeck.getObjects(), function (cData)
			return U.isIn("SA_" .. aData.secretAgenda, cData.tags)
		end)
		if agendaObj then
			table.insert(takenAgendaGUIDs, agendaObj.guid)
			table.insert(seqFuncs, function()
				L.PulseLight("lightFront", aData.color)
				aDeck.takeObject({
					position = Vector({ -0.01, 6.95, 24.41 }),
					rotation = Vector({ 0, 0, 180 }),
					guid = agendaObj.guid,
					callback_function = function(obj)
						DIR.AssignSecretAgenda(aData.color, obj, false)
					end
				})
				if aDeck.remainder then aDeck.remainder.setLock(true) end
			end)
		end
	end)

	local burntAgendaGUIDs = U.filter(aDeck.getObjects(), function(aData) return not U.isIn(aData.guid, takenAgendaGUIDs) end)

	local lastAgendaGUID = U.pop(burntAgendaGUIDs).guid

	if #burntAgendaGUIDs > 0 then
		U.forEach(burntAgendaGUIDs, function(guid)
			table.insert(seqFuncs, function()
				aDeck.takeObject({
					position = C.Spots.Staging.SecretAgenda.Burnt.position,
					rotation = C.Spots.Staging.SecretAgenda.Burnt.rotation,
					guid = guid,
					callback_function = function(obj)
						obj.addTag("Burnt")
						obj.setLock(true)
					end
				})
				if aDeck.remainder then aDeck.remainder.setLock(true) end
			end)
		end)
	end
	if lastAgendaGUID ~= nil then
		table.insert(seqFuncs, function()
			local card = getObjectFromGUID(lastAgendaGUID)
			if card == nil then return U.error("Last Agenda GUID ('" .. lastAgendaGUID .. "') Not On Table!") end
			card.setLock(true)
			card.addTag("Burnt")
			card.setPositionSmooth(C.Spots.Staging.SecretAgenda.Burnt.position)
			card.setRotationSmooth(C.Spots.Staging.SecretAgenda.Burnt.rotation)
		end)
	end


	return U.RunSequence({
		function()
			P.SetCamera("BehindScreen")
			return MSG.Splash("Secret Agendas (Preassigned)")
		end,
		function()
			aDeck.setLock(true)
			L.SetLightMode("lightLectern", "spotlightDilemmaDeck", nil, 1)
			return {
				U.setPositionSlow(aDeck, Vector(C.Spots.Staging.SecretAgenda.High.position), 1),
				U.setRotationSlow(aDeck, Vector(C.Spots.Staging.SecretAgenda.High.rotation), 1)
			}
		end,
		function()
			U.setPositionSlow(aDeck, Vector(C.Spots.Staging.SecretAgenda.Low.position), 0.5)
			U.setRotationSlow(aDeck, Vector(C.Spots.Staging.SecretAgenda.Low.rotation), 0.5)
			return 0.25
		end,
		function()
			L.SetLightMode("lightLectern", "off")
			L.SetLightMode("lightFront", "dim")
			return 1
		end,
		function()
			return U.sequence(seqFuncs, 1)
		end
	})



end

function DIR.EndSecretAgendas()
	L.SetLightMode("lightLectern", "ambient")
	L.SetLightMode("lightFront", "ambient")
	L.SetLightMode("lightPlayerSpotlight", "off")

	local heldAgendas = {}

	U.forEach(S.getPlayers(), function(player)
		heldAgendas = U.concat(heldAgendas, U.filter(player.getHandObjects(), function(obj) return obj.hasTag("SecretAgenda") end))
	end)

	U.forEach(heldAgendas, function(obj)
		obj.use_hands = false
		obj.setLock(true)
		obj.addTag("Burnt")
		obj.setPositionSmooth(C.Spots.Staging.SecretAgenda.Burnt.position)
		obj.setRotationSmooth(C.Spots.Staging.SecretAgenda.Burnt.rotation)
		Wait.time(function() obj.use_hands = true end, 0.5)
	end)

	if S.isInMode(C.Modes.END) then
		U.forEach(DIR.GetAssignedAgendas(), function(agenda, pColor)
			S.setPlayerVal(agenda, pColor, "PreAssignedSecretAgenda")
		end)
		Wait.time(DIR.ADVANCE, 4)
	end
end

function DIR.RecallSecretAgendas()
	L.SetLightMode("lightLectern", "ambient")
	L.SetLightMode("lightFront", "ambient")
	L.SetLightMode("lightPlayerSpotlight", "off")
	local secretAgendas = getObjectsWithTag("SecretAgenda")
	-- U.forEach(S.getPlayers(), function(player)
	-- 	secretAgendas = U.concat(secretAgendas, U.filter(player.getHandObjects(), function(obj) return obj.hasTag("SecretAgenda") end))
	-- end)
	U.Assert("Six secret agendas found?", #secretAgendas == 6)
	local stagingPos = Vector(C.Spots.Storage.SecretAgenda.position)
	return {
		U.sequence(U.map(secretAgendas, function(sA)
			return function()
				sA.use_hands = false
				local sATag = U.findTag(sA, {"SA_Opportunist", "SA_Opulent", "SA_Rebel", "SA_Extremist", "SA_Moderate", "SA_Greedy"})
				sA.setTags({"SecretAgenda", sATag})
				stagingPos:add(Vector(0, 0.2, 0))
				sA.setPositionSmooth(stagingPos)
				sA.setRotationSmooth(C.Spots.Storage.SecretAgenda.rotation)
				sA.setInvisibleTo()
				sA.setLock(false)
				Wait.time(function() sA.use_hands = true end, 1)
			end
		end)),
		function() return #getObjectsWithTag("SecretAgenda") == 1 end
	}
end

-- #endregion
function DIR.SpawnStartingPlayerPower()
	return U.RunSequence(U.map(S.getPlayers(), function(player)
		local numPower = 8 + (S.getPlayerVal(player, "startingPowerBonus") or 0)
		return function()
			L.PulseLight("lightFront", player)
			return { 1, P.SpawnPower(player, numPower) }
		end
	end))
end

function DIR.SpawnStartingPlayerCoins()
	return U.RunSequence(U.map(S.getPlayers(), function(player)
		local numCoins = 10 + (S.getPlayerVal(player, "startingCoinsBonus") or 0)
		return function() return { 1, P.SpawnCoins(player, numCoins) } end
	end))
end
-- #endregion

-- #region Game Round~

-- #region Player Prompting: Stickers, Envelopes, King Name~
function DIR.PromptForSticker(player)
	UI.setAttribute("stickerQuery_" .. player.color, "active", "false")
	MSG.Show("stickerQuery_" .. player.color)
	UI.setAttribute("stickerQuery_" .. player.color, "text", " ")
end

function DIR.ConfirmFetchSticker(player, stickerKey)
	U.forEach(S.getPlayers(), function(ply) MSG.Hide("stickerQuery_" .. ply.color) end)
	local query = {Yes = "true", No = "false"}
	return U.RunSequence({
		function()
			return MSG.SplashQuery(
				"Confirm Sticker Key '" .. stickerKey .. "'",
				P.GetPlayerName(player),
				query,
				player
			)
		end,
		function()
			if query.response == "true" then
				return DIR.FetchSticker(stickerKey)
			else
				return DIR.PromptForSticker(player)
			end
		end
	})
end

function DIR.PromptForEnvelope(player)
	UI.setAttribute("envelopeQuery_" .. player.color, "active", "false")
	MSG.Show("envelopeQuery_" .. player.color)
	UI.setAttribute("envelopeQuery_" .. player.color, "text", " ")
end

function DIR.ConfirmFetchEnvelope(player, envKey)
	U.forEach(S.getPlayers(), function(ply) MSG.Hide("envelopeQuery_" .. ply.color) end)
	local query = {Yes = "true", No = "false"}
	return U.RunSequence({
		function()
			return MSG.SplashQuery(
				"Confirm Envelope Key '" .. envKey .. "'",
				P.GetPlayerName(player),
				query,
				player
			)
		end,
		function()
			if query.response == "true" then
				return DIR.FetchEnvelope(envKey, false)
			else
				return DIR.PromptForEnvelope(player)
			end
		end
	})
end

function DIR.PromptForKingName()
	local player = S.getPlayer(U.sample(S.getStateVal("gameState", "winners")))
	S.setStateVal(nil, "gameState", "kingName")
	UI.setAttribute("kingQuery_" .. player.color, "active", "false")
	MSG.Show("kingQuery_" .. player.color)
	UI.setValue("kingQuery_kingTitle_" .. player.color, S.getStateVal("gameState", "kingTitle"))
	UI.setValue("kingQuery_kingHouse_" .. player.color, "of House " .. S.getPlayerHouseName(player))
	UI.setAttributes("kingQuery_input_" .. player.color, {
		text = " ",
		interactable = "true"
	})
	UI.setAttribute("kingQuery_inputImage_" .. player.color, "color", "#FFDD0011")
	return {
		function() return S.getStateVal("gameState", "kingName") ~= nil end,
		MSG.Splash("Naming Next Monarch")
	}
end

-- #endregion


-- #region Fetching: Stickers, Envelopes~
function DIR.FetchSticker(stickerKey)
	local stickerContainer = O.SecretContainers.Stickers()
	local stickerGUID = OU.FindContainedObjGUID(stickerContainer, function(objData)
		return string.lower(objData.name) == string.lower(stickerKey)
	end)

	if not stickerGUID then
		U.Alert("Sticker '" .. stickerKey .. "' Not Found! Check Case & Spelling", Color(1, 0, 0))
		return
	end

	local sticker
	local displayedDilemma = getObjectsWithAllTags({"Dilemma", "OnDisplay"})[1]

	return U.RunSequence({
		function()
			P.SetCamera("Lectern")
			if displayedDilemma ~= nil then
				local yRot = displayedDilemma.getRotation().y
				local outcome = yRot > 170 and "Nay" or "Aye"
				return {
					U.setPositionSlow(displayedDilemma, C.Spots.Main.Dilemma["faceUp" .. outcome .. "Shrink"].position, 0.5),
					U.setScaleSlow(displayedDilemma, C.Spots.Main.Dilemma["faceUp" .. outcome .. "Shrink"].scale, 0.5),
					L.SetLightMode("lightLectern", "spotlightSticker", nil, 0.25)
				}
			else
				return L.SetLightMode("lightLectern", "spotlightSticker", nil, 0.25)
			end
		end,
		function()
			U.setPositionSlow(stickerContainer, C.Spots.Staging.Lectern.Stickers.position)
			U.setRotationSlow(stickerContainer, C.Spots.Staging.Lectern.Stickers.rotation)
			return { stickerContainer, L.SetLightMode("lightLectern", "spotlightPlinth", nil, 0.1) }
		end,
		function()
			stickerContainer.takeObject({
				position = C.Spots.Staging.Lectern.Display.position,
				rotation = C.Spots.Staging.Lectern.Display.rotation,
				guid = stickerGUID,
				callback_function = function(obj)
					sticker = obj
					sticker.addTag("ChronicleSticker")
					sticker.setLock(true)
				end
			})
			return function() return sticker ~= nil end
		end,
		function()
			U.setPositionSlow(stickerContainer, C.Spots.Storage.Stickers.position)
			U.setRotationSlow(stickerContainer, C.Spots.Storage.Stickers.rotation)
			return 0.3
		end,
		function() return L.SetLightMode("lightLectern", "spotlightTransit", nil, 0.3) end,
		function()
			sticker.setPositionSmooth(Vector(C.Spots.Staging.Sticker.Display.position):add(Vector(0, 5, 0)))
			sticker.setRotationSmooth(Vector(C.Spots.Staging.Sticker.Display.rotation))
			return {
				sticker,
				L.SetLightMode("lightLectern", "spotlightDilemmaDeck")
			}
		end,
		function()
			sticker.setLock(false)
			return {
				sticker,
				1.5
			}
		end,
		function()
			P.SetCamera("Stickers")
			return function()
				return not Vector.equals(sticker.getPosition(),
					Vector(C.Spots.Staging.Sticker.Display.position), 1)
			end
		end,
		function() return L.SetLightMode({ "lightLectern" }, "ambient", nil, 0.5) end
	})
end

function DIR.FetchEnvelope(envKey)
	U.Assert("DIR.FetchEnvelope", envKey, "string")
	local envContainer = O.SecretContainers.Envelopes()
	U.Assert("DIR.FetchEnvelope", envContainer, "Object")

	local envGUID = OU.FindContainedObjGUID(envContainer, function(objData)
		return string.lower(objData.name) == string.lower(envKey)
	end)

	if not envGUID then return U.Alert("Envelope '" .. envKey .. "' Not Found! Check Case & Spelling", Color(1, 0, 0)) end

	local displayCard = getObjectsWithTag("OnDisplay")[1]

	local envDeck, storyCard

	return U.RunSequence({
		function()
				P.SetCamera("Lectern")
				if displayCard ~= nil then
					if displayCard.hasTag("Dilemma") then
						local yRot = displayCard.getRotation().y
					local outcome = yRot > 170 and "Nay" or "Aye"
					return {
							U.setPositionSlow(displayCard, C.Spots.Main.Dilemma["faceUp" .. outcome .. "Shrink"].position, 0.5),
							U.setScaleSlow(displayCard, C.Spots.Main.Dilemma["faceUp" .. outcome .. "Shrink"].scale, 0.5),
						L.SetLightMode("lightLectern", "spotlightEnvelope", nil, 0.25)
					}
					elseif displayCard.hasTag("Trigger") then
						return {
							U.setPositionSlow(displayCard, C.Spots.Main.Trigger.faceUpShrink.position, 0.5),
							U.setScaleSlow(displayCard, C.Spots.Main.Trigger.faceUpShrink.scale, 0.5),
							L.SetLightMode("lightLectern", "spotlightEnvelope", nil, 0.25)
						}
					end
				else
					return L.SetLightMode("lightLectern", "spotlightEnvelope", nil, 0.25)
				end
		end,
		function()
			U.setPositionSlow(envContainer, C.Spots.Staging.Lectern.Envelopes.position)
			U.setRotationSlow(envContainer, C.Spots.Staging.Lectern.Envelopes.rotation)
			return { envContainer, L.SetLightMode("lightLectern", "spotlightPlinth", nil, 0.1) }
		end,
		function()
			envContainer.takeObject({
				position = C.Spots.Staging.Lectern.Display.position,
				rotation = C.Spots.Staging.Lectern.Display.rotation,
				guid = envGUID,
				callback_function = function(obj)
					envDeck = obj
					envDeck.setLock(true)
				end
			})
			return function() return envDeck ~= nil end
		end,
		function()
			U.setPositionSlow(envContainer, C.Spots.Storage.Envelopes.position)
			U.setRotationSlow(envContainer, C.Spots.Storage.Envelopes.rotation)
			return 0.3
		end,
		function()
			envDeck.takeObject({
				position = C.Spots.Staging.Lectern.TopCard.position,
				rotation = C.Spots.Staging.Lectern.TopCard.rotation,
				-- smooth = false,
				callback_function = function(obj)
					storyCard = obj
					storyCard.setTags({ "StoryCard" })
					storyCard.setLock(true)
					storyCard.use_hands = false
					storyCard.use_snap_points = true
					storyCard.sticky = false
				end
			})
			return function() return storyCard ~= nil end
		end,
		function()
			return L.SetLightMode("lightLectern", "spotlightTransit", nil, 0.3)
		end,
		function()
			storyCard.setPositionSmooth(Vector(C.Spots.Staging.StoryCard.Display.position):add(Vector(0, 5, 0)))
			storyCard.setRotationSmooth(Vector(C.Spots.Staging.StoryCard.Display.rotation))
			return {
				storyCard,
				L.SetLightMode("lightLectern", "storyCard")
			}
		end,
		function()
			storyCard.setLock(false)
			return {
				storyCard,
				1.5
			}
		end,
		function()
			MSG.Splash(P.GetLeaderName() .. ", the Story Card is Yours", P.GetLeader())
			return P.SetCamera("Stickers")
		end,
		function()
			L.SetLightMode({ "lightMainTop", "lightMainBottom" }, "ambient", nil, 2)
			return function()
				return not Vector.equals(storyCard.getPosition(),
					Vector(C.Spots.Staging.StoryCard.Display.position), 1)
			end
		end,
		function()
			local coverCard = O.Pieces.CoverCard()
			coverCard.setLock(true)
			coverCard.setPositionSmooth(coverCard.getPosition():add(Vector(0, 1, 0)))
			U.setPositionSlow(envDeck, C.Spots.Main.Dilemma.aboveDeck.position)
			U.setRotationSlow(envDeck, C.Spots.Main.Dilemma.aboveDeck.rotation)
			envDeck.setLock(false)
			-- DIR.PromptLeaderToHandleEnvelope(envDeck)
			return L.SetLightMode({ "lightLectern" }, "ambient", nil, 0.5)
		end
	})
end
-- #endregion

-- #region Dilemma Cards & Consequences Query~
function DIR.GetDilemmaDeck()
	local coverCard = O.Pieces.CoverCard()
	return U.findBelowObject(coverCard, function(obj) return obj.type == "Card" or obj.type == "Deck" end)[1]
end

function DIR.DrawDilemmaCard()
	local dilemmaSource = DIR.GetDilemmaDeck()
	local drawnCard
	if dilemmaSource.type == "Deck" then
		dilemmaSource.takeObject({
			position = C.Spots.Staging.DilemmaDraw.position,
			rotation = C.Spots.Staging.DilemmaDraw.rotation,
			top = false,
			callback_function = function(obj)
				obj.use_hands = false
				obj.use_snap_points = true
				obj.addTag("OnDisplay")
				obj.setLock(true)
				if obj.hasTag("TriggerCard") then
					S.setStateVal("trigger", "roundState", "displayedCardType")
				else
					S.setStateVal("dilemma", "roundState", "displayedCardType")
				end
				drawnCard = obj
			end
		})
		return function() return drawnCard ~= nil end
	elseif dilemmaSource.type == "Card" then
		drawnCard = dilemmaSource
		drawnCard.use_hands = false
		drawnCard.use_snap_points = true
		drawnCard.setLock(true)
		drawnCard.addTag("OnDisplay")
		if drawnCard.hasTag("TriggerCard") then
			S.setStateVal("trigger", "roundState", "displayedCardType")
		else
			S.setStateVal("dilemma", "roundState", "displayedCardType")
		end
		return {
			U.setPositionSlow(drawnCard, C.Spots.Staging.DilemmaDraw.position),
			U.setRotationSlow(drawnCard, C.Spots.Staging.DilemmaDraw.rotation)
		}
	end
end

function DIR.SpawnReferenceDilemmas(dilemmaCard)
	U.forEach(S.getPlayers(), function(player)
		local angle = S.getPlayerAngle(player)
		local targetTransform = OU.RotateByAngle(C.Spots.Player.DilemmaSpot, angle)
		local tags = {"RefDilemma"}
		OU.SpawnFromSourceObj(dilemmaCard, tags, targetTransform, nil, nil, true)

	end)
end

function DIR.AddToDilemmaDeck(dilemmas)
	local coverCard = O.Pieces.CoverCard()
	U.Assert("DIR.AddToDilemmaDeck", coverCard, "Object")

	local seqFuncs = {}

	if dilemmas == nil then
		dilemmas = U.findAboveObject(coverCard, function(obj) return obj.type == "Deck" or obj.type == "Card" end, {box = true})
		U.Val("DIR.AddToDilemmaDeck", dilemmas, #dilemmas <= 1, "Multiple sources of dilemmas found above Cover Card. Consolidate them into a deck." )
		dilemmas = dilemmas[1]
		if dilemmas == nil then return 0 end
		table.insert(seqFuncs, function()
			return {
				U.setPositionSlow(dilemmas, dilemmas.getPosition():add(Vector(0, 4, 4))),
				U.setRotationSlow(dilemmas, coverCard.getRotation())
			}
		end)
	end

	U.Assert("DIR.AddToDilemmaDeck: Object Test", dilemmas, "Object")
	U.Assert("DIR.AddToDilemmaDeck: Deck or Card Test", U.isIn(dilemmas.type, { "Card", "Deck" }))

	coverCard.setLock(true)
	dilemmas.setLock(true)

	table.insert(seqFuncs, function()
		return {
			U.setPositionSlow(coverCard, coverCard.getPosition():add(Vector(0, 2, -3))),
			U.setRotationSlow(coverCard, coverCard.getRotation():add(Vector(0, 0, 70)))
		}
	end)

	local dilemmaCardDestPos = coverCard.getPosition():add(Vector(0, 4, 0))
	local dilemmaCardDestRot = coverCard.getRotation()

	local function addNextDilemma()
		dilemmaCardDestPos:add(Vector(0, 0.4, 0))
		if dilemmas.type == "Deck" then
			dilemmas.takeObject({
				position = dilemmaCardDestPos,
				rotation = dilemmaCardDestRot,
				callback_function = function(obj)
					obj.use_hands = false
					if obj.hasTag("TriggerCard") then
						obj.setTags({"TriggerCard"})
					else
					obj.setTags({ "Dilemma" })
					end
					obj.setLock(false)
				end
			})
			if dilemmas.remainder ~= nil then
				dilemmas.remainder.setLock(true)
				dilemmas = dilemmas.remainder
			end
			return 0.3
		elseif dilemmas.type == "Card" then
			U.RunSequence({
				function()
					dilemmas.use_hands = false
					if dilemmas.hasTag("TriggerCard") then
						dilemmas.setTags({"TriggerCard"})
					else
						dilemmas.setTags({ "Dilemma" })
					end
					dilemmas.setPositionSmooth(dilemmaCardDestPos)
					dilemmas.setRotationSmooth(dilemmaCardDestRot)
					return dilemmas
				end,
				function()
					dilemmas.setLock(false)
				end
			})
			return 0.3
		end
	end

	if dilemmas.type == "Deck" then
		for i = 1, #dilemmas.getObjects() do
			table.insert(seqFuncs, addNextDilemma)
		end
	else
		table.insert(seqFuncs, addNextDilemma)
	end

	table.insert(seqFuncs, function()
		return {
			U.setPositionSlow(coverCard, C.Spots.Main.CoverCard.Closed.position),
			U.setRotationSlow(coverCard, C.Spots.Main.CoverCard.Closed.rotation)
		}
	end)
	table.insert(seqFuncs, function()
		coverCard.setLock(false)
		return { coverCard, 0.1 }
	end)
	table.insert(seqFuncs, function()
		DIR.GetDilemmaDeck().shuffle()
	end)

	return U.RunSequence(seqFuncs)
end

function DIR.InitConsequencesQuery(playerRef)
	local player = playerRef == nil and P.GetModerator() or S.getPlayer(playerRef)
	U.forEach({"Sticker", unpack(C.Resources)}, function(resource)
		U.forEach({"P", "N"}, function(outcome)
			local stateVal = S.getStateVal("roundState", "consequences", outcome, resource) or "O"
			U.forEach({"O", "P", "N"}, function(conType)
				if conType == "O" then
					UI.setAttribute("consequence_" .. outcome .. "_" .. conType .. "_" .. resource .. "_" .. player.color, "active", tostring(conType == stateVal))
				else
					UI.setAttribute("consequence_" .. outcome .. "_" .. conType .. "_" .. resource .. "_" .. player.color, "active", tostring(conType == stateVal))
					UI.setAttribute("conDisplay_" .. outcome .. "_" .. conType .. "_" .. resource, "active", tostring(conType == stateVal))
				end
			end)
		end)
	end)
	if S.isInPhase(C.Phases.PLAY.DrawDilemma) then
		MSG.Show("consequencesQuery_" .. player.color)
	end
	MSG.Show("consequencesSidebar")
	return 0.5
end
-- #endregion

-- #region Vote Turn Control~
function DIR.DisplayPassHUD(playerRef)
	local player = S.getPlayer(playerRef)
	return U.RunSequence({
		function()
			UI.setAttribute("turnHUD_" .. player.color, "active", "false")
			V.UpdateHUD(player, true)
			return 0.5
		end,
		function()
			MSG.Show("turnHUD_" .. player.color)
			return 0.5
		end
	})
end
function DIR.TurnHUDClick(action, color)
	U.RunSequence({
		function()
			MSG.Hide("turnHUD_" .. color)
			return V.EndTurn(action == "passMod") end,
		function()
			local nextPlayer = DIR.GetNextVotingPlayer()


			function DIR.GetNextVotingPlayer()
				local curPlayerColor = S.getStateVal("roundState", "currentTurn")
				local activePlayers = U.filter(Player.getAvailableColors(), function(pColor)
					return pColor == curPlayerColor or U.isIn(S.getStateVal("turnState", pColor, "vote"), {false, "Aye", "Nay"})
				end)
				local playerIndex = U.findIndex(activePlayers, function(pColor) return pColor == curPlayerColor end)
				local nextPlayerColor
				if playerIndex == #activePlayers then
					nextPlayerColor = activePlayers[1]
				else
					nextPlayerColor = activePlayers[playerIndex + 1]
				end

				if P.GetLeader().color == nextPlayerColor or not U.isIn(S.getPlayerVoteStatus(nextPlayerColor), {false, "Aye", "Nay"}) then
					return nil
				end

				return S.getPlayer(nextPlayerColor)
			end

			if nextPlayer == nil then return DIR.ADVANCE() end

			return U.RunSequence({
				function()
					DIR.DisplayPassHUD(nextPlayer)
					return V.StartTurn(nextPlayer)
				end
			})
		end
	})
end
-- #endregion

-- #region Momentum & Stability~
function DIR.UpdateTokenLight(resource, momentum)
	if resource == nil then return U.iMap(U.concat({"Stability"}, C.Resources), DIR.UpdateTokenLight) end
	if resource == "Stability" then
		return L.SetLightMode("lightStability", "on", nil, 0.5)
	end
	if momentum == nil then momentum = getTokenMomentums()[resource] end
	local dir = momentum < 0 and "Down" or "Up"
	momentum = math.abs(momentum)
	return L.SetLightMode("light" .. resource, "momentum" .. dir .. momentum, nil, 0.5)
end

function DIR.GetStabilityBump()
	local stabilityPos = S.getStateVal("roundState", "boardTokens", "positions", "Stability")
	local curPositions = DIR.GetTokenPositionsFromBoard()
	U.forEach(C.Resources, function(resource)
		local prevPos = S.getStateVal("roundState", "boardTokens", "positions", resource)
		local curPos = curPositions[resource]
		local deltaPos = curPos - prevPos
		stabilityPos = math.max(math.min(stabilityPos + deltaPos, 19), 1)
	end)
	local boardStabilityPos = curPositions.Stability
	return stabilityPos - boardStabilityPos
end

function DIR.BumpToken(tokenName, count)

	local boardTokens = getBoardTokens()

	local function bumpToken(token, unitForceVector, count, lightName)
		local forceVector = Vector(unitForceVector):scale(count > 0 and Vector(1, 1, 1) or Vector(1, 1, -1))
		local absCount = math.abs(count)
		if absCount <= 3 then
			if lightName then
				Wait.time(function() DIR.UpdateTokenLight(lightName) end, 0.6)
			end
			return token.addForce(Vector(forceVector):scale(Vector(1, 1, math.abs(count))), 3)
		else
			local seqFuncs = {}
			while absCount >= 3 do
				absCount = absCount - 3
				table.insert(seqFuncs, function() bumpToken(token, forceVector, 3, lightName) end)
			end
			while absCount >= 2 do
				absCount = absCount - 2
				table.insert(seqFuncs, function() bumpToken(token, forceVector, 2, lightName) end)
			end
			while absCount >= 1 do
				absCount = absCount - 1
				table.insert(seqFuncs, function() bumpToken(token, forceVector, 1, lightName) end)
			end
			return U.sequence(seqFuncs, 0.5)
		end
	end

	local tokenPos = DIR.GetTokenPositionsFromBoard()
	local min, max = 1, tokenName == "Stability" and 19 or 17
	if tokenName == "Stability" and (tokenPos.Stability == 19 or tokenPos.Stability == 1) then
		return 0
	end
	count = math.max(math.min(count, max - tokenPos[tokenName]), min - tokenPos[tokenName])

	return bumpToken(
		tokenName == "Stability" and boardTokens.Stability or boardTokens.resource[tokenName],
		Vector(0, 15, 3.5),
		count,
		tokenName
	)
end
-- #endregion

-- #endregion

-- #region End of Game~
function DIR.EndGame() return DIR.JumpToStatePhase(C.Modes.END, C.Phases.END.Score) end

function DIR.GetSecretAgenda(playerRef)
	local player = S.getPlayer(playerRef)
	local secretAgendaCard = getObjectsWithAllTags({player.color, "SecretAgenda"})
	U.Val("DIR.GetSecretAgenda", secretAgendaCard, #secretAgendaCard == 1, "Unable to find " .. player.color .. "'s Secret Agenda!")
	secretAgendaCard = secretAgendaCard[1]
	local secretAgendaTag = U.find(secretAgendaCard.getTags(), function(tag) return string.match(tag, "^SA_") end)
	U.Val("DIR.GetSecretAgenda", secretAgendaTag, U.Type(secretAgendaTag) == "string", "Unable to find " .. player.color .. "'s Secret Agenda type!")
	return string.gsub(secretAgendaTag, "^SA_", "")
end

function DIR.GetCoinStandings()
	local coinTotals = U.map(S.getPlayers(), function(player)
		return {
			color = player.color,
			total = OU.GetTotalValue(P.GetPlayerZone(player, "Coin"), "CoinToken"),
			placement = nil
		}
	end)
	table.sort(coinTotals, function(a, b) return a.total > b.total end)
	local placement, lastTotal = 1, coinTotals[1].total
	U.iForEach(coinTotals, function(cData)
		if cData.total < lastTotal then
			placement = placement + 1
		end
		cData.placement = placement
		lastTotal = cData.total
	end)

	local results = {}

	U.forEach(S.getPlayers(), function(player)
		results[player.color] = U.find(coinTotals, function(cData) return cData.color == player.color end)
	end)

	return results
end

function DIR.GetSecretAgendaScore(playerRef, tokenPositions, coinStandings)
	local player = S.getPlayer(playerRef)
	local secretAgendaData = C.SecretAgendaData[DIR.GetSecretAgenda(playerRef)]
	local scoreReport = {}
	if U.isIn("resPoints", secretAgendaData) then
		-- resFunc is a filter function that will return number of qualifying tokens
		local numTokens = #U.filter(U.getValues(tokenPositions), secretAgendaData.resFunc)
		scoreReport.resources = secretAgendaData.resPoints[numTokens + 1]
	else
		-- resFunc takes all data and returns final score
		scoreReport.resources = secretAgendaData.resFunc(nil, tokenPositions)
	end

	scoreReport.coinTotal = coinStandings.total
	scoreReport.coinPlacement = coinStandings.placement
	if coinStandings.placement <= 3 then
		scoreReport.coin = secretAgendaData.coinPoints[coinStandings.placement]
	else
		scoreReport.coin = 0
	end

	return scoreReport
end

function DIR.GetSecretAgendaScores()
	local results = {}
	local tokenPositions = DIR.GetTokenPositionsFromBoard()
	tokenPositions.Stability = nil
	local coinStandings = DIR.GetCoinStandings()
	U.forEach(S.getPlayers(), function(player)
		results[player.color] = DIR.GetSecretAgendaScore(player, tokenPositions, coinStandings[player.color])
	end)
	return results
end

function DIR.GetOpenAgendaScore(playerRef, tokenPositions)
	local posOpenAgendas = S.getPlayerVal(playerRef, "openAgendas", "positive") or {}
	local negOpenAgendas = S.getPlayerVal(playerRef, "openAgendas", "negative") or {}
	local scoreReport = {positive = {}, negative = {}}
	local resPositions = U.getValues(tokenPositions)
	table.sort(resPositions, function(a, b) return a.slot > b.slot end)
	-- log({tokenPositions = tokenPositions})
	local topResources, secondResources = {}, {}
	table.insert(topResources, U.shift(resPositions))
	while (#resPositions > 0 and resPositions[1].slot == topResources[1].slot) do
		table.insert(topResources, U.shift(resPositions))
	end
	if #resPositions > 0 then
		table.insert(secondResources, U.shift(resPositions))
		while (#resPositions > 0 and resPositions[1].slot == secondResources[1].slot) do
			table.insert(secondResources, U.shift(resPositions))
		end
	end

	resPositions = U.getValues(tokenPositions)

	table.sort(resPositions, function(a, b) return a.slot < b.slot end)
	local botResources, secBotResources = {}, {}
	table.insert(botResources, U.shift(resPositions))
	while (#resPositions > 0 and resPositions[1].slot == botResources[1].slot) do
		table.insert(botResources, U.shift(resPositions))
	end
	if #resPositions > 0 then
		table.insert(secBotResources, U.shift(resPositions))
		while (#resPositions > 0 and resPositions[1].slot == secBotResources[1].slot) do
			table.insert(secBotResources, U.shift(resPositions))
		end
	end

	-- log({topResources = topResources, secondResources = secondResources, botResources = botResources, secBotResources = secBotResources})

	scoreReport.openAgendaTotal = 0
	U.iForEach(posOpenAgendas, function(res)
		if U.find(topResources, function(rData) return rData.resource == res end) then
			scoreReport.openAgendaTotal = scoreReport.openAgendaTotal + 3
			scoreReport.positive[res] = 3
		elseif U.find(secondResources, function(rData) return rData.resource == res end) then
			scoreReport.openAgendaTotal = scoreReport.openAgendaTotal + 1
			scoreReport.positive[res] = 1
		end
	end)

	U.iForEach(negOpenAgendas, function(res)
		if U.find(botResources, function(rData) return rData.resource == res end) then
			scoreReport.openAgendaTotal = scoreReport.openAgendaTotal - 3
			scoreReport.negative[res] = -3
		elseif U.find(secBotResources, function(rData) return rData.resource == res end) then
			scoreReport.openAgendaTotal = scoreReport.openAgendaTotal - 1
			scoreReport.negative[res] = -1
		end
	end)

	return scoreReport
end

function DIR.GetOpenAgendaScores()
	local results = {}
	local resourcePositions = DIR.GetTokenPositionsFromBoard()
	resourcePositions.Stability = nil
	local tokenPositions = U.map(resourcePositions, function(slot, res)
		return {resource = res, slot = slot}
	end)
	U.forEach(S.getPlayers(), function(player)
		results[player.color] = DIR.GetOpenAgendaScore(player, tokenPositions)
	end)
	return results
end

function DIR.GetPowerBonus()
	local powerTotals = U.map(S.getPlayers(), function(player)
		return {
			color = player.color,
			total = OU.GetTotalValue(P.GetPlayerZone(player, "Power"), "PowerToken"),
			placement = nil
		}
	end)
	table.sort(powerTotals, function(a, b) return a.total > b.total end)
	local placement, lastTotal = 1, powerTotals[1].total
	U.iForEach(powerTotals, function(pData)
		if pData.total < lastTotal then
			placement = placement + 1
		end
		pData.placement = placement
		lastTotal = pData.total
	end)

	local results = {}

	U.forEach(S.getPlayers(), function(player)
		results[player.color] = U.find(powerTotals, function(pData) return pData.color == player.color end)
		if results[player.color].placement == 1 then
			results[player.color].points = 2
		elseif results[player.color].placement == 2 then
			results[player.color].points = 1
		else
			results[player.color].points = 0
		end
	end)

	return results
end

function DIR.GetFinalScores()
	local results = {
		SecretAgenda = DIR.GetSecretAgendaScores(),
		OpenAgenda = DIR.GetOpenAgendaScores(),
		PowerBonus = DIR.GetPowerBonus()
	}
	local byPlayer = {}
	U.forEach(S.getPlayers(), function(player)
		byPlayer[player.color] = {
			name = S.getPlayerHouseName(player),
			color = player.color,
			secretAgenda = DIR.GetSecretAgenda(player),
			resources = results.SecretAgenda[player.color].resources,
			openAgendas = results.OpenAgenda[player.color],
			openAgendasTotal = results.OpenAgenda[player.color].openAgendaTotal,
			coin = results.SecretAgenda[player.color].coin,
			coinTotal = results.SecretAgenda[player.color].coinTotal,
			coinPlacement = results.SecretAgenda[player.color].coinPlacement,
			power = results.PowerBonus[player.color].points,
			powerTotal = results.PowerBonus[player.color].total,
			powerPlacement = results.PowerBonus[player.color].placement
		}
		byPlayer[player.color].total = byPlayer[player.color].resources
			+ byPlayer[player.color].coin
			+ byPlayer[player.color].power
			+ U.sumVals(U.getValues(byPlayer[player.color].openAgendas.positive))
			+ U.sumVals(U.getValues(byPlayer[player.color].openAgendas.negative))
	end)
	return byPlayer
end

function DIR.GetFinalStandings()
	local scoring = C.FinalScoring[S.getStateVal("gameState", "endState")]
	local scores = U.getValues(DIR.GetFinalScores())
	table.sort(scores, function(a, b) return a.total > b.total end)
	local winnerScore = scores[1].total
	local winners = U.map(U.filter(scores, function(sData) return sData.total == winnerScore end), function(sData) return sData.color end)
	S.setStateVal(winners, "gameState", "winners")
	for i = 1, #scores do
		scores[i].row = i
	end
	local lastPlace = scores[#scores].total
	for i = #scores, 1, -1 do
		if scores[i].total == lastPlace then
			scores[i].placement = "LAST"
			scores[i].prestige = scoring[5].prestige
			scores[i].crave = scoring[5].crave
		else
			break
		end
	end

	if scores[1].placement ~= "LAST" then
		local placement = 1
		scores[1].placement = placement
		scores[1].prestige = scoring[placement].prestige
		scores[1].crave = scoring[placement].crave
		for i = 2, #scores do
			if scores[i].placement == "LAST" then
				break
			elseif scores[i].total == scores[i - 1].total then
				scores[i].placement = placement
			else
				placement = placement + 1
				scores[i].placement = placement
			end
			scores[i].prestige = scoring[placement].prestige
			scores[i].crave = scoring[placement].crave
		end
	end

	if S.getStateVal("gameState", "endState") ~= "Death" then
		for i = 1, #scores do
			if scores[i].secretAgenda == "Rebel" then
				scores[i].crave = scores[i].crave + 1
			end
		end
	end
	return scores
end



function DIR.InitScoringHUD(scores)
	if scores == nil then scores = DIR.GetFinalStandings() end

	local function signNum(num)
		if num == 0 then return "-" end
		if num > 0 then return "+" .. tostring(num) end
		return tostring(num)
	end
	-- initialize all scoring elements with data from scoresData

	local lastPlacement
	local imageRefs = {}
	U.iForEach(scores, function(sData, index)
		local prefix = "scoringHUD_" .. index .. "_"
		if lastPlacement ~= sData.placement then
			lastPlacement = sData.placement
			UI.setValue(prefix .. "Placement", ({
				[1] = "1st", [2] = "2nd", [3] = "3rd", [4] = "4th", LAST = "LAST"
			})[sData.placement])
		else
			UI.setValue(prefix .. "Placement", "")
		end
		UI.setAttribute("scoringHUD_" .. index, "offsetXY", "0 -" .. tostring(50 + (index - 1) * (100 + 5)))
		U.forEach({"Name", "SecretAgenda", "OpenAgendas", "Coin", "Power", "Total"}, function(ref)
			UI.setAttribute(prefix .. ref, "color", U.GetHex(Color[sData.color]))
		end)
		UI.setValue(prefix .. "Name", sData.name)
		UI.setValue(prefix .. "SecretAgenda", signNum(sData.resources))
		UI.setValue(prefix .. "OpenAgendas", signNum(sData.openAgendasTotal))
		UI.setValue(prefix .. "Coin", signNum(sData.coin))
		UI.setValue(prefix .. "Power", signNum(sData.power))
		UI.setValue(prefix .. "Total", tostring(sData.total))

		local imageRef = ""
		if sData.prestige > 0 then
			imageRef = imageRef .. tostring(sData.prestige) .. "p"
		end
		if sData.crave > 0 then
			imageRef = imageRef .. tostring(sData.crave) .. "c"
		end
		table.insert(imageRefs, imageRef)
	end)

	local validPlacements = U.filter({"LAST", 4, 3}, function(p) return U.find(scores, function(sData) return sData.placement == p end) end)

	local seqFuncs = {
		function()
			MSG.Hide("scoringSplashScreen")
			MSG.Show("scoringHUD")
			return 3
		end
	}

	U.iForEach(validPlacements, function(placement)
		table.insert(seqFuncs, function()
			U.forEach(
				U.filter(scores, function(sData) return sData.placement == placement end),
				function(sData) MSG.Show("scoringHUD_" .. sData.row) end
			)
			return 4
		end)
	end)

	table.insert(seqFuncs, function()
		U.forEach(
			U.filter(scores, function(sData) return sData.placement == 1 end),
			function(sData) MSG.Show("scoringHUD_" .. sData.row) end
		)
		return 1
	end)

	table.insert(seqFuncs, function()
		U.forEach(
			U.filter(scores, function(sData) return sData.placement == 2 end),
			function(sData) MSG.Show("scoringHUD_" .. sData.row) end
		)
		return 3
	end)

	table.insert(seqFuncs, function()
		return U.sequence(U.iMap({1, 2, 3, 4, 5}, function(row) return function()
			local id = "scoringHUD_" .. row .. "_Reward_" .. imageRefs[row]
			MSG.Show(id)
			-- log("Showing '" .. id .. '". = 1_Reward_)
			-- log("Setting 'scoringHUD_" .. row .. "_Reward' to '" .. imageRefs[row] .. "'")
			-- Wait.time(function() UI.setAttribute("scoringHUD_" .. row .. "_Reward", "image", imageRefs[row]) end, 1)
		end end), 0.5)
	end)

	return U.RunSequence(seqFuncs)
end

function DIR.GetWinners() return U.iMap(U.filter(DIR.GetFinalStandings(), function(sData) return sData.placement == 1 end), function(sData) return S.getPlayer(sData.color) end) end
-- #endregion


function DIR.SpawnStoryCardForCapture(card, rowNum, colNum)
	local frontPos = Vector(C.CaptureCoords.cameraPos):add(Vector(0, 0, C.CaptureCoords.cameraZoneZShift):scale(1, 1, rowNum))
	frontPos:setAt("y", C.TableHeight)
	frontPos:add(Vector(
		C.CaptureCoords.Dilemma.startXDelta + (colNum - 1) * C.CaptureCoords.columnXShift,
		0,
		C.CaptureCoords.rowZShift
	))

	local backPos = Vector(frontPos)
	backPos:add(Vector(
		0,
		0,
		-1 * C.CaptureCoords.rowZShift
	))
	-- construct front and back transforms
	local transformFront = {
		position = frontPos,
		rotation = Vector(C.CaptureCoords.Story.frontRotation),
		scale = C.CaptureCoords.Story.scale
	}
	local transformBack = {
		position = backPos,
		rotation = Vector(C.CaptureCoords.Story.backRotation),
		scale = C.CaptureCoords.Story.scale
	}

	-- spawn front and back sides, tagging so they can be deleted easily
	OU.SpawnFromSourceObj(card, {"Capture"}, transformFront, nil, nil, true)
	OU.SpawnFromSourceObj(card, {"Capture"}, transformBack, nil, nil, true)


end

function DIR.SpawnDilemmaForCapture(dilemmaCard, index)

	local row = math.ceil(index / C.CaptureCoords.Dilemma.numColumns)
	local col = index % C.CaptureCoords.Dilemma.numColumns
	if col == 0 then col = C.CaptureCoords.Dilemma.numColumns end

	-- get position of FRONT side, rotated according to vote outcome; 4.43 -5.32 to -10.60
	local frontPos = Vector(C.CaptureCoords.cameraPos)
	frontPos:setAt("y", C.TableHeight)
	frontPos:add(Vector(
		C.CaptureCoords.Dilemma.startXDelta + (col - 1) * C.CaptureCoords.columnXShift,
		0,
		C.CaptureCoords.Dilemma.startZDelta + (row - 1) * (C.CaptureCoords.Dilemma.fullZShift + C.CaptureCoords.Dilemma.halfZShift)
	))

	-- get position of BACK side, from front side pos
	local backPos = Vector(frontPos)
	backPos:add(Vector(
		0,
		C.CaptureCoords.stackYShift,
		C.CaptureCoords.Dilemma.halfZShift
	))

	-- construct front and back transforms
	local transformFront = {
		position = frontPos,
		rotation = Vector(dilemmaCard.alt_view_angle).y > 90 and C.CaptureCoords.Dilemma.frontRotationNay or C.CaptureCoords.Dilemma.frontRotationAye,
		scale = C.CaptureCoords.Dilemma.scale
	}
	local transformBack = {
		position = backPos,
		rotation = Vector(C.CaptureCoords.Dilemma.backRotation),
		scale = C.CaptureCoords.Dilemma.scale
	}

	-- spawn front and back sides, tagging so they can be deleted easily
	OU.SpawnFromSourceObj(dilemmaCard, {"Capture"}, transformFront, nil, nil, true)
	OU.SpawnFromSourceObj(dilemmaCard, {"Capture"}, transformBack, nil, nil, true)

end

function DIR.RESET()
	-- S.setStateVal("NONE", "gameState", "gameMode")
	-- S.setStateVal("NONE", "gameState", "gamePhase")
	-- HOUSE_SELECTION, newPlayerColors = {}, {}

	U.RunSequence({
		-- stow played Dilemma cards, maintaining order, setting Description to record vote result.
		function()
			local playedDilemmaCards = getObjectsWithAllTags({"Dilemma", "Played"})
			table.sort(playedDilemmaCards, function(a, b) return a.getPosition().z < b.getPosition().z end)
			local tempStagingPos = Vector(C.Spots.Main.CoverCard.Closed.position):add(Vector(-10, -3, 0))
			return {
				U.sequence(U.iMap(playedDilemmaCards, function(card, i) return function()
					tempStagingPos:add(Vector(0, 0.2, 0))
					if Vector(card.alt_view_angle).y > 90 then
						card.setDescription("Vote: NAY")
					else
						card.setDescription("Vote: AYE")
					end
					card.setPosition(tempStagingPos)
					card.setRotation(Vector(0, 180, 180))
					card.setTags({"DilemmaOld"})
					card.setLock(false)
				end end), 0.15),
				unpack(playedDilemmaCards)
			}
		end,

		function() return U.AlertGM("All set!") end
	})
end



return DIR
end)
__bundle_register("kingsdilemma.objs.p3screen", function(require, _LOADED, __bundle_register, __bundle_modules)

-- local C = require("kingsdilemma.lib.constants")
local U = require("lib.utilities")
-- local OU = require("kingsdilemma.objects.objUtilities")
local O = require("kingsdilemma.lib.objects")
local S = require("kingsdilemma.core.state")
local P = require("kingsdilemma.core.players")

local HouseScreen = {}

local HouseData = {
	Blodyn = {
		HouseScreen = {
			top = "http://cloud-3.steamusercontent.com/ugc/2064377033366695909/2328B205458FE4E2846F8858304131D775002568/", -- "house-screenCenter"
			bottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366695246/DE0CFBB00A5B5B0E718B451404D8F4B6DE7531A3/", -- "back-screenCenter"
			leftTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366696176/8A080A07A2B4E0D15233003B6F788EFC89B80D6F/", -- "house-tab-screenFlapRight"
			leftBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366695354/A9889B82BD2F8B1B7B088ABB969AB63E4D8A8C6E/", -- "back-tab-screenFlapLeft"
			rightTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366695435/D767EF28F588CA82BBDF0A1229867F7FA6BDD825/", -- "back-tab-screenFlapRight"
			rightBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366696081/4B43821A167CBD262A707117D31BA6EB3854C12D/" -- "house-tab-screenFlapLeft"
		}
	},
	Coden = {
		HouseScreen = {
			top = "http://cloud-3.steamusercontent.com/ugc/2064377033366696288/4478CC3C3CCAD67A9A73B7CEBDF64290F4012B5A/", -- "house-screenCenter"
			bottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366694905/BA2470172347B1E6C3E0F2BA5DCB44119E8AD436/", -- "back-screenCenter"
			leftTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366696481/AE7FB65A741BB682803B7080B099D45EC2B51685/", -- "house-tab-screenFlapRight"
			leftBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366695051/DF5946B039F9F85A590BBF726CCE6FBFDF4FD90B/", -- "back-tab-screenFlapLeft"
			rightTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366695163/3A8D9D5122CCE95AF924709CD66FB39FF1CDD648/", -- "back-tab-screenFlapRight"
			rightBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366696421/1F15C3BD7A5D49470E970ACD9EC7A880ECA8322C/" -- "house-tab-screenFlapLeft"
		}
	},
	Gamam = {
		HouseScreen = {
			top = "http://cloud-3.steamusercontent.com/ugc/2064377033366697322/83621C8805464343E25EFF1B38C56536F7592277/", -- "house-screenCenter"
			bottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366695246/DE0CFBB00A5B5B0E718B451404D8F4B6DE7531A3/", -- "back-screenCenter"
			leftTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366697629/5A0083E82FC696F39674ED846BBA146A31DC8F01/", -- "house-tab-screenFlapRight"
			leftBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366695354/A9889B82BD2F8B1B7B088ABB969AB63E4D8A8C6E/", -- "back-tab-screenFlapLeft"
			rightTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366695435/D767EF28F588CA82BBDF0A1229867F7FA6BDD825/", -- "back-tab-screenFlapRight"
			rightBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366697529/8A6E7CF0993BAFFB1C1B4495E880BC91E23942D1/" -- "house-tab-screenFlapLeft"
		}
	},
	Natar = {
		HouseScreen = {
			top = "http://cloud-3.steamusercontent.com/ugc/2064377033366697727/2F6561BBDEC8456F1719C1E6211FBA02287AAAC3/", -- "house-screenCenter"
			bottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366694571/7C0723DC5FAEB7E8B98C914C74EF5DD6C626E221/", -- "back-screenCenter"
			leftTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366697956/13E59AFCCD716522A209A3231568D98FDAF98ABA/", -- "house-tab-screenFlapRight"
			leftBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366694699/A1BCB2EE646EB64180923F62AC9B1054C0C76C06/", -- "back-tab-screenFlapLeft"
			rightTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366694789/86BC0AD96BBB95004A36DD0DE8EF2BEB37A51222/", -- "back-tab-screenFlapRight"
			rightBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366697885/ADD2B097DE4908B384C09766F3F9B14B5B976564/" -- "house-tab-screenFlapLeft"
		}
	},
	Olwyn = {
		HouseScreen = {
			top = "http://cloud-3.steamusercontent.com/ugc/2064377033366082853/75AB016C3349F7269FEFABAC3814623D2508FF72/", -- "house-screenCenter"
			bottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366091356/8BB69BF4756244B40037219F31A7CF87616109DD/", -- "back-screenCenter"
			leftTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366083172/6E3BDBCB9FCB38BC07AB16C20282E21AFCA49D33/", -- "house-tab-screenFlapRight"
			leftBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366659940/D47A151C1338BBF4D151E4F3DAEFB582400BF97C/", -- "back-tab-screenFlapLeft"
			rightTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366660025/48FD1DEA1CBBBC459B612C0AD0BE991C6AF876A6/", -- "back-tab-screenFlapRight"
			rightBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366083108/9414CA5CD6CD8582186AB12E883797530F273210/" -- "house-tab-screenFlapLeft"
		}
	},
	Solad = {
		HouseScreen = {
			top = "http://cloud-3.steamusercontent.com/ugc/2064377033366698064/1E7A17EC8242159BEC9C5C1F4811F0D04194B702/", -- "house-screenCenter"
			bottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366693770/A4FFD4FD9D0D8943A07A8A7AFD70E5F33FABCC1C/", -- "back-screenCenter"
			leftTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366698356/23D937E1725FA8455279602BB4DFD654D4B6E8D5/", -- "house-tab-screenFlapRight"
			leftBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366693946/D7CF43D8970F9EF6674F02E376321ED98102FA54/", -- "back-tab-screenFlapLeft"
			rightTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366694021/0598CE8521757D98A5F1D2ADF805A55A54631AA9/", -- "back-tab-screenFlapRight"
			rightBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366698266/9A971B6D9C9DA973C441F4C96BF79CB6884B9583/" -- "house-tab-screenFlapLeft"
		}
	},
	Allwed = {
		HouseScreen = {
			top = "http://cloud-3.steamusercontent.com/ugc/2064377033366695535/61F8CAEFAF0978B77FE9C77F347EABE4FBC6DA95/", -- "house-screenCenter"
			bottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366694905/BA2470172347B1E6C3E0F2BA5DCB44119E8AD436/", -- "back-screenCenter"
			leftTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366695799/4E3A118FD56271C82294CC4A9A65620D6C3BDCBD/", -- "house-tab-screenFlapRight"
			leftBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366695051/DF5946B039F9F85A590BBF726CCE6FBFDF4FD90B/", -- "back-tab-screenFlapLeft"
			rightTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366695163/3A8D9D5122CCE95AF924709CD66FB39FF1CDD648/", -- "back-tab-screenFlapRight"
			rightBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366695723/4EEC8EECE8B3D25AA4F4754CD682A3A46EB31C4D/" -- "house-tab-screenFlapLeft"
		}
	},
	Crann = {
		HouseScreen = {
			top = "http://cloud-3.steamusercontent.com/ugc/2064377033366696586/DDAFCBDA6ECEDA36482768E371FD90D1B6FFFD38/", -- "house-screenCenter"
			bottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366694103/F1FB846534BEC77EB9D34BBA508732F792A35BC9/", -- "back-screenCenter"
			leftTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366696855/8C141506C944DF9201BE12A212AF97FC73938F66/", -- "house-tab-screenFlapRight"
			leftBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366694312/64860EE59755032CB98BD53521CAD602F82D396D/", -- "back-tab-screenFlapLeft"
			rightTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366694459/4EB40DC7AE1B5598D7A22DC638402660195E0D19/", -- "back-tab-screenFlapRight"
			rightBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366696725/1B19152BDFE255FD6148BE564CEDAEDEF5B0B43F/" -- "house-tab-screenFlapLeft"
		}
	},
	Dualak = {
		HouseScreen = {
			top = "http://cloud-3.steamusercontent.com/ugc/2064377033366696963/45FE34D3D6B1B0059D94780A6808959EF6B45D3F/", -- "house-screenCenter"
			bottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366694103/F1FB846534BEC77EB9D34BBA508732F792A35BC9/", -- "back-screenCenter"
			leftTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366697214/0A02D883744AF6ADCFBF59622A71D0895979658C/", -- "house-tab-screenFlapRight"
			leftBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366694312/64860EE59755032CB98BD53521CAD602F82D396D/", -- "back-tab-screenFlapLeft"
			rightTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366694459/4EB40DC7AE1B5598D7A22DC638402660195E0D19/", -- "back-tab-screenFlapRight"
			rightBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366697122/EFBE9DB0E377218D67D41072FB7537CF4259BD3C/" -- "house-tab-screenFlapLeft"
		}
	},
	Tiryll = {
		HouseScreen = {
			top = "http://cloud-3.steamusercontent.com/ugc/2064377033366698478/C37CA6E5F1591DE2E8BD70B06A52EA58A86402E0/", -- "house-screenCenter"
			bottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366091356/8BB69BF4756244B40037219F31A7CF87616109DD/", -- "back-screenCenter"
			leftTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366698723/1F7CA92DB5E425760072D1B1D6648CC1A89B078C/", -- "house-tab-screenFlapRight"
			leftBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366659940/D47A151C1338BBF4D151E4F3DAEFB582400BF97C/", -- "back-tab-screenFlapLeft"
			rightTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366660025/48FD1DEA1CBBBC459B612C0AD0BE991C6AF876A6/", -- "back-tab-screenFlapRight"
			rightBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366698639/C51D2E0E795A44A587A4E99DB6C1C8AFF1399BC1/" -- "house-tab-screenFlapLeft"
		}
	},
	Tork = {
		HouseScreen = {
			top = "http://cloud-3.steamusercontent.com/ugc/2064377033366698855/8B0E3E8031F505EAAD3CEAD04EEA0C3CC21D7803/", -- "house-screenCenter"
			bottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366694571/7C0723DC5FAEB7E8B98C914C74EF5DD6C626E221/", -- "back-screenCenter"
			leftTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366699094/6DE970D684877EEEE627E05248EC76D3A2E8ED91/", -- "house-tab-screenFlapRight"
			leftBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366694699/A1BCB2EE646EB64180923F62AC9B1054C0C76C06/", -- "back-tab-screenFlapLeft"
			rightTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366694789/86BC0AD96BBB95004A36DD0DE8EF2BEB37A51222/", -- "back-tab-screenFlapRight"
			rightBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366699017/993091BCCE5B8EC31AED2A551D98C6C38167051D/" -- "house-tab-screenFlapLeft"
		}
	},
	Wylio = {
		HouseScreen = {
			top = "http://cloud-3.steamusercontent.com/ugc/2064377033366699213/B24D56A5EA01FB75096920F3B05F0EB153B44731/", -- "house-screenCenter"
			bottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366091356/8BB69BF4756244B40037219F31A7CF87616109DD/", -- "back-screenCenter"
			leftTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366699616/77CD0E92B3518556F3E146D613757A70C695FB3C/", -- "house-tab-screenFlapRight"
			leftBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366659940/D47A151C1338BBF4D151E4F3DAEFB582400BF97C/", -- "back-tab-screenFlapLeft"
			rightTop = "http://cloud-3.steamusercontent.com/ugc/2064377033366660025/48FD1DEA1CBBBC459B612C0AD0BE991C6AF876A6/", -- "back-tab-screenFlapRight"
			rightBottom = "http://cloud-3.steamusercontent.com/ugc/2064377033366699384/7D4BE95C4A8E6138ADD03E7F2AFB6C757E41BA8F/" -- "house-tab-screenFlapLeft"
		}
	}
}

local ObjectData = {
		screenFlapLeft = {
			source = O.SpawnSources.screenFlapLeft,
			position = {9.10, 6.47, 41.09},
			rotation = {87.76, 180.00, 45.00},
			scale = {5, 1, 5},
			data = {
				Tags = {"HouseScreen"}
			}
		},
		screenCenter = {
			source = O.SpawnSources.screenCenter,
			position = {0.00, 6.51, 40.00},
			rotation = {87.76, 180.00, 0.00},
			scale = {5, 1, 5},
			data = {
				Tags = {"HouseScreen"}
			}
		},
		screenFlapRight = {
			source = O.SpawnSources.screenFlapRight,
			position = {-9.26, 6.47, 40.97},
			rotation = {87.76, 180.00, 135.00},
			scale = {5, 1, 5},
			data = {
				Tags = {"HouseScreen"}
			}
		},
		houseCard = { -- This is at Player 0 position: Others should be moved to Player 0 position, too
			source = O.SpawnSources.HouseCards,
			isSpawning = false,
			position = {0.00, 7.52, 40.95},
			rotation = {83.90, 0.00, 0.00},
			scale = {3.75, 1.00, 3.75},
			data = {
				Tags = {"HouseCard"}
			}
		},
		zonePrivateAye = {
			source = O.SpawnSources.zonePrivateAye,
			position = {4.00, 1.46, 42.35},
			rotation = {0.00, 180.00, 0.00},
			scale = {4.94, 4.94, 4.94},
			data = {
				Tags = {"Zone_Counter", "Zone_PrivateUI", "PowerToken", "Zone_VoteAye"}
			}
		},
		zonePrivateNay = {
			source = O.SpawnSources.zonePrivateNay,
			position = {-4.00, 1.46, 42.35},
			rotation = {0.00, 180.00, 0.00},
			scale = {4.94, 4.94, 4.94},
			data = {
				Tags = {"Zone_Counter", "Zone_PrivateUI", "PowerToken", "Zone_VoteNay"}
			}
		},
		zonePrivatePower = {
			source = O.SpawnSources.zonePrivatePower,
			position = {8, 1.46, 48},
			rotation = {0.00, 180.00, 0.00},
			scale = {4.94, 4.94, 4.94},
			data = {
				Tags = {"Zone_Counter", "Zone_PrivateUI", "PowerToken"}
			}
		},
		zonePrivateCoin = {
			source = O.SpawnSources.zonePrivateCoin,
			position = {-8, 1.46, 48},
			rotation = {0.00, 180.00, 0.00},
			scale = {4.94, 4.94, 4.94},
			data = {
				Tags = {"Zone_Counter", "Zone_PrivateUI", "CoinToken"}
			}
		},
		zonePublic = {
			source = O.SpawnSources.zonePublic,
			position = {0.00, 3, 32.42},
			rotation = {0, 180, 0},
			scale = {5, 5, 5},
			data = {
				Tags = {"Zone_Counter", "Zone_PublicUI", "PowerToken"}
			}
		},
		zoneHiderHouseCard = {
			source = O.SpawnSources.zoneHiderHouseCard,
			position = {7.34, 10.32, 40.54},
			rotation = {88.00, 180.00, 0.00},
			scale = {0.09, 0.37, 0.20},
			data = {
				Tags = false
			}
		},
		zoneHiderGeneral = {
			source = O.SpawnSources.zoneHiderGeneral,
			position = {0.00, 0.44, 48.00},
			rotation = {0.00, 180.00, 0.00},
			scale = {21.5, 10, 5.00},
			data = {
				Tags = false
			}
		},
		ayeCard = {
			source = O.SpawnSources.ayeCard,
			position = {4.00, 1.46, 42.50},
			rotation = {0.00, 0.00, 0.00},
			scale = {1.59, 1.00, 1.59},
			data = {
				Tags = {}
			}
		},
		-- passCard = {
		-- 	source = O.SpawnSources.passCard,
		-- 	position = {0.00, 1.46, 42.50},
		-- 	rotation = {0.00, 0.00, 0.00},
		-- 	scale = {1.59, 1.00, 1.59},
		-- 	data = {
		-- 		Tags = {}
		-- 	}
		-- },
		nayCard = {
			source = O.SpawnSources.nayCard,
			position = {-4.00, 1.46, 42.50},
			rotation = {0.00, 0.00, 0.00},
			scale = {1.59, 1.00, 1.59},
			data = {
				Tags = {}
			}
		},
		lightBehind = {
			source = O.SpawnSources.lightBehind,
			position = {0.00, 20.81, 83.86},
			rotation = {281.79, 180.00, 0.00},
			scale = {1.00, 1.00, 1.00},
			data = {
				Tags = {}
			}
		},
		lightFront = {
			source = O.SpawnSources.lightFront,
			position = {0.00, 2.30, 27.37},
			rotation = {110, 180.00, 0.00},
			scale = {1.00, 1.00, 1.00},
			data = {
				Tags = {}
			}
		},
		lightVote = {
			source = O.SpawnSources.lightVote,
			position = {0.00, 9.60, 32.42},
			rotation = {0.00, 180.00, 0.00},
			scale = {1.00, 1.00, 1.00},
			data = {
				Tags = {}
			}
		},
		lightDilemmaRef = {
			source = O.SpawnSources.lightDilemmaRef,
			position = {0.00, 9.2, 50.84},
			rotation = {83.9, 0, 0},
			scale = {1, 1, 1},
			data = {
				Tags = {}
			}
		},
		plinthBase = {
			source = O.SpawnSources.plinthBase,
			position = {0.00, 1.58, 32.42},
			rotation = {0.00, 180.00, 0.00},
			scale = {0.8, 0.5, 0.8},
			data = {
				Tags = {}
			}
		},
		plinthRiser = {
			source = O.SpawnSources.plinthRiser,
			position = {0.00, 1.5, 32.42},
			rotation = {0.00, 180.00, 0.00},
			scale = {0.5, 1.12, 0.5},
			data = {
				Tags = {"plinthRiser"}
			}
		}
	}

local function assignHouseCard(playerRef, houseName, isResettingHouseCard)
	local player = S.getPlayer(playerRef)
	if player == nil then return end

	local houseCard = U.find(getObjects(), function(obj) return string.match(obj.getName(), "^.* of " .. houseName) end)
	U.Assert("assignHouseCard", houseCard, "userdata")

	local toTransform = P.getRotatedPlayerTransform(ObjectData.houseCard, player)

	local isDone = false
	U.sequence({
		function()
			houseCard.setPosition(toTransform.position)
			houseCard.setRotation(toTransform.rotation)
			houseCard.setScale(toTransform.scale)
			houseCard.setTags({"HouseCard", player.color})
			-- log({isResettingHouseCard = isResettingHouseCard})
			if isResettingHouseCard then
				houseCard.call("ResetCard")
			end
		end,
		1,
		function() houseCard.reload(); isDone = true end
	})
	return function() return isDone == true end
end

local function applyObjData(partName, playerRef, houseName)
	local oParams = ObjectData[partName]
	if oParams == nil then return end
	if oParams.source == nil then return end
	if oParams.isSpawning == false then return end

	local player = S.getPlayer(playerRef)

	local sourceObj = oParams.source()

	-- Get object spawn data, from source object
	if sourceObj == nil then return end
	local spawnData = sourceObj.getData()

	-- Overwrite spawnData with ObjectData.data entries
	for key, val in pairs(oParams.data or {}) do
		if key == "Tags" then
			if val == false then
				val = {}
			elseif U.Type(val) == "table" then
				val = U.concat(val, {partName})
				if player ~= nil then
					val = U.concat(val, {player.color})
				end
			end
		end
		spawnData[key] = val
	end

	-- Perform special operations depending on object type
	-- ... Set Image URLs
	if partName == "screenCenter" then
		spawnData.CustomImage.ImageURL = HouseData[houseName].HouseScreen.top
		spawnData.CustomImage.ImageSecondaryURL = HouseData[houseName].HouseScreen.bottom
	elseif partName == "screenFlapLeft" then
		spawnData.CustomImage.ImageURL = HouseData[houseName].HouseScreen.leftTop
		spawnData.CustomImage.ImageSecondaryURL = HouseData[houseName].HouseScreen.leftBottom
	elseif partName == "screenFlapRight" then
		spawnData.CustomImage.ImageURL = HouseData[houseName].HouseScreen.rightTop
		spawnData.CustomImage.ImageSecondaryURL = HouseData[houseName].HouseScreen.rightBottom
	end

	-- ... Assign Hidden Zones to players, dim color intensity, set GM Notes so they can be found later
	if player and U.isIn(partName, {"zoneHiderHouseCard", "zoneHiderGeneral"}) then
		spawnData.FogColor = player.color
		local diffuseColor = Color[player.color]
		diffuseColor.a = 0.15
		spawnData.ColorDiffuse = Color(diffuseColor)
		spawnData.GMNotes = "ZonePlayer" .. player.color
	end

	-- ... Apply proper Transform
	local transformData = {
		position = Vector(ObjectData[partName].position),
		rotation = Vector(ObjectData[partName].rotation)
	}

	if player ~= nil then
		transformData = P.getRotatedPlayerTransform(transformData, player, 0)
	end

	spawnData.Transform = {
		posX = transformData.position.x,
		posY = transformData.position.y,
		posZ = transformData.position.z,
		rotX = transformData.rotation.x,
		rotY = transformData.rotation.y,
		rotZ = transformData.rotation.z,
		scaleX = ObjectData[partName].scale[1],
		scaleY = ObjectData[partName].scale[2],
		scaleZ = ObjectData[partName].scale[3]
	}

	return spawnData
end

function HouseScreen.Spawn(playerRef, houseName, isResettingHouseCard)
	local player = S.getPlayer(playerRef)
	-- log("Spawning '" .. houseName .. "' for Player #" .. playerNum)
	P.ClearSeat(player.color)
	if houseName == nil then return end
	return U.map(ObjectData, function(objData, objName)
		local spawnData
		if objName == "houseCard" then
			return assignHouseCard(playerRef, houseName, isResettingHouseCard)
		else
			spawnData = applyObjData(objName, playerRef, houseName) -- objData.source().getData()
		end

		if spawnData == nil then return end

		local isSpawned = false
		spawnObjectData({
			data = spawnData,
			callback_function = function(obj)
				if string.match(objName, "^light") then
					obj.getChildren()[1].getChildren()[2].getComponents()[2].set("enabled", false)
				end
				isSpawned = true
			end
		})

		return function() return isSpawned == true end
	end)
end


return HouseScreen
end)
__bundle_register("kingsdilemma.core.players", function(require, _LOADED, __bundle_register, __bundle_modules)
local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
local C = require("kingsdilemma.lib.constants")
local O = require("kingsdilemma.lib.objects")
local OU = require("kingsdilemma.objects.objUtilities")

local P = {}

function P.InitializeSeatHandZones()
	S.UpdatedSeatedPlayerData()

	local seats = U.slice(Player.getColors(), 2, 6)
	-- log({SeatColors = seats})
	local players = S.getPlayers()

	local function initSeat(color)
		local angle = S.getPlayerAngle(color)
		local handTransform = OU.RotateByAngle(U.clone(C.BaseHandTransform), angle)
		local hZone = U.getHandZone(color)
		if hZone == nil then
			U.RunSequence({
				function()
					return spawnObjectData({
						data = {
							Name = "HandTrigger",
							FogColor = color,
							Transform = OU.unfoldTransform(handTransform)
						}
					})
				end,
				function()
					Player[color].setHandTransform(handTransform)
				end
			})
		else
			Player[color].setHandTransform(handTransform)
		end

		P.SetCamera("BehindScreen", color)
	end

	seats = Player.getAvailableColors()
	U.Assert("P.UpdatePlayerSeats - #seats", #seats >= 3 and #seats <= 5)
	U.Assert("P.UpdatePlayerSeats - Requires between three and five seated players.", #players >= 3 and #players <= 5)

	if #players < #seats then
		local excessSeats = U.slice(seats, #players + 1, #seats)
		seats = U.slice(seats, 1, #players)
		U.forEach(excessSeats, function(sColor)
			U.getHandZone(sColor).destruct()
		end)
	end

	U.iForEach(seats, function(sColor) initSeat(sColor) end)
end

function P.ClearSeat(color)
	if color == nil then return U.forEach(Player.getAvailableColors(), P.ClearSeat) end
	local playerObjects = getObjectsWithTag(color)
	local playerZones = U.filter(getObjects(), function(obj) return obj.getGMNotes() == "ZonePlayer" .. color end)

	-- destroy POWER
	-- destroy COIN
	-- recover SECRET AGENDA
	-- unassign LEADER or MODERATOR


	U.forEach(U.concat(playerObjects, playerZones), function(obj)
		if obj.hasTag("HouseCard") then
			obj.setTags({"HouseCard"})
			obj.setPosition(C.Spots.Storage.HouseCard.position)
			obj.setRotation(C.Spots.Storage.HouseCard.rotation)
			obj.setScale(C.Spots.Storage.HouseCard.scale)
		else
			obj.destruct()
		end
	end)
end
function P.ClearSeats() U.forEach(Player.getAvailableColors(), P.ClearSeat); return 2 end

function P.getRotatedPlayerTransform(objOrTransform, player, fromAngle)
	objOrTransform = U.clone(objOrTransform, true)
	objOrTransform = OU.foldTransform(objOrTransform)
	if fromAngle == nil then
		fromAngle = OU.GetNearestAngle(objOrTransform, S.getSeatAngles())
	end
	local toAngle = S.getPlayerAngle(player)
	return OU.RotateByAngle(objOrTransform, toAngle - fromAngle)
end

function P.RotateToPlayer(objs, player, fromAngle, fromTransform, totalTime)
	if totalTime == nil then totalTime = 2 end
	if U.Type(objs) ~= "table" then objs = {objs} end

	return U.map(objs, function(obj)
		local startPos = obj.getPosition()
		local toData = P.getRotatedPlayerTransform(fromTransform or obj, player, fromAngle)
		local endPos, endRot = toData.position, toData.rotation
		local raiseTime, travelTime = totalTime / 4, totalTime / 2

		return U.RunSequence({
			function()
				U.setRotationSlow(obj, endRot, totalTime)
				return U.setPositionSlow(obj, Vector(startPos):add(Vector(0, 2, 0)), raiseTime)
			end,
			function()
				return U.setPositionSlow(obj, Vector(endPos):add(Vector(0, 2, 0)), travelTime)
			end,
			function()
				return U.setPositionSlow(obj, endPos, raiseTime)
			end
		})
	end)
end

function P.AssignOpenSeat(player) player.changeColor(S.getOpenColors()[1]) end

function P.AssignPlayerColors(isNotShuffling)
	if S.isInMode(C.Modes.NONE) then
		U.forEach(U.getKeys(S.getStateVal("playerStorage")), function(pID) S.setStateVal(nil, "playerStorage", pID, "curColor") end)
		local players = U.slice(Player.getPlayers(), 1, 5)
		local seatColors = U.slice(Player.getColors(), 2, #players + 1)
		if isNotShuffling ~= true then
			U.shuffle(seatColors)
		end
		return U.RunSequence({
			function()
				return U.sequence(U.map(Player.getPlayers(), function(player) return function() player.changeColor("Grey") end end), 0.5)
			end,
			function()
				return U.sequence(U.map(players, function(player) return function()
					local pColor = U.shift(seatColors)
					S.setPlayerVal(pColor, player, "curColor")
					player.changeColor(pColor)
				end
			end), 0.75)
		end})
	else
		local players = Player.getPlayers()
		return U.RunSequence({
			function()
				return U.sequence(U.map(players, function(player) return function() player.changeColor("Grey") end end), 0.5)
			end,
			function()
				return U.sequence(U.map(players, function(player)
					local pID
					if string.match(player.steam_name, "^Player ") then
						pID = player.steam_name
						local storedColor = S.getStateVal("playerStorage", pID, "curColor")
						if storedColor == nil then
							error("Must first transfer player data before you can assign colors to test players.")
						end
					else
						pID = player.steam_id
					end
					return function() player.changeColor(S.getStateVal("playerStorage", pID, "curColor")) end
				end), 0.75)
			end
		})
	end
end

function P.SetCamera(cameraMode, playerRef, playerCamRef)
	if playerRef == nil then return U.map(S.getPlayers(), function(player) return P.SetCamera(cameraMode, player) end) end

	local player = S.getPlayer(playerRef)
	local playerCam = player
	if playerCamRef then
		playerCam = S.getPlayer(playerCamRef)
	end
	local cameraData = U.clone(C.CameraAngles[cameraMode])

	U.Val("P.SetCamera", cameraMode, cameraData ~= nil, "Not a valid camera mode")

	if cameraData.isPlayerAngle and S.getPlayerAngle(player) then
		cameraData.position = Vector(cameraData.position):rotateOver("y", S.getPlayerAngle(player))
		cameraData.yaw = S.getPlayerAngle(player) + cameraData.yaw
		cameraData.isPlayerAngle = nil
	end

	-- log(cameraData)
	playerCam.setCameraMode("ThirdPerson")
	playerCam.lookAt(cameraData)
	playerCam.setCameraMode("ThirdPerson")
	return 0.5
end

function P.DealAll(cards, playerRef)
	local player = S.getPlayer(playerRef)
	U.Val("P.DealAll", cards, U.Type(cards) == "table" or (U.Type(cards) == "userdata" and (cards.type == "Deck" or cards.type == "Card")))

	local function dealNextCard()
		if U.Type(cards) == "table" then
			if #cards > 0 then
				local card = U.shift(cards)
				card.deal(1, player.color)
			end
		elseif cards.type == "Deck" then
			cards.deal(1, player.color)
			if cards.remainder ~= nil then
				cards = {cards.remainder}
			end
		end
		return 0.5
	end

	local numCards
	if U.Type(cards) == "table" then numCards = #cards
	elseif cards.type == "Deck" then numCards = #cards.getObjects()
	else return error("P.DealAll: Must submit a deck, a card, or a table of cards.") end

	-- log({cards, player.color, numCards})

	local seqFuncs = {}

	for i = 1, numCards do
		table.insert(seqFuncs, dealNextCard)
	end

	U.RunSequence(seqFuncs)

	return U.sequence(seqFuncs, 0.25)
end

function P.GetPlayerName(playerRef)
	if S.getPlayerVal(playerRef, "houseName") then
		return "House " .. S.getPlayerVal(playerRef, "houseName")
	else
		return S.getPlayerVal(playerRef, "house")
	end
end

function P.GetMostPrestigious()
	local prestigeData = U.map(S.getPlayers(), function(player)
		return {
			player = player,
			prestige = S.getPlayerVal(player, "prestige")
		}
	end)
	table.sort(prestigeData, function(a, b) return a.prestige > b.prestige end)
	return prestigeData[1].player
end

function P.GetLeastPrestigious()
	local prestigeData = U.map(S.getPlayers(), function(player)
		return {
			player = player,
			prestige = S.getPlayerVal(player, "prestige")
		}
	end)
	table.sort(prestigeData, function(a, b) return a.prestige < b.prestige end)
	return prestigeData[1].player
end

function P.GetNextLeastPrestigious(playerRef)
	local refPlayer = S.getPlayer(playerRef)
	local refPrestige = S.getPlayerVal(refPlayer, "prestige")
	local lesserPlayers = U.filter(S.getPlayers(), function(player) return S.getPlayerVal(player, "prestige") > refPrestige end)
	if #lesserPlayers == 0 then return false end
	local prestigeData = U.map(lesserPlayers, function(player)
		return {
			player = player,
			prestige = S.getPlayerVal(player, "prestige")
		}
	end)
	table.sort(prestigeData, function(a, b) return a.prestige < b.prestige end)
	return prestigeData[1].player
end

function P.AssignLeader(playerRef)
	if playerRef == nil then return P.AssignLeader(P.GetMostPrestigious()) end
	local player = S.getPlayer(playerRef)
	S.setStateVal(player.color, "gameState", "leader")
	return {
		P.RotateToPlayer(O.Leader.Figure(), player, 0, C.Spots.Storage.LeaderFigure, 1),
		P.RotateToPlayer(O.Leader.Light(), player, 0, C.Spots.Storage.LeaderLight, 1)
	}
end

function P.AssignModerator(playerRef)
	if playerRef == nil then return P.AssignModerator(P.GetLeastPrestigious()) end
	local player = S.getPlayer(playerRef)
	S.setStateVal(player.color, "gameState", "moderator")
	return {
		P.RotateToPlayer(O.Moderator.Figure(), player, 0, C.Spots.Storage.ModeratorFigure, 1),
		P.RotateToPlayer(O.Moderator.Light(), player, 0, C.Spots.Storage.ModeratorLight, 1)
	}
end

function P.GetLeader() return S.getPlayer(S.getStateVal("gameState", "leader")) or P.GetMostPrestigious() end
function P.GetModerator() return S.getPlayer(S.getStateVal("gameState", "moderator")) or P.GetLeastPrestigious() end
function P.GetLeaderName() return P.GetPlayerName(P.GetLeader()) end
function P.GetModeratorName() return P.GetPlayerName(P.GetModerator()) end


function P.GetPlayerZone(playerRef, zoneRef)
	local playerColor = S.getPlayer(playerRef).color
	if zoneRef == "Aye" then
		return getObjectsWithAllTags({playerColor, "Zone_VoteAye"})[1]
	elseif zoneRef == "Nay" then
		return getObjectsWithAllTags({playerColor, "Zone_VoteNay"})[1]
	elseif zoneRef == "Pass" then
		return getObjectsWithAllTags({playerColor, "Zone_VotePass"})[1]
	elseif zoneRef == "Power" then
		return getObjectsWithAllTags({playerColor, "zonePrivatePower"})[1]
	elseif zoneRef == "Coin" then
		return getObjectsWithAllTags({playerColor, "zonePrivateCoin"})[1]
	elseif zoneRef == "Public" then
		return getObjectsWithAllTags({playerColor, "Zone_PublicUI"})[1]
	end
end

function P.GetPlayerCard(playerRef)
	local player = S.getPlayer(playerRef)
	U.Val("P.GetPlayerCard()", playerRef, U.isPlayer(player), "Not a player")
	return getObjectsWithAllTags({"HouseCard", player.color})[1]
end

function P.GetPlayerScreen(playerRef)
	local player = S.getPlayer(playerRef)
	U.Val("P.GetPlayerScreen()", playerRef, U.isPlayer(player), "Not a player")
	return getObjectsWithAllTags({"screenCenter", player.color})[1]
end

function P.ActivatePlayerScreenHUD(playerRef)
	if playerRef == nil then return U.map(S.getPlayers(), P.ActivatePlayerScreenHUD) end
	local houseScreen = P.GetPlayerScreen(playerRef)
	if houseScreen == nil then return 0 end
	houseScreen.call("Activate")
	return 0.5
end

function P.SpawnPower(playerRef, numPower) return OU.SpawnValue(P.GetPlayerZone(playerRef, "Power"), numPower, "PowerToken") end
function P.TakePower(playerRef, numPower) return OU.TakeValue(P.GetPlayerZone(playerRef, "Power"), numPower, "PowerToken") end
function P.SpawnCoins(playerRef, numCoins) return OU.SpawnValue(P.GetPlayerZone(playerRef, "Coin"), numCoins, "CoinToken") end
function P.TakeCoins(playerRef, numCoins) return OU.TakeValue(P.GetPlayerZone(playerRef, "Coin"), numCoins, "CoinToken") end
function P.TransferPower(fromPlayerRef, toPlayerRef, numPower)
	return OU.TransferValue(
		P.GetPlayerZone(fromPlayerRef, "Power"),
		P.GetPlayerZone(toPlayerRef, "Power"),
		numPower,
		"PowerToken"
	)
end
function P.TransferCoins(fromPlayerRef, toPlayerRef, numCoins)
	return OU.TransferValue(
		P.GetPlayerZone(fromPlayerRef, "Coin"),
		P.GetPlayerZone(toPlayerRef, "Coin"),
		numCoins,
		"CoinToken"
	)
end

return P
end)
__bundle_register("kingsdilemma.objects.objUtilities", function(require, _LOADED, __bundle_register, __bundle_modules)
local U = require("lib.utilities")
local C = require("kingsdilemma.lib.constants")
local O = require("kingsdilemma.lib.objects")
local OU = {}

function OU.foldTransform(objOrTransform, positionDelta, rotationDelta)
	if U.Type(objOrTransform) == "userdata" and objOrTransform.getData ~= nil then
		objOrTransform = objOrTransform.getData().Transform
	end
	if U.Type(objOrTransform) ~= "table" then return end
	if U.Type(objOrTransform.Transform) == "table" then
		objOrTransform = objOrTransform
	end
	objOrTransform = U.clone(objOrTransform)

	if objOrTransform.posX ~= nil then
		if objOrTransform.rotX == nil then
			objOrTransform.rotX = 0
			objOrTransform.rotY = 0
			objOrTransform.rotZ = 0
		end
		if objOrTransform.scaleX == nil then
			objOrTransform.scaleX = 1
			objOrTransform.scaleY = 1
			objOrTransform.scaleZ = 1
		end
		objOrTransform = {
			position = Vector({objOrTransform.posX, objOrTransform.posY, objOrTransform.posZ}),
			rotation = Vector({objOrTransform.rotX, objOrTransform.rotY, objOrTransform.rotZ}),
			scale = Vector({objOrTransform.scaleX, objOrTransform.scaleY, objOrTransform.scaleZ}),
		}
	end

	if U.Type(objOrTransform.position) == "table" then
		if positionDelta ~= nil then
			objOrTransform.position = objOrTransform.position:add(positionDelta)
		end
		if rotationDelta ~= nil then
			objOrTransform.rotation = objOrTransform.rotation:add(rotationDelta)
		end
		return {
			position = Vector(objOrTransform.position),
			rotation = Vector(objOrTransform.rotation or {0, 0, 0}),
			scale = Vector(objOrTransform.scale or {1, 1, 1})
		}
	end
end

function OU.unfoldTransform(objOrTransform, positionDelta, rotationDelta)
	if positionDelta ~= nil or rotationDelta ~= nil then
		objOrTransform = OU.foldTransform(objOrTransform, positionDelta, rotationDelta)
	end
	if U.Type(objOrTransform) == "userdata" and objOrTransform.getData ~= nil then
		return objOrTransform.getData().Transform
	end
	if U.Type(objOrTransform) ~= "table" then return end
	if U.Type(objOrTransform.Transform) == "table" then
		return U.clone(objOrTransform.Transform)
	end

	if objOrTransform.position ~= nil then
		local position = Vector(objOrTransform.position)
		local rotation = Vector(objOrTransform.rotation or {0, 0, 0})
		local scale = Vector(objOrTransform.scale or {1, 1, 1})
		return {
			posX = position.x,
			posY = position.y,
			posZ = position.z,
			rotX = rotation.x,
			rotY = rotation.y,
			rotZ = rotation.z,
			scaleX = scale.x,
			scaleY = scale.y,
			scaleZ = scale.z
		}
	end

	if objOrTransform.posX ~= nil then
		return {
			posX = objOrTransform.posX,
			posY = objOrTransform.posY,
			posZ = objOrTransform.posZ,
			rotX = objOrTransform.rotX or 0,
			rotY = objOrTransform.rotY or 0,
			rotZ = objOrTransform.rotZ or 0,
			scaleX = objOrTransform.scaleX or 1,
			scaleY = objOrTransform.scaleY or 1,
			scaleZ = objOrTransform.scaleZ or 1
		}
	end
end

function OU.SpawnToken(objOrBounds, tokenType, tokenValue, yShift)
	if yShift == nil then yShift = 3 end
	local sourceObj
	if tokenType == "Power" then
		sourceObj = O.SpawnSources["powerToken" .. tokenValue]()
	elseif tokenType == "Coin" then
		sourceObj = O.SpawnSources["coinToken" .. tokenValue]()
	end
	local spawnData = sourceObj.getData()
	spawnData.Value = tokenValue
	spawnData.Transform = OU.unfoldTransform({
		position = U.getScatterPosition(objOrBounds, yShift, 0.6),
		rotation = U.isGameObject(objOrBounds) and objOrBounds.getRotation() or Vector(0, 0, 0),
		scale = sourceObj.getScale()
	})
	spawnData.Tags = {tokenType .. "Token", "Value" .. tokenValue}
	spawnObjectData({
		data = spawnData,
		callback_function = function(obj)
			obj.setLock(false)
		end
	})
	return 0.1
end

function OU.GetTotalValue(zoneOrObjs, tag)
	if type(zoneOrObjs) == "userdata" then return OU.GetTotalValue(zoneOrObjs.getObjects(), tag) end
	if tag ~= nil then zoneOrObjs = U.filter(zoneOrObjs, function(obj) return obj.hasTag(tag) end) end
	local total = 0
	U.forEach(zoneOrObjs, function(obj) total = total + obj.value end)
	return total
end
function OU.GetUpValueData(objs, tag)
	objs = U.filter(objs, function(obj) return obj.hasTag(tag) end)

	local totalValue = OU.GetTotalValue(objs, tag)

	if tag == "CoinToken" then
		return {
			coinToken5 = math.floor(totalValue / 5),
			coinToken1 = totalValue - (5 * math.floor(totalValue / 5))
		}
	elseif tag == "PowerToken" then
		log({
			totalValue = totalValue,
			powerToken10 = math.floor(totalValue / 10),
			powerToken5 = math.floor((totalValue - (10 * math.floor(totalValue / 10))) / 5),
			powerToken1 = totalValue - 5 * math.floor((totalValue - (10 * math.floor(totalValue / 10))) / 5) - 10 * math.floor(totalValue / 10)
		})
		return {
			powerToken10 = math.floor(totalValue / 10),
			powerToken5 = math.floor((totalValue - (10 * math.floor(totalValue / 10))) / 5),
			powerToken1 = totalValue - 5 * math.floor((totalValue - (10 * math.floor(totalValue / 10))) / 5) - 10 * math.floor(totalValue / 10)
		}
	else
		return {}
	end
end
function OU.GetDownValueData(obj)
	if obj.hasTag("CoinToken") then
		if obj.value == 5 then
			return 1, O.SpawnSources.coinToken1(), {"CoinToken", "Value1"}
		end
	elseif obj.hasTag("PowerToken") then
		if obj.value == 10 then
			return 5, O.SpawnSources.powerToken5(), {"PowerToken", "Value5"}
		elseif obj.value == 5 then
			return 1, O.SpawnSources.powerToken1(), {"PowerToken", "Value1"}
		end
	end
	return false, false, false
end

function OU.GetNumObjsByVal(objs, val, tag)
	return #U.filter(objs, function(obj) return obj.hasTag(tag) and obj.value == val end)
end

function OU.GetNumCombinedObjs(objs)
	return {
		power = U.sumVals(OU.GetUpValueData(objs, "PowerToken")),
		coin = U.sumVals(OU.GetUpValueData(objs, "CoinToken"))
	}
end

function OU.GetNumSplitObjs(objs)
	return {
		power = U.sumVals(
			U.map(
				U.filter(objs, function(o) return o.hasTag("PowerToken") end),
				function(pToken) return OU.GetDownValueData(pToken) or 0 end
			)
		),
		coin = U.sumVals(
			U.map(
				U.filter(objs, function(o) return o.hasTag("CoinToken") end),
				function(cToken) return OU.GetDownValueData(cToken) or 0 end
			)
		)
	}
end

function OU.SpawnFromSourceObj(sourceObj, tags, transformData, positionDelta, rotationDelta, isLocked)
	local spawnData = sourceObj.getData()
	local token
	spawnData.Transform = OU.unfoldTransform(transformData, positionDelta, rotationDelta)
	spawnData.Tags = tags
	spawnObjectData({
		data = spawnData,
		callback_function = function(obj)
			obj.setLock(isLocked == true)
			token = obj
		end
	})
	return function() return token ~= nil and token.resting and not token.loading_custom end
end
function OU.JumpDestroy(obj, delayTime)
	delayTime = delayTime or 0.5
	obj.setPosition(obj.getPosition():add(Vector(0, 1, 0)))
	obj.addForce(Vector(0, 50, 0), 3)
	Wait.time(function() obj.destruct() end, delayTime)
	return delayTime
end

function OU.TransferObjects(fromZone, toZone, tag, amount)

	local objs = fromZone.getObjects()
	if tag ~= nil then
		objs = U.filter(objs, function(obj) return obj.hasTag(tag) end)
	end
	local toZoneBounds = toZone.getBounds()
	toZoneBounds.size = toZone.getScale()

	amount = amount or #objs

	local function transferObj(obj)
		obj.setPosition(obj.getPosition():add(Vector(0, 1, 0)))
		obj.addForce(Vector(0, 50, 0), 3)
		Wait.time(function()
			obj.setPosition(U.getScatterPosition(toZoneBounds, 2, 0.6))
		end, 0.5)
	end

	local seqFuncs = {}

	for i = 1, amount do
		local obj = U.shift(objs)
		table.insert(seqFuncs, function() transferObj(obj) end)
	end

	U.sequence(seqFuncs, 0.15)
end

function OU.SplitObjByValue(obj)
	local newValue, spawnSource, tags = OU.GetDownValueData(obj)
	if spawnSource == false then return 0 end

	local position = obj.getPosition()

	local seqFuncs = {
		function() OU.JumpDestroy(obj, 0.25) end
	}

	for i = 1, obj.value / newValue do
		table.insert(seqFuncs, function()
			OU.SpawnFromSourceObj(spawnSource, tags, {
				position = U.getScatterPosition(Vector(position), 1, 1),
				rotation = spawnSource.getRotation(),
				scale = spawnSource.getScale()
			})
		end)
	end

	return U.sequence(seqFuncs, 0.15)
end

function OU.CombineObjsByValue(objs)
	local powerObjs = U.filter(objs, function(obj) return obj.hasTag("PowerToken") end)
	local coinObjs = U.filter(objs, function(obj) return obj.hasTag("CoinToken") end)

	local function getAvgCoord(os, coord)
		local coordTotal = 0
		U.forEach(os, function(obj) coordTotal = coordTotal + obj.getPosition()[coord] end)
		return coordTotal / #os
	end

	local position = Vector(getAvgCoord(objs, "x"), getAvgCoord(objs, "y"), getAvgCoord(objs, "z"))
	local spawnDataPower = OU.GetUpValueData(powerObjs, "PowerToken")
	local spawnDataCoin = OU.GetUpValueData(coinObjs, "CoinToken")

	local seqFuncs = {}

	for i = 1, #powerObjs do
		table.insert(seqFuncs, function() OU.JumpDestroy(powerObjs[i], 0.25) end)
	end
	U.iForEach({1, 5, 10}, function(val)
		local spawnDataKey = "powerToken" .. val
		if spawnDataPower[spawnDataKey] == nil then return end
		local spawnSource = O.SpawnSources[spawnDataKey]()
		local tags = {"PowerToken", "Value" .. val}
		for i = 1, spawnDataPower[spawnDataKey] do
			table.insert(seqFuncs, function()
				OU.SpawnFromSourceObj(spawnSource, tags, {
					position = U.getScatterPosition(Vector(position), 1, 1),
					rotation = spawnSource.getRotation(),
					scale = spawnSource.getScale()
				})
			end)
		end
	end)
	for i = 1, #coinObjs do
		table.insert(seqFuncs, function() OU.JumpDestroy(coinObjs[i], 0.25) end)
	end
	U.iForEach({1, 5}, function(val)
		local spawnDataKey = "coinToken" .. val
		if spawnDataCoin[spawnDataKey] == nil then return end
		local spawnSource = O.SpawnSources[spawnDataKey]()
		local tags = {"CoinToken", "Value" .. val}
		for i = 1, spawnDataCoin[spawnDataKey] do
			table.insert(seqFuncs, function()
				OU.SpawnFromSourceObj(spawnSource, tags, {
					position = U.getScatterPosition(Vector(position), 1, 1),
					rotation = spawnSource.getRotation(),
					scale = spawnSource.getScale()
				})
			end)
		end
	end)

	return U.sequence(seqFuncs, 0.15)
end

function OU.SpawnValue(toZones, amount, tag)
	if U.Type(toZones) == "table" then
		if #toZones == 0 then return 0 end
		if #toZones > 1 then return U.RunSequence(U.iMap(toZones, function(toZone) return OU.SpawnValue(toZone, amount, tag) end)) end
		toZones = toZones[1]
	end
	U.Assert("OU.SpawnValue", toZones, U.Type(toZones) == "userdata")

	local denoms = tag == "PowerToken" and {10, 5, 1} or {5, 1}

	local seqFuncs = {}
	for _, val in ipairs(denoms) do
		while (val == 1 and amount >= val) or (amount > val) do
			table.insert(seqFuncs, function() return OU.SpawnToken(toZones, string.gsub(tag, "Token$", ""), val) end)
			amount = amount - val
		end
	end
	return U.sequence(seqFuncs, 0.15)
end

function OU.TakeValue(fromZone, amount, tag)
	local seqFuncs = {}

	local zoneObjs = U.filter(fromZone.getObjects(), function(obj) return obj.hasTag(tag) end)

	for _, val in ipairs({10, 5, 1}) do
		while amount >= val and OU.GetNumObjsByVal(zoneObjs, val, tag) > 0 do
			local thisObj = U.pluck(zoneObjs, function(obj) return obj.hasTag(tag) and obj.value == val end)
			table.insert(seqFuncs, function() OU.JumpDestroy(thisObj, 0.15) end)
			amount = amount - val
		end
	end

	for _, val in ipairs({5, 10}) do
		while amount > 0 and OU.GetNumObjsByVal(zoneObjs, val, tag) > 0 do
			local thisObj = U.pluck(zoneObjs, function(obj) return obj.hasTag(tag) and obj.value == val end)
			table.insert(seqFuncs, function() OU.JumpDestroy(thisObj, 0.15) end)
			amount = amount - val
		end
	end

	-- if fromZoneAmount is negative now, spawn value to zero it out
	if amount < 0 then
		table.insert(seqFuncs, function() return OU.SpawnValue(fromZone, amount * -1, tag) end)
	end

	return U.sequence(seqFuncs, 0.15)
end

function OU.TransferValue(fromZone, toZones, amountPerZone, tag)
	U.Val("OU.TransferValue", fromZone, U.Type(fromZone) == "userdata" and fromZone.type == "Scripting", "From-zone is not a zone.")
	if U.Type(toZones) == "userdata" then toZones = {toZones} end

	return U.RunSequence({
		function() return OU.TakeValue(fromZone, amountPerZone * #toZones, tag) end,
		function() return OU.SpawnValue(toZones, amountPerZone, tag) end
	})
end

function OU.getAngleOf(objOrTransform)
	local posData = OU.foldTransform(objOrTransform).position
	local zeroPos = Vector(0, 0, C.TableRadius)
	local angle = posData:angle(zeroPos)
	if posData.x < 0 then
		angle = 360 - angle
	end
	return angle
end

function OU.GetNearestAngle(objOrTransform, seatAngles)
	local objAngle = OU.getAngleOf(objOrTransform)
	table.insert(seatAngles, 1, 0)
	local nearestAngle = 1000
	U.forEach(seatAngles, function(pAngle)
		if math.abs(pAngle - objAngle) < math.abs(nearestAngle - objAngle) then
			nearestAngle = pAngle
		end
	end)
	return nearestAngle
end

function OU.RotateByAngle(objOrTransform, angleDelta)
	local objTransform = OU.foldTransform(objOrTransform)
	if objTransform == nil then return end
	return {
		position = Vector(objTransform.position):rotateOver("y", angleDelta),
		rotation = Vector(objTransform.rotation):add(Vector(0, angleDelta, 0)),
		scale = objTransform.scale
	}
end

function OU.GetStepsBetween(startVector, endVector, numSteps)
	-- Vector 5 -> Vector 3, 3 steps.  Distance = 2.  StepSize = Distance/(steps - 1)
	-- Vector 25 -> 20, 6 steps.  Distance = 5. StepSize = Distance/(steps - 1)
	local distVector = Vector(endVector):sub(Vector(startVector))
	local vectorDelta = Vector(distVector):scale(Vector(1/(numSteps - 1), 1/(numSteps - 1), 1/(numSteps - 1)))
	local steps = {}
	local curVector = Vector(startVector)
	while #steps < numSteps do
		table.insert(steps, Vector(curVector))
		curVector:add(Vector(vectorDelta))
	end

	-- log(steps)

	return steps
end

function OU.FindNearestSnapPoint(objOrTransform, obj, includeAll)
	-- log({
	-- 	objOrTransform = objOrTransform,
	-- 	obj = obj,
	-- 	includeAll = includeAll,
	-- 	traceback = debug.traceback()
	-- })
	local position = OU.foldTransform(objOrTransform).position

	local snapPoints, unfilteredSnaps
	if obj == nil then
		snapPoints = Global.getSnapPoints()
		unfilteredSnaps = Global.getSnapPoints()
	else
		snapPoints = obj.getSnapPoints()
		unfilteredSnaps = obj.getSnapPoints()
	end

	if U.isGameObject(objOrTransform) then
		local objTags = objOrTransform.getTags()
		snapPoints = U.filter(snapPoints, function(snap)
			-- log(snap)
			-- log({tags = U.join(snap.tags, ", "), objTags = U.join(objOrTransform.getTags(), ", "), hasAnyTags = objOrTransform.hasAnyTags(snap.tags)})
			if #U.getValues(snap.tags) == 0 then return true end
			return U.find(snap.tags, function(tag) return U.isIn(tag, objTags) end)
		end)
	end

	-- log({isGameObject = U.isGameObject(objOrTransform), objOrTransform = U.ToString(objOrTransform), numSnaps = #snapPoints, numUnfiltered = #unfilteredSnaps})

	local snapPositions = U.iMap(snapPoints, function(snap) return obj.positionToWorld(snap.position) end)
	local sortedPositions = U.clone(snapPositions)

	table.sort(sortedPositions, function(a, b) return Vector(a):distance(position) < Vector(b):distance(position) end)

	local distTolerance = 0.25 * (sortedPositions[1]:distance(sortedPositions[2]))

	-- log({sorted = sortedPositions})

	local nearestSnapPos = sortedPositions[1]

	if includeAll then
		return U.findIndex(unfilteredSnaps, function(objSnap)
			local snapPos = obj.positionToWorld(objSnap.position)
			return snapPos:distance(nearestSnapPos) < distTolerance
		end)
	else
		return U.findIndex(snapPoints, function(objSnap)
			local snapPos = obj.positionToWorld(objSnap.position)
			return snapPos:distance(nearestSnapPos) < distTolerance
		end)
	end
end

function OU.SetBoardSnapPoints()
	local board = O.UninteractableObjs.Board()
	local resourceHorizSteps = U.iMap(OU.GetStepsBetween(
		Vector(C.Spots.Board.ResourceTokens.Influence.center.position),
		Vector(C.Spots.Board.ResourceTokens.Knowledge.center.position),
		5
	), function(pos) return pos.x end)
	local cCardHorizSteps = U.iMap(OU.GetStepsBetween(
		Vector(C.Spots.Board.ChronicleStickers.bottom.position),
		Vector(C.Spots.Board.ChronicleStickers.top.position),
		3
	), function(pos) return pos.x end)
	local cCardVertSteps = U.iMap(OU.GetStepsBetween(
		Vector(C.Spots.Board.ChronicleStickers.top.position),
		Vector(C.Spots.Board.ChronicleStickers.bottom.position),
		5
	), function(pos) return pos.z end)

	-- log({horiz = cCardHorizSteps, vert = cCardVertSteps})

	local snapPoints = {}
	U.iForEach(OU.GetStepsBetween(
		C.Spots.Board.StabilityToken.bottom.position,
		C.Spots.Board.StabilityToken.top.position,
		19), function(pos)
			table.insert(snapPoints, {
				position = U.roundVector(board.positionToLocal(pos)),
				rotation = U.roundVector(Vector(C.Spots.Board.StabilityToken.top.rotation):sub(board.getRotation())),
				rotation_snap = true,
				tags = {"StabilityMarker"}
			})
		end)

	U.iForEach(C.Resources, function(resName, i)
		local startPos = Vector(C.Spots.Board.ResourceTokens[resName].bottom.position):setAt("x", resourceHorizSteps[i])
		local endPos = Vector(C.Spots.Board.ResourceTokens[resName].top.position):setAt("x", resourceHorizSteps[i])
		U.iForEach(OU.GetStepsBetween(
			startPos,
			endPos,
			17), function(pos)
				table.insert(snapPoints, {
					position = U.roundVector(board.positionToLocal(pos)),
					rotation = U.roundVector(Vector(C.Spots.Board.ResourceTokens[resName].top.rotation):sub(board.getRotation())),
					rotation_snap = false,
					tags = {resName}
				})
			end)
		end)


	U.iForEach(C.Resources, function(resName, i)
		for j = 1, 3 do
			local pos = Vector(C.Spots.Board.ChronicleStickers.top.position)
			pos.x = cCardHorizSteps[j]
			pos.z = cCardVertSteps[i]

			table.insert(snapPoints, {
				position = U.roundVector(board.positionToLocal(pos)),
				rotation = U.roundVector(Vector(C.Spots.Board.ChronicleStickers.top.rotation):sub(board.getRotation())),
				rotation_snap = true,
				tags = {"ChronicleSticker"}
			})
		end
	end)

	board.setSnapPoints(snapPoints)
	-- log(JSON.encode_pretty(snapPoints))
end

function OU.FindContainedObjGUID(container, findFunc)
	U.Val("OU.FindContainedObjGUID", container, U.isGameObject(container), "'container' param is not a Game Object")
	U.Val("OU.FindContainedObjGUID", findFunc, U.Type(findFunc) == "function", "'findFunc' param is not a Function")
	local objData = U.find(container.getObjects(), findFunc)
	if objData == nil then return false end
	return objData.guid
end

return OU
end)
__bundle_register("kingsdilemma.lib.objects", function(require, _LOADED, __bundle_register, __bundle_modules)
-- local U = require("lib.utilities")

local O = {}

ObjTable = {}

local function memoGetFromGUID(guid)
	if ObjTable[guid] == nil then
		ObjTable[guid] = getObjectFromGUID(guid)
	end
	return ObjTable[guid]
end

local function generateGetterFunction(guid)
	return function() return memoGetFromGUID(guid) end
end

O.SecretContainers = {
	Envelopes = generateGetterFunction("e8b898"),
	Stickers = generateGetterFunction("531d8d"),
	MysteryStickers = generateGetterFunction("9c9b72")
}

O.UninteractableObjs = {
	Table = generateGetterFunction("9909b3"),
	Scales = generateGetterFunction("39b7dd"),
	Lectern = generateGetterFunction("6cc1dc"),
	Board = generateGetterFunction("ade6bc"),
	DilemmaPlinth = generateGetterFunction("0e036e"),
	StagingPlinth = generateGetterFunction("fed994")
}

O.Maps = {
	MapAnkist = generateGetterFunction("ec2fcc"),
	MapWorld = generateGetterFunction("378389")
}

O.MainStorage = generateGetterFunction("138cbd")

O.SpawnSources = {
	chronicleCard = generateGetterFunction("10939d"),
	screenFlapLeft = generateGetterFunction("d5842d"),
	screenCenter = generateGetterFunction("1b818a"),
	screenFlapRight = generateGetterFunction("dd1534"),
	ayeCard = generateGetterFunction("437238"),
	passCard = generateGetterFunction("d6e934"),
	nayCard = generateGetterFunction("f0eb64"),
	lightBehind = generateGetterFunction("05b53a"),
	lightFront = generateGetterFunction("05b53a"),
	lightVote = generateGetterFunction("05b53a"),
	lightDilemmaRef = generateGetterFunction("05b53a"),
	plinthBase = generateGetterFunction("daa9ef"),
	plinthRiser = generateGetterFunction("8f0ce1"),
	zonePrivateAye = generateGetterFunction("065175"),
	zonePrivateNay = generateGetterFunction("aab38f"),
	zonePublic = generateGetterFunction("9100f3"),
	zonePrivatePower = generateGetterFunction("5c34ee"),
	zonePrivateCoin = generateGetterFunction("f02cb1"),
	zoneHiderHouseCard = generateGetterFunction("12e119"),
	zoneHiderGeneral = generateGetterFunction("0a34f7"),
	stabilityToken = generateGetterFunction("e19593"),
	influenceToken = generateGetterFunction("29b725"),
	wealthToken = generateGetterFunction("c717a0"),
	moraleToken = generateGetterFunction("0f25a8"),
	welfareToken = generateGetterFunction("1ce1ca"),
	knowledgeToken = generateGetterFunction("2071f2"),
	powerToken1 = generateGetterFunction("0c9837"),
	powerToken5 = generateGetterFunction("805e3a"),
	powerToken10 = generateGetterFunction("b7fbd2"),
	coinToken1 = generateGetterFunction("be3cd3"),
	coinToken5 = generateGetterFunction("5dce57"),
}

-- lua getObjectFromGUID("05b53a").getChildren()[1].getChildren()[2].getComponents()[2].set("intensity", 0)
-- lua getObjectFromGUID("9bfae4").getChildren()[1].getChildren()[2].getComponents()[2].set("intensity", 0)
-- lua getObjectFromGUID("65fb31").getChildren()[1].getChildren()[2].getComponents()[2].set("intensity", 0)
-- lua log(getObjectFromGUID("05b53a").getTags()); log(getObjectFromGUID("9bfae4").getTags()); log(getObjectFromGUID("65fb31").getTags())

O.Leader = {
	Figure = generateGetterFunction("215a29"),
	Light = generateGetterFunction("6f9e66")
}

O.Moderator = {
	Figure = generateGetterFunction("078ee2"),
	Light = generateGetterFunction("6a99d8")
}

O.Lights = {
	MainBoardTop = generateGetterFunction("79ba9e"),
	MainBoardBottom = generateGetterFunction("746f68"),
	Debug = generateGetterFunction("a4527e")
}

O.Pieces = {
	CoverCard = generateGetterFunction("533718"),
	StabilityToken = generateGetterFunction("e19593"),
	InfluenceToken = generateGetterFunction("29b725"),
	WealthToken = generateGetterFunction("c717a0"),
	MoraleToken = generateGetterFunction("0f25a8"),
	WelfareToken = generateGetterFunction("1ce1ca"),
	KnowledgeToken = generateGetterFunction("2071f2"),
	BalancePlinth = generateGetterFunction("555cdb")
}

O.Zones = {
	TriggerCards = generateGetterFunction("79c7ed")
}

O.Get = memoGetFromGUID

return O
end)
__bundle_register("kingsdilemma.lib.constants", function(require, _LOADED, __bundle_register, __bundle_modules)
local U = require("lib.utilities")

local C = {}

C.SeatAngleSpan = 240

C.TableRadius = 57

C.TableHeight = 1.46 -- toCheck: lua log(tbl.getBounds().center:add(tbl.getBounds().offset):add(tbl.getBounds().size))
C.BoardHeight = 1.92

C.BaseHandTransform = {
	position = Vector(0, 3, C.TableRadius),
	rotation = Vector(0, 180, 0),
	scale = Vector(12, 5, 4)
}

C.AdminID = "76561198002132577"

C.SeatColors = {"Brown", "Red", "Orange", "Yellow", "Green"}

C.Houses = {"Allwed", "Blodyn", "Coden", "Crann", "Dualak", "Gamam", "Natar", "Olwyn", "Solad", "Tiryll", "Tork", "Wylio"}
C.HousePrefixes = {
	Allwed = "the Mark of",
	Blodyn = "the Duchy of",
	Coden = "the Duchy of",
	Crann = "the Mark of",
	Dualak = "the Mark of",
	Gamam = "the Duchy of",
	Natar = "the Duchy of",
	Olwyn = "the Duchy of",
	Solad = "the Duchy of",
	Tiryll = "the Mark of",
	Tork = "the Mark of",
	Wylio = "the Mark of"
}

C.Resources = {"Influence", "Wealth", "Morale", "Welfare", "Knowledge"}
C.SecretAgendas = {"Extremist", "Greedy", "Moderate", "Opportunist", "Opulent", "Rebel"}
C.SecretAgendaData = {
	Extremist = {
		-- if resPoints is missing, function assumed to return actual score
		resFunc = function(_, allData)
			local min, max = 20, 0
			for _, spot in pairs(allData) do
				if spot < min then min = spot end
				if spot > max then max = spot end
			end
			return max - min
		end,
		coinPoints = {4, 2, 1}
	},
	Greedy = {
		resFunc = function(resSpot)
			return resSpot >= 13 or resSpot <= 5
		end,
		resPoints = {4, 7, 11, 7, 4, 0},
		coinPoints = {8, 6, 4}
	},
	Moderate = {
		resFunc = function(resSpot) return resSpot <= 13 and resSpot >= 5 end,
		resPoints = {0, 6, 7, 10, 13, 14},
		coinPoints = {5, 3, 1}
	},
	Opportunist = {
		resFunc = function(resSpot) return resSpot <= 9 end,
		resPoints = {0, 4, 7, 10, 14, 15},
		coinPoints = {6, 4, 2}
	},
	Opulent = {
		resFunc = function(resSpot) return resSpot >= 9 end,
		resPoints = {0, 4, 7, 10, 14, 15},
		coinPoints = {6, 4, 2}
	},
	Rebel = { -- *** WILL HAVE TO HANDLE THE CHECK FOR EXTRA CRAVE MANUALLY
		resFunc = function(resSpot) return resSpot >= 13 or resSpot <= 5 end,
		resPoints = {0, 9, 13, 17, 19, 20},
		coinPoints = {3, 2, 1}
	}
}
C.FinalScoring = {
	Death = {
		{prestige = 5, crave = 0},
		{prestige = 4, crave = 0},
		{prestige = 2, crave = 1},
		{prestige = 2, crave = 1},
		{prestige = 0, crave = 2}
	},
	AbdicatedTop = {
		{prestige = 3, crave = 0},
		{prestige = 2, crave = 0},
		{prestige = 1, crave = 0},
		{prestige = 1, crave = 0},
		{prestige = 0, crave = 2}
	},
	AbdicatedBottom = {
		{prestige = 0, crave = 3},
		{prestige = 0, crave = 2},
		{prestige = 0, crave = 1},
		{prestige = 0, crave = 1},
		{prestige = 2, crave = 0}
	}
}
C.Modes = {
	NONE = "NONE",
	SESSIONINIT = "SESSIONINIT",
	CHRONSETUP = "CHRONSETUP",
	GAMESETUP = "GAMESETUP",
	PLAY = "PLAY",
	END = "END"
}

C.Phases = {
	NONE = "NONE",
	SESSIONINIT = {
		SeatPlayers = "SeatPlayers",
		HouseSelection = "HouseSelection"
	},
	CHRONSETUP = "CHRONSETUP",
	GAMESETUP = {
		InitializeState = "InitializeState",
		MainBoard = "MainBoard",
		LeaderModerator = "LeaderModerator",
		LegacySetup = "LegacySetup",
		SecretAgendas = "SecretAgendas"
	},
	PLAY = {
		StartRound = "StartRound",
		DrawDilemma = "DrawDilemma",
		Vote = "Vote",
		VoteResolution = "VoteResolution",
		DisplayOutcome = "DisplayOutcome",
		ApplyChanges = "ApplyChanges",
		ApplyMomentum = "ApplyMomentum",
		StickerCheck = "StickerCheck",
		EnvelopeCheck = "EnvelopeCheck",
		EndRound = "EndRound"
	},
	END = {
		Score = "Score",
		Realm = "Realm",
		Achievements = "Achievements",
		Alignments = "Alignments",
		Cleanup = "Cleanup",
		SecretAgendas = "SecretAgendas",
		SignOff = "SignOff"
	}
}

C.CameraAngles = {
	BehindScreen = {
		isPlayerAngle = true,
		position = Vector({0,-14.25,1.5}),
		pitch = 30.7,
		yaw = 180,
		distance = 75
	},
	Lectern = { -- lua Player.Brown.lookAt({position =  Vector({0,6.25,24}), pitch = 12.67, yaw = 0, distance = 25})
		position = Vector({0,6.25,24}),
		pitch = 12.67,
		yaw = 0,
		distance = 25
	},
	DilemmaPlinth = { -- lua Player.Brown.lookAt({position = Vector({0,-6.2,58.25}), pitch = 14.34, yaw = 0, distance = 75})
		position = Vector({0,-6.2,58.25}),
		pitch = 14.34,
		yaw = 0,
		distance = 75
	},
	DilemmaDraw = { -- lua Player.Brown.lookAt({position = Vector({0,13.11,30.15}), pitch = 1.51, yaw = 0, distance = 75})
		position = Vector({0,13.11,30.15}),
		pitch = 1.51,
		yaw = 0,
		distance = 75
	},
	DilemmaResult = { -- lua Player.Brown.lookAt({position = Vector({0,0,40}), pitch = 14.34, yaw = 0, distance = 75})
		position = Vector({0,0,40}),
		pitch = 14.34,
		yaw = 0,
		distance = 75
	},
	Stickers = { -- lua Player.Brown.lookAt({position = Vector({0,-6.2,27}), pitch = 45.34, yaw = 0, distance = 35})
		position = Vector({0,-6.2,27}),
		pitch = 45.34,
		yaw = 0,
		distance = 35
	},
	Resources = { -- lua Player.Brown.lookAt({position = Vector({0,-14.25,3.5}), pitch = 60, yaw = 0, distance = 40})
		position = Vector({0,-14.25,3.5}),
		pitch = 60,
		yaw = 0,
		distance = 40
	},
	MainBoard = { -- lua Player.Brown.lookAt({position = Vector({0,-14.25,7.7}), pitch = 50.67, yaw = 0, distance = 60})
		position = Vector({0,-14.25,7.7}),
		pitch = 50.67,
		yaw = 0,
		distance = 60
	}, --
	StorySign = { -- lua Player.Orange.lookAt({position = Vector({0, -7.2, 14.52}), pitch = 90, yaw = 0, distance = 11.5})
		position = Vector({0, -7.2, 14.52}),
		pitch = 90,
		yaw = 0,
		distance = 11.5
	},
	StickerSign = { -- lua Player.Orange.lookAt({position = Vector({0,-6.2,25}), pitch = 90, yaw = 0, distance = 13})
		position = Vector({0, -6.2, 25}),
		pitch = 90,
		yaw = 0,
		distance = 13
	},
	ScreenCapture = { -- lua Player.Orange.lookAt({pitch=90, yaw=0, distance=15.5, position = Vector({70,0,0})}); Player.Orange.setCameraMode("TopDown")
		cameraMode = "TopDown",
		position = Vector({70, 0, 0}),
		pitch = 90,
		yaw = 0,
		distance = 15.5
	},
	ScreenCaptureZoom = { -- lua Player.Orange.lookAt({pitch=90, yaw=0, distance=15.5, position = Vector({70,0,0})}); Player.Orange.setCameraMode("TopDown")
		cameraMode = "TopDown",
		position = Vector({70, 0, 0}),
		pitch = 90,
		yaw = 0,
		distance = 5.2
	}
	-- STORY CARD SCREENSHOT POSITIONS FOR ENDGAME
	-- spread story cards out with x-values: 9.16, 12.66, 16.16, 19.66
	-- STORY 1 - lua Player.Brown.lookAt({position = Vector({13.75, -7, 19}), pitch = 90, yaw = 0, distance = 17})
	-- STORY 2 - lua Player.Brown.lookAt({position = Vector({13.75, -7, 12.81}), pitch = 90, yaw = 0, distance = 17})
	-- STORY 3 - lua Player.Brown.lookAt({position = Vector({13.75, -7, 6.61}), pitch = 90, yaw = 0, distance = 17})
	-- STORY 4 - lua Player.Brown.lookAt({position = Vector({13.75, -7, 0.41}), pitch = 90, yaw = 0, distance = 17})
	-- STORY 5 - lua Player.Brown.lookAt({position = Vector({13.75, -7, -5.78}), pitch = 90, yaw = 0, distance = 17})
	-- STORY 6 - lua Player.Brown.lookAt({position = Vector({13.75, -7, -11.98}), pitch = 90, yaw = 0, distance = 17})
	-- STIKCKERS - lua Player.Brown.lookAt({position = Vector({-2.5,-6.2,16.5}), pitch = 90, yaw = 0, distance = 19})
}

C.CaptureCoords = {
	cameraPos = Vector(C.CameraAngles.ScreenCapture.position),
	columnXShift = 3.55,
	stackYShift = 0.05,
	rowZShift = -4.9,
	cameraZoneZShift = -16,
	Dilemma = {
		numColumns = 6,
		startXDelta = -8.67,
		startZDelta = 4.43,
		fullZShift = -4.92,
		halfZShift = -2.42,
		backRotation = Vector(0, 180, 0),
		frontRotationAye = Vector(0, 180, 180),
		frontRotationNay = Vector(0, 0, 180),
		scale = Vector(1.59, 1, 1.59)
	},
	Story = {
		startXDelta = -5.005,
		startZDelta = 2.14,
		backRotation = Vector(0, 180, 0),
		frontRotation = Vector(0, 180, 180),
		scale = Vector(1.59, 1, 1.59)
	},
	Zoom = {
		startXDelta = -1.41,
		startZDelta = -0.1,
		scale = Vector(1.59, 1, 1.59)
	}
}

C.SnapPoints = {
	Global = {
		{
			position = Vector({9.15, 1.46, 19.00}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = true,
			tags = {"StoryCard"}
		},
		{
			position = Vector({9.15, 1.46, 12.81}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = true,
			tags = {"StoryCard"}
		},
		{
			position = Vector({9.15, 1.46, 6.61}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = true,
			tags = {"StoryCard"}
		},
		{
			position = Vector({9.15, 1.46, 0.41}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = true,
			tags = {"StoryCard"}
		},
		{
			position = Vector({9.15, 1.46, -5.78}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = true,
			tags = {"StoryCard"}
		},
		{
			position = Vector({9.15, 1.46, -11.98}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = true,
			tags = {"StoryCard"}
		}, -- 9.16, 12.66, 16.16, 19.66
		{
			position = Vector({9.15, 1.46, -18.17}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = false,
			tags = {"EventCard", "StoryCard", "TriggerCard"}
		},
		{
			position = Vector({12.65, 1.46, -18.17}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = false,
			tags = {"EventCard", "StoryCard", "TriggerCard"}
		},
		{
			position = Vector({16.15, 1.46, -18.17}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = false,
			tags = {"EventCard", "StoryCard", "TriggerCard"}
		},
		{
			position = Vector({19.66, 1.46, -18.17}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = false,
			tags = {"EventCard", "StoryCard", "TriggerCard"}
		},
		{
			position = Vector({9.95, 1.46, -23.19}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = false,
			tags = {"EventCard", "StoryCard", "TriggerCard"}
		},
		{
			position = Vector({13.45, 1.46, -23.19}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = false,
			tags = {"EventCard", "StoryCard", "TriggerCard"}
		},
		{
			position = Vector({16.95, 1.46, -23.19}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = false,
			tags = {"EventCard", "StoryCard", "TriggerCard"}
		},
		{
			position = Vector({10.46, 1.46, -23.19}),
			rotation = Vector({0, 180, 0}),
			rotation_snap = false,
			tags = {"EventCard", "StoryCard", "TriggerCard"}
		},
		{
			position = Vector({-7.4, 1.46, 8.05}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, 3.63}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -0.80}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -5.23}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -9.65}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -14.08}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -14.08}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -18.50}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -18.74}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -18.99}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -19.23}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		},
		{
			position = Vector({-7.4, 1.46, -19.47}),
			rotation = Vector({0, 270, 0}),
			rotation_snap = false,
			tags = {"Dilemma"}
		}
	}
}

C.Spots = {
	Storage = {
		HouseCard = {
			position = Vector({104.00, 29.25, -2.25}),
			rotation = Vector({71.10, 180.00, 180.00}),
			scale = Vector({0.30, 1.00, 0.30})
		},
		Envelopes = {
			position = Vector({3.67, 7.25, 48.00}),
			rotation = Vector({320.42, 0.00, 0.00}),
			scale = Vector({0.19, 0.07, 0.10})
		},
		Stickers = {
			position = Vector({-3.67, 7.25, 48.00}),
			rotation = Vector({320.42, 0.00, 0.00}),
			scale = Vector({0.19, 0.07, 0.10})
		},
		MysteryEnvelopes = {
			position = Vector({0.00, 8.05, 50.27}),
			rotation = Vector({0.00, 90.00, 320.42}),
			scale = Vector({1.15, 0.23, 6.30})
		},
		LeaderLight = {
			position = Vector({-7.78, 15.62, 35.10}),
			rotation = Vector({0, 180, 0}),
			scale = Vector({1, 1, 1})
		},
		LeaderFigure = {
			position = Vector({-7.78, 5.51, 35.08}),
			rotation = Vector({359.77, 359.86, 0.05}),
			scale = Vector({1, 1, 1})
		},
		ModeratorLight = {
			position = Vector({7.78, 15.68, 35.10}),
			rotation = Vector({0, 180, 0}),
			scale = Vector({1, 1, 1})
		},
		ModeratorFigure = {
			position = Vector({7.78, 1.39, 35.10}),
			rotation = Vector({0.00, 219.63, 0.00}),
			scale = Vector({0.3, 0.3, 0.3})
		},
		SecretAgenda = {
			position = Vector({0.00, 1.50, 33.79}),
			rotation = Vector({0, 270, 180})
		}
	},
	Staging = {
		Lectern = {
			Envelopes = {
				position = Vector({0.00, 12.00, 45.50}),
				rotation = Vector({285.00, 0.00, 0.00}),
				scale = Vector({0.19, 0.07, 0.10})
			},
			Stickers = {
				position = Vector({0.00, 12.00, 45.50}),
				rotation = Vector({285.00, 0.00, 0.00}),
				scale = Vector({0.19, 0.07, 0.10})
			},
			MysteryEnvelopes = {
				position = Vector({0.00, 15.03, 50.28}),
				rotation = Vector({0.00, 90.00, 270.00}),
				scale = Vector({1.15, 0.23, 6.30})
			},
			Display = {
				position = Vector({0.00, 12.00, 42.00}),
				rotation = Vector({62.95, 179.98, 0.00}),
				scale = Vector({1.59, 1.00, 1.59})
			},
			TopCard = {
				position = Vector({0.00, 13.22, 40.62}),
				rotation = Vector({62.95, 180.00, 0.00}),
				scale = Vector({1.59, 1.00, 1.59})
			},
			RestOfDeck = {
				position = Vector({0.00, 9.32, 41.94}),
				rotation = Vector({0.00, 90.00, 0.00}),
				scale = Vector({1.59, 1.00, 1.59})
			}
		},
		StoryCard = {
			Display = {
				position = Vector({0, 1.94, 16.52}),
				rotation = Vector({0, 180, 0}),
				scale = Vector({1.59, 1.00, 1.59})
			}
		},
		Sticker = {
			Display = {
				position = Vector({0.00, 3.81, 26.00}),
				rotation = Vector({0.00, 180.00, 0.00}),
				scale = Vector({1, 1, 1})
			}
		},
		SecretAgenda = {
			High = {
				position = Vector({0.00, 15.00, 26.00}),
				rotation = Vector({0.00, 180, 180.00})
			},
			Low = {
				position = Vector({0.00, 5.37, 25.04}),
				rotation = Vector({18, 180, 180.00})
			},
			Burnt = {
				position = Vector({0.00, 2.27, 52.08}),
				rotation = Vector(90, 500, 500)
			}
		},
		DilemmaDraw = {
			position = Vector({0.00, 7.05, 24.61}),
			rotation = Vector({25.36, 180, 0})
		}
	},
	Main = {
		CoverCard = {
			Closed = {
				position = Vector({0.00, 6, 26.00}),
				rotation = Vector({0.00, 270, 0.00}),
				scale = Vector({2.55, 1.00, 2.57})
			},
			Open = {
				position = Vector({0.00, 6.67, 23}),
				rotation = Vector({0, 270, 290}),
				scale = Vector({2.55, 1.00, 2.57})
			}
		},
		ChronicleCard = {
			position = Vector({0.00, 3.93, 37.12}),
			rotation = Vector({78.09, 180.00, 0.00}),
			scale = Vector({2.60, 1.00, 2.60})
		},
		Event = {
			board = U.iMap(
				U.filter(C.SnapPoints.Global, function(sPt) return U.isIn("EventCard", sPt.tags) end),
				function(sPt) return {
					position = Vector(sPt.position):setAt("y", 4),
					rotation = Vector({0, 180, 0}),
					scale = Vector(1.59, 1, 1.59)
				}
			end)
		},
		Trigger = {
			aboveDeck = {}, -- = Dilemma.aboveDeck
			faceDown = {}, -- = Dilemma.faceDown
			faceUp = {
				position = Vector({0.00, 28.51, 43.94}),
				rotation = Vector(90, 0, 0),
				scale = Vector(10, 1, 10)
			},
			faceUpShrink = {
				position = Vector({0.00, 0.00, 39.30}),
				rotation = Vector({270, 180, 0}),
				scale = Vector({5, 1, 5})
			}
		},
		Dilemma = {
			deck = {
				position = Vector({0.00, 6, 26.00}),
				rotation = Vector({0.00, 90.00, 0.00}),
				scale = Vector({1.59, 1.00, 1.59})
			},
			aboveDeck = {
				position = Vector({0.00, 6, 26.00}),
				rotation = Vector({0.00, 180.00, 0.00}),
				scale = Vector({1.59, 1.00, 1.59})
			},
			faceDown = {
				position = Vector({0.00, 28.51, 43.94}),
				rotation = Vector(90, 180, 0),
				scale = Vector(10, 1, 10)
			},
			faceUpAye = {
				position = Vector({0, -1.56, 39.30}), -- 0.81
				rotation = Vector({90, 0, 0}),
				scale = Vector({10, 1.00, 10})
			},
			faceUpAyeResolve = {
				position = Vector({0, 0.81, 39.30}), -- 0.81
				rotation = Vector({90, 0, 0}),
				scale = Vector({10, 1.00, 10})
			},
			faceUpNay = {
				position = Vector({0.00, -1.13, 39.30}), -- 1.57
				rotation = Vector({270, 180, 0}),
				scale = Vector({10, 1.00, 10})
			},
			faceUpNayResolve = {
				position = Vector({0.00, 1.57, 39.30}), -- 1.57
				rotation = Vector({270, 180, 0}),
				scale = Vector({10, 1.00, 10})
			},
			faceUpAyeShrink = {
				position = Vector({0.00, 1.18, 39.30}),
				rotation = Vector({270, 180, 0}),
				scale = Vector({5, 1, 5})
			},
			faceUpNayShrink = {
				position = Vector({0.00, 1.5, 39.30}),
				rotation = Vector({270, 180, 0}),
				scale = Vector({5, 1.00, 5})
			},
			boardAye = U.iMap(
				U.filter(C.SnapPoints.Global, function(sPt) return U.isIn("Dilemma", sPt.tags) end),
				function(sPt) return {
					position = Vector(sPt.position):setAt("y", 4),
					rotation = Vector({0, 90, 180}),
					scale = Vector(1.59, 1, 1.59)
				}
			end),
			boardNay = U.iMap(
				U.filter(C.SnapPoints.Global, function(sPt) return U.isIn("Dilemma", sPt.tags) end),
				function(sPt) return {
					position = Vector(sPt.position):setAt("y", 4),
					rotation = Vector({0, 270, 180}),
					scale = Vector(1.59, 1, 1.59)
				}
			end),
			oldBoardAye = {
				{
					position = Vector({-7.4, 4, 8.05}),
					rotation = Vector({0, 90, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, 3.63}),
					rotation = Vector({0, 90, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, -0.80}),
					rotation = Vector({0, 90, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, -5.23}),
					rotation = Vector({0, 90, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, -9.65}),
					rotation = Vector({0, 90, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, -14.08}),
					rotation = Vector({0, 90, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, -18.50}),
					rotation = Vector({0, 90, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, -18.74}),
					rotation = Vector({0, 90, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, -18.99}),
					rotation = Vector({0, 90, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, -19.23}),
					rotation = Vector({0, 90, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, -19.47}),
					rotation = Vector({0, 90, 180}),
					scale = Vector({1.59, 1, 1.59})
				}
			},
			oldBoardNay = {
				{
					position = Vector({-7.4, 4, 8.05}),
					rotation = Vector({0, 270, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, 3.63}),
					rotation = Vector({0, 270, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, -0.80}),
					rotation = Vector({0, 270, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, -5.23}),
					rotation = Vector({0, 270, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, -9.65}),
					rotation = Vector({0, 270, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, -14.08}),
					rotation = Vector({0, 270, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, -18.50}),
					rotation = Vector({0, 270, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, -18.74}),
					rotation = Vector({0, 270, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, -18.99}),
					rotation = Vector({0, 270, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, -19.23}),
					rotation = Vector({0, 270, 180}),
					scale = Vector({1.59, 1, 1.59})
				},
				{
					position = Vector({-7.4, 4, -19.47}),
					rotation = Vector({0, 270, 180}),
					scale = Vector({1.59, 1, 1.59})
				}
			}
		}
	},
	Board = {
		StabilityToken = {
			top = {
				position = Vector({-4.83, C.BoardHeight, 9.43}),
				rotation = Vector({0, 180, 0}),
				scale = Vector({0.6, 1, 0.6})
			},
			center = {
				position = Vector({-4.83, C.BoardHeight, -3.35}),
				rotation = Vector({0, 180, 0}),
				scale = Vector({0.6, 1, 0.6})
			},
			bottom = {
				position = Vector({-4.83, C.BoardHeight, -15.91}),
				rotation = Vector({0, 180, 0}),
				scale = Vector({0.6, 1, 0.6})
			}
		},
		ResourceTokens = {
			Influence = {
				top = {
					position = Vector({-2.71, C.BoardHeight, 8.04}),
					rotation = Vector({0, 180, 0}),
					scale = Vector({0.6, 1, 0.6})
				},
				center = {
					position = Vector({-2.71, C.BoardHeight, -3.18}),
					rotation = Vector({0, 180, 0}),
					scale = Vector({0.6, 1, 0.6})
				},
				bottom = {
					position = Vector({-2.71, C.BoardHeight, -14.42}),
					rotation = Vector({0, 180, 0}),
					scale = Vector({0.6, 1, 0.6})
				}
			},
			Wealth = {
				top = {
					position = Vector({-1.38, C.BoardHeight, 8.04}),
					rotation = Vector({0, 180, 0}),
					scale = Vector({0.6, 1, 0.6})
				},
				center = {
					position = Vector({-1.38, C.BoardHeight, -3.20}),
					rotation = Vector({0, 180, 0}),
					scale = Vector({0.6, 1, 0.6})
				},
				bottom = {
					position = Vector({-1.38, C.BoardHeight, -14.42}),
					rotation = Vector({0, 180, 0}),
					scale = Vector({0.6, 1, 0.6})
				}
			},
			Morale = {
				top = {
					position = Vector({-0.02, C.BoardHeight, 8.04}),
					rotation = Vector({0, 180, 0}),
					scale = Vector({0.6, 1, 0.6})
				},
				center = {
					position = Vector({-0.02, C.BoardHeight, -3.22}),
					rotation = Vector({0, 180, 0}),
					scale = Vector({0.6, 1, 0.6})
				},
				bottom = {
					position = Vector({-0.02, C.BoardHeight, -14.42}),
					rotation = Vector({0, 180, 0}),
					scale = Vector({0.6, 1, 0.6})
				}
			},
			Welfare = {
				top = {
					position = Vector({1.33, C.BoardHeight, 8.04}),
					rotation = Vector({0, 180, 0}),
					scale = Vector({0.6, 1, 0.6})
				},
				center = {
					position = Vector({1.33, C.BoardHeight, -3.20}),
					rotation = Vector({0, 180, 0}),
					scale = Vector({0.6, 1, 0.6})
				},
				bottom = {
					position = Vector({1.33, C.BoardHeight, -14.42}),
					rotation = Vector({0, 180, 0}),
					scale = Vector({0.6, 1, 0.6})
				}
			},
			Knowledge = {
				top = {
					position = Vector({2.69, C.BoardHeight, 8.04}),
					rotation = Vector({0, 180, 0}),
					scale = Vector({0.6, 1, 0.6})
				},
				center = {
					position = Vector({2.69, C.BoardHeight, -3.18}),
					rotation = Vector({0, 180, 0}),
					scale = Vector({0.6, 1, 0.6})
				},
				bottom = {
					position = Vector({2.69, C.BoardHeight, -14.42}),
					rotation = Vector({0, 180, 0}),
					scale = Vector({0.6, 1, 0.6})
				}
			}
		},
		ChronicleStickers = {
			top = {
				position = Vector({4, C.BoardHeight, 20.55}),
				rotation = Vector({0, 180, 0}),
				scale = Vector({1,1,1})
			},
			center = {
				position = Vector({4, C.BoardHeight, 16.05}),
				rotation = Vector({0, 180, 0}),
				scale = Vector({1,1,1})
			},
			bottom = {
				position = Vector({-4, C.BoardHeight, 11.55}),
				rotation = Vector({0, 180, 0}),
				scale = Vector({1,1,1})
			}
		},
		BalancePlinth = {
			up = {
				position = Vector({0, 3, -19.17}),
				rotation = Vector({0, 0, 0}),
				scale = Vector({0.33, 0.54, 0.33})
			},
			down = {
				position = Vector({0, 1.75, -19.17}),
				rotation = Vector(0, 0, 0)
			}
		}
	},
	Player = {
		Power = {
			position = Vector({8, 2, 48}),
			rotation = Vector({0, 0, 0})
		},
		Coin = {
			position = Vector({-8, 2, 48}),
			rotation = Vector({0, 250, 0})
		},
		SecretAgenda = {
			position = Vector({10.00, 7.00, 42.50}),
			rotation = Vector({87.76, 0.00, 45.00})
		},
		DilemmaSpot = {
			position = Vector({0.00, 8.27, 41.30}),
			rotation = Vector({83.90, 0, 0}),
			scale = Vector({2, 1.00, 2})
		}
	}
}

C.Decals = {
	BlackBox = {
		name = "z Black Box",
		url = "http://cloud-3.steamusercontent.com/ugc/2065507029337283063/B7141B38D24D9CA328392F9032080B5B543E2787/",
		rotation = Vector(90, 180, 0),
		scale = Vector(0.17, 0.17, 0.17)
	}
}

C.ObjectSpots = {
	ChronicleSticker = {
		Vector(1.695, 0.125, -0.247),
		Vector(1.695, 0.125, 0.062),
		Vector(1.695, 0.125, 0.356)
	}
}

C.Spots.Main.Trigger.aboveDeck = C.Spots.Main.Dilemma.aboveDeck
C.Spots.Main.Trigger.faceDown =  C.Spots.Main.Dilemma.faceDown

C.RootColors = {
	Amber = Color(1, 0.67, 0, 1),
	PureBlack = Color(0, 0, 0, 1),
	PureRed = Color(1, 0, 0, 1),
	PureBlue = Color(0, 0, 1, 1)
}

C.Colors = {
	StabilityToken = {
		center = Color.White,
		half = Color(C.RootColors.Amber),
		ends = Color(C.RootColors.PureRed)
	}
}

C.scanData = {
	Blodyn = {
		globalOffsets = {gx = 0.002, gy = 0.02},
		textWidth = 3400,
		nameOffsets = {dx = -0.16, dy = -0.8},
		prestigeGap = 0.062,
		agendaGap = 0.78,
		achievementButtons = {
			offsets = {dx = 1.31, dy = -0.64, zStart = 0.13},
			blocks = {
				{num = 4, zFix = 0.45, zScale = 0.065},
				{num = 2, zFix = 0.94, zScale = 0.065},
				{num = 2, zFix = 1.25, zScale = 0.065}
			}
		}
	},
	Coden = {
		globalOffsets = {gx = 0, gy = 0},
		textWidth = 3400,
		nameOffsets = {dx = -0.16, dy = -0.8},
		prestigeGap = 0.062,
		agendaGap = 0.78,
		achievementButtons = {
			offsets = {dx = 1.31, dy = -0.64, zStart = 0.13},
			blocks = {
				{num = 2, zFix = 0.445, zScale = 0.065},
				{num = 3, zFix = 0.785, zScale = 0.065},
				{num = 2, zFix = 1.18, zScale = 0.065}
			}
		}
	},
	Gamam = {
		globalOffsets = {gx = 0, gy = 0.02},
		textWidth = 3400,
		nameOffsets = {dx = -0.16, dy = -0.8},
		prestigeGap = 0.062,
		agendaGap = 0.78,
		achievementButtons = {
			offsets = {dx = 1.3, dy = -0.64, zStart = 0.13},
			blocks = {
				{num = 2, zFix = 0.45, zScale = 0.065},
				{num = 3, zFix = 0.81, zScale = 0.065},
				{num = 3, zFix = 1.17, zScale = 0.065}
			}
		}
	},
	Natar = {
		globalOffsets = {gx = 0.004, gy = 0.01},
		textWidth = 3400,
		nameOffsets = {dx = -0.16, dy = -0.8},
		prestigeGap = 0.062,
		agendaGap = 0.78,
		achievementButtons = {
			offsets = {dx = 1.3, dy = -0.64, zStart = 0.13},
			blocks = {
				{num = 3, zFix = 0.43, zScale = 0.065},
				{num = 2, zFix = 0.84, zScale = 0.065},
				{num = 3, zFix = 1.1, zScale = 0.065}
			}
		}
	},
	Olwyn = {
		globalOffsets = {gx = 0.005, gy = 0},
		textWidth = 3400,
		nameOffsets = {dx = -0.16, dy = -0.8},
		prestigeGap = 0.062,
		agendaGap = 0.78,
		achievementButtons = {
			offsets = {dx = 1.3, dy = -0.64, zStart = 0.13},
			blocks = {
				{num = 2, zFix = 0.49, zScale = 0.065},
				{num = 2, zFix = 0.92, zScale = 0.065},
				{num = 3, zFix = 1.25, zScale = 0.065}
			}
		}
	},
	Solad = {
		globalOffsets = {gx = 0, gy = 0},
		textWidth = 3600,
		nameOffsets = {dx = -0.12, dy = -0.8},
		prestigeGap = 0.065,
		agendaGap = 0.79,
		achievementButtons = {
			offsets = {dx = 1.315, dy = -0.64, zStart = 0.14},
			blocks = {
				{num = 2, zFix = 0.44, zScale = 0.07},
				{num = 2, zFix = 0.79, zScale = 0.07},
				{num = 2, zFix = 1.12, zScale = 0.07}
			}
		}
	},
	Allwed = {
		globalOffsets = {gx = 0.001, gy = 0.01},
		textWidth = 3000,
		nameOffsets = {dx = -0.19, dy = -0.8},
		prestigeGap = 0.062,
		agendaGap = 0.78,
		achievementButtons = {
			offsets = {dx = 1.3, dy = -0.64, zStart = 0.13},
			blocks = {
				{num = 2, zFix = 0.45, zScale = 0.065},
				{num = 4, zFix = 0.86, zScale = 0.065},
				{num = 3, zFix = 1.33, zScale = 0.065}
			}
		}
	},
	Crann = {
		globalOffsets = {gx = 0.001, gy = 0.01},
		textWidth = 3000,
		nameOffsets = {dx = -0.19, dy = -0.8},
		prestigeGap = 0.062,
		agendaGap = 0.78,
		achievementButtons = {
			offsets = {dx = 1.305, dy = -0.64, zStart = 0.13},
			blocks = {
				{num = 2, zFix = 0.49, zScale = 0.065},
				{num = 2, zFix = 0.85, zScale = 0.065},
				{num = 3, zFix = 1.165, zScale = 0.065}
			}
		}
	},
	Dualak = {
		globalOffsets = {gx = 0.001, gy = 0.01},
		textWidth = 3000,
		nameOffsets = {dx = -0.19, dy = -0.8},
		prestigeGap = 0.062,
		agendaGap = 0.78,
		achievementButtons = {
			offsets = {dx = 1.302, dy = -0.64, zStart = 0.13},
			blocks = {
				{num = 3, zFix = 0.411, zScale = 0.065},
				{num = 2, zFix = 0.78, zScale = 0.065},
				{num = 2, zFix = 1.1, zScale = 0.065}
			}
		}
	},
	Tiryll = {
		globalOffsets = {gx = 0, gy = 0.01},
		textWidth = 3400,
		nameOffsets = {dx = -0.16, dy = -0.8},
		prestigeGap = 0.062,
		agendaGap = 0.78,
		achievementButtons = {
			offsets = {dx = 1.3, dy = -0.64, zStart = 0.14},
			blocks = {
				{num = 2, zFix = 0.46, zScale = 0.07},
				{num = 2, zFix = 0.83, zScale = 0.07},
				{num = 2, zFix = 1.15, zScale = 0.07}
			}
		}
	},
	Tork = {
		globalOffsets = {gx = 0.002, gy = 0},
		textWidth = 3400,
		nameOffsets = {dx = -0.16, dy = -0.8},
		prestigeGap = 0.062,
		agendaGap = 0.78,
		achievementButtons = {
			offsets = {dx = 1.3, dy = -0.64, zStart = 0.13},
			blocks = {
				{num = 2, zFix = 0.46, zScale = 0.065},
				{num = 2, zFix = 0.86, zScale = 0.065},
				{num = 3, zFix = 1.19, zScale = 0.065}
			}
		}
	},
	Wylio = {
		globalOffsets = {gx = 0, gy = 0.01},
		textWidth = 3200,
		nameOffsets = {dx = -0.18, dy = -0.8},
		prestigeGap = 0.062,
		agendaGap = 0.78,
		achievementButtons = {
			offsets = {dx = 1.305, dy = -0.64, zStart = 0.12},
			blocks = {
				{num = 3, zFix = 0.39, zScale = 0.065},
				{num = 2, zFix = 0.79, zScale = 0.07},
				{num = 3, zFix = 1.13, zScale = 0.065}
			}
		}
	}
}

C.Images = {
	Flags = {
		Base = {
			Allwed = "http://cloud-3.steamusercontent.com/ugc/2064377962739194792/C9B66702A87E6D1FDB5384B4F51A5D77D2634917/",
			Blodyn = "http://cloud-3.steamusercontent.com/ugc/2064377962739253245/C9DBFEEB59A7B71D0A27FF280334271818FB26A0/",
			Coden = "http://cloud-3.steamusercontent.com/ugc/2064377962739253338/EA28A27B464F7693CC133B4E2FE6015B8C5CF0E3/",
			Crann = "http://cloud-3.steamusercontent.com/ugc/2064377962739253435/EE7BDEC5F7E46AC930644FC7533079F6879F5433/",
			Dualak = "http://cloud-3.steamusercontent.com/ugc/2064377962739253510/A16DF1A670D95E1C866F918ACE227092DBE9352B/",
			Gamam = "http://cloud-3.steamusercontent.com/ugc/2064377962739253616/87E88E5AC38BDC76F98654E1C280AA0A6E510C4E/",
			Natar = "http://cloud-3.steamusercontent.com/ugc/2064377962739253752/97822A3B8F0A01116CE2B721BB52E25A4317C218/",
			Olwyn = "http://cloud-3.steamusercontent.com/ugc/2064377962739253853/BB38AE3D3F420C0FD61BF814FD7775D462016AC8/",
			Solad = "http://cloud-3.steamusercontent.com/ugc/2064377962739253975/092946C413889BB5FC5E0D3F65C4C5EE136396BE/",
			Tiryll = "http://cloud-3.steamusercontent.com/ugc/2064377962739254148/DAC3E6F35DA73048387F0A2DEA8432C802AF83E3/",
			Tork = "http://cloud-3.steamusercontent.com/ugc/2064377962739254244/C64C331492D2A1AE626A63DEDEEA15CA99F5AF7A/",
			Wylio = "http://cloud-3.steamusercontent.com/ugc/2064377962739254331/8FD06EFCCF997781E5823A58C8DC3C3776866DD5/"
		},
		Claimed = {
			Allwed = "http://cloud-3.steamusercontent.com/ugc/2064378834882481449/963A8B75C9B97BDFF3D39E9D2BA5A544938954E1/",
			Blodyn = "http://cloud-3.steamusercontent.com/ugc/2064378834882481603/9BE1EE4AEAA99E52AEA5EED6FD4A7036E16A4A17/",
			Coden = "http://cloud-3.steamusercontent.com/ugc/2064378834882481665/DA4FE160EBBB082B654F2092437D146CDDD345BE/",
			Crann = "http://cloud-3.steamusercontent.com/ugc/2064378834882481723/16D0A4A74E791F5B809BD9CBE163D82BBDD70411/",
			Dualak = "http://cloud-3.steamusercontent.com/ugc/2064378834882481782/135D0D733C7715712302D85A5934CDB4CA016C19/",
			Gamam = "http://cloud-3.steamusercontent.com/ugc/2064378834882481847/21F19D0E431C93E5BAA92BD55E171162C550DCAE/",
			Natar = "http://cloud-3.steamusercontent.com/ugc/2064378834882481904/BABC349974DA713FA78C507B6B87A239A758B140/",
			Olwyn = "http://cloud-3.steamusercontent.com/ugc/2064378834882481956/263331DCE7B4ADEE222632B4BDCFF69C0CBFF479/",
			Solad = "http://cloud-3.steamusercontent.com/ugc/2064378834882482018/DB4192485CD507073895CE07E0F82FD0BFB778FE/",
			Tiryll = "http://cloud-3.steamusercontent.com/ugc/2064378834882482078/1F0131767099772ED3A445CB829A625EA609045E/",
			Tork = "http://cloud-3.steamusercontent.com/ugc/2064378834882482152/FEFD89F47ED3313B7CDAD5DB233EA94C58A025D7/",
			Wylio = "http://cloud-3.steamusercontent.com/ugc/2064378834882482218/BA59D16ACA1FB4220686BDBB50BA10DF076D4C62/"
		},
		HoverText = {
			Allwed ="http://cloud-3.steamusercontent.com/ugc/2064377962739254406/9003D12A2F60763746F70FD85B030CB56926FA3E/",
			Blodyn ="http://cloud-3.steamusercontent.com/ugc/2064377962739254471/6AE191A3885504DDCD870F5C7468649C44CA96A1/",
			Coden ="http://cloud-3.steamusercontent.com/ugc/2064377962739254535/09B0A8D11B1AA84576627FB9BB4663E3D0C2C313/",
			Crann ="http://cloud-3.steamusercontent.com/ugc/2064377962739254636/5A255B7F1A880072A759FD565084B6ABFDB7432A/",
			Dualak ="http://cloud-3.steamusercontent.com/ugc/2064377962739254731/39B09C3173BD729B98D0EAFF571FAAEF780D4C96/",
			Gamam ="http://cloud-3.steamusercontent.com/ugc/2064377962739254820/69650201B8D22E1DA43BD7A09AA56832C1EA3474/",
			Natar ="http://cloud-3.steamusercontent.com/ugc/2064377962739254903/5AC6BFDDAA21F465CAB49A5DCD2D872F28820AB2/",
			Olwyn ="http://cloud-3.steamusercontent.com/ugc/2064377962739255012/F88D0A873C75A76D6146FFFF562727DA74C26ED7/",
			Solad ="http://cloud-3.steamusercontent.com/ugc/2064377962739255078/CC8293A11AA2ED6E94B47E8F256F65585CC38542/",
			Tiryll ="http://cloud-3.steamusercontent.com/ugc/2064377962739255138/93DB22680A4FE3D5FB849D7D3C5EAF5DA010748F/",
			Tork ="http://cloud-3.steamusercontent.com/ugc/2064377962739255202/BB341225C631E5CFEB280744941AC0EA4CAA321A/",
			Wylio ="http://cloud-3.steamusercontent.com/ugc/2064377962739255282/02152CB3502A02EEE60567CC01C6996416BBA4C7/"
		}
	}
}

return C
end)
__bundle_register("lib.utilities", function(require, _LOADED, __bundle_register, __bundle_modules)
local U = {}

function U.pFloat(num)
    if (num) then
        return math.ceil(num * 100) / 100
    else
        return 0
    end
end
function U.pAngle(num, interval)
  if not interval then interval = 45 end
  return math.floor((num / interval) + 0.5) * interval
end
function U.pRotation(rot, interval)
	return U.map(rot, function(rVal) return U.pAngle(rVal, interval) end)
end

function U.findAboveObject(obj, testFunc, params)
	-- params:  invert = true/false
	-- 					box = true/false (defaults to ray)
	--					far = true/false (default limits distance to 5)
	local guidTest
	if params == nil then params = {} end
	if testFunc == nil then testFunc = function() return true end end
	if U.Type(testFunc) == "userdata" then
		guidTest = testFunc.guid
		testFunc = function(testObj) return testObj.guid == guidTest end
	end

	local castParams = {}

	if params.invert == true then
		castParams.direction = {0, -1, 0}
	else
		castParams.direction = {0, 1, 0}
	end

	local objBounds = obj.getBounds()
	if params.box == true then
    objBounds.center.y = objBounds.center.y + (0.5 * objBounds.size.y) + 2.5
		if params.invert == true then
			objBounds.center.y = objBounds.center.y - 5
		end
    objBounds.size.y = 5

		castParams.type = 3
		castParams.size = objBounds.size

		if params.far ~= true then
			castParams.max_distance = 0
		end
	end

	castParams.origin = objBounds.center

	if UI.getAttribute("debugStatePanel", "active") == "True" then
		castParams.debug = true
	end

	local hitList = Physics.cast(castParams)
	if not hitList then return {} end

	return U.map(
		U.filter(hitList, function(hitData)
			return hitData ~= nil and hitData.hit_object ~= nil and hitData.hit_object.guid ~= obj.guid and testFunc(hitData.hit_object)
		end), function(hitData)
			return hitData.hit_object
		end
	)
end

function U.findBelowObject(obj, testFunc, params)
	if params == nil then params = {} end
	if params.invert == nil then params.invert = true end
	return U.findAboveObject(obj, testFunc, params)
end

function U.isObjectAbove(obj, testObj, params)
	return #U.findAboveObject(obj, testObj, params) > 0
end

function U.getScatterPosition(boundsOrPosOrObj, yShift, padPercentOrDiameter)
	if yShift == nil then yShift = 2 end
	if padPercentOrDiameter == nil then padPercentOrDiameter = 0 end
	local center, size
	if U.Type(boundsOrPosOrObj) == "userdata" then
		if boundsOrPosOrObj.type == "Scripting" then
			boundsOrPosOrObj = {
				center = boundsOrPosOrObj.getPosition(),
				size = boundsOrPosOrObj.getScale()
			}
		else
			boundsOrPosOrObj = boundsOrPosOrObj.getBounds()
		end
	end
	if U.Type(boundsOrPosOrObj) == "table" and boundsOrPosOrObj.center ~= nil and boundsOrPosOrObj.size ~= nil then
		center = Vector(boundsOrPosOrObj.center):add(Vector(0, yShift, 0))
		size = boundsOrPosOrObj.size
	elseif U.Type(boundsOrPosOrObj) == "table" and boundsOrPosOrObj.x ~= nil and boundsOrPosOrObj.y ~= nil and boundsOrPosOrObj.z ~= nil then
		center = Vector(boundsOrPosOrObj)
		size = Vector(padPercentOrDiameter * 2, 0, padPercentOrDiameter * 2)
		padPercentOrDiameter = 0
	else
		U.AlertGM("[U.scatterObjects] Error: Must provide a position, an object, or a table with 'center' and 'size'.")
		return
	end
	local spanX = size.x * (1 - padPercentOrDiameter)
	local spanZ = size.z * (1 - padPercentOrDiameter)
	local mins = Vector(
		center.x - 0.5 * spanX,
		center.y,
		center.z - 0.5 * spanZ
	)
	local maxs = Vector(
		center.x + 0.5 * spanX,
		center.y,
		center.z + 0.5 * spanZ
	)
	local scatterVector = Vector(
		U.randBetween(mins.x, maxs.x),
		center.y,
		U.randBetween(mins.z, maxs.z)
	)
	return scatterVector
end

local function checkSnapPoint(snapPoint, axis, coordsFilter)
    if (snapPoint and snapPoint.position) then
        if (axis and coordsFilter[axis]) then
            local snapPos = math.ceil(snapPoint.position[axis] * 10) / 10
            local testPos = math.ceil(coordsFilter[axis] * 10) / 10
            return snapPos == testPos
        end
        return true
    end
    return false
end

function U.getSnapPoints(board, coordsFilter, sortAxis)
    local snapPoints = {}
    for _, point in ipairs(board.getSnapPoints()) do
        local isValid = true
        if (coordsFilter) then
            for i, thisAxis in ipairs({"x", "y", "z"}) do
                isValid = isValid and checkSnapPoint(point, thisAxis, coordsFilter)
            end
        end
        if (isValid) then
            table.insert(snapPoints, point)
        end
    end

    if (sortAxis) then
        table.sort(snapPoints, function(a,b) return a.position[sortAxis] > b.position[sortAxis] end)
    end

    return snapPoints
end

function U.findSnapPoint(snapPoints, pos, fuzziness)
	local baseObj, snapObj
		if U.Type(snapPoints) == "userdata" and snapPoints.getSnapPoints ~= nil then
			baseObj = snapPoints
			snapPoints = U.map(baseObj.getSnapPoints(), function(snapData)
				snapData.position = baseObj.positionToWorld(snapData.position)
				return snapData
			end)
		end
		if U.Type(pos) == "userdata" and pos.getSnapPoints ~= nil then
			snapObj = pos
			pos = snapObj.getPosition()
		end
    fuzziness = fuzziness or 0.1
    for slot, snap in ipairs(snapPoints) do
        if (snap.position) then
          snap = snap.position
        end
        local xPos = U.pFloat(pos.x)
        local zPos = U.pFloat(pos.z)
        local xSnap = U.pFloat(snap.x)
        local zSnap = U.pFloat(snap.z)
        local isXOkay = false
        local isZOkay = false
        if (pos.x == nil) then
            isXOkay = true
        elseif (xPos >= (xSnap - fuzziness) and xPos <= (xSnap + fuzziness)) then
            isXOkay = true
        end
        if (pos.z == nil) then
            isZOkay = true
        elseif (zPos >= (zSnap - fuzziness) and zPos <= (zSnap + fuzziness)) then
            isZOkay = true
        end
        if (isXOkay and isZOkay) then
            return slot
        end
    end
end

function U.GetHex(color, newAlpha)
	U.Val("U.GetHex()", color, color ~= nil, "Color is nil!")
	if newAlpha ~= nil then
		color = Color(color):setAt("a", newAlpha)
	end
	return "#" .. color:toHex(true)
end

function U.count(T)
  local count = 0
  for _ in pairs(T) do count = count + 1 end
  return count
end

function U.split(inputstr, sep)
	if inputstr == nil then return {} end
    if sep == nil then
      sep = "%s"
    else
      inputstr = string.gsub(inputstr, sep .. " ", sep)
    end
    local t={}
		if string.match(inputstr, "^" .. sep) then
			table.insert(t, "")
		end
    for str in string.gmatch(inputstr, "([^"..sep.."]+)") do
      table.insert(t, str)
    end
    return t
end

function U.trim(inputStr, skipInternalWhitepace)
	inputStr = U.ToString(inputStr)
	if skipInternalWhitepace == nil then skipInternalWhitepace = false end

	inputStr = string.gsub(inputStr, "^%s+|%s+$", "")
	if skipInternalWhitepace then return inputStr end

	return string.gsub(inputStr, "%s+", " ")
end

function U.lCase(inputStr) return string.lower(U.ToString(inputStr)) end
function U.uCase(inputStr) return string.upper(U.ToString(inputStr)) end
function U.sCase(inputStr)
	inputStr = U.ToString(inputStr)
	return string.upper(string.sub(inputStr, 1, 1)) .. string.lower(string.sub(inputStr, 2))
end
function U.tCase(inputStr) return U.join(U.iMap(U.split(U.ToString(inputStr), " "), U.sCase), " ") end

function U.error(source, message, val)
	local errString = "[" .. source .. "] " .. message
	local valString

	if val ~= "NOVAL" then
		valString = nil
	elseif U.Type(val) == "userdata" then
		if U.isIn("getName", val) then
			valString = "<" .. val.getName() .. ">"
		else
			valString = "<" .. val.guid or "unknown" .. ">"
		end
	elseif U.Type(val) == "table" then
		valString = JSON.encode_pretty(val)
	else
		valString = U.ToString(val)
	end

	log({ErrorTraceback = debug.traceback()})

	error(errString .. (valString and (": " .. valString) or ""), 3)
end

function U.Val(source, checkVal, testResult, errorMsg, params)
	if testResult == true then return true end
	if errorMsg == nil then errorMsg = "Validation Failed" end
	if params == nil then params = {isSilent = false, isThrowing = true} end
	if testResult ~= false then errorMsg = errorMsg .. " (Test Result = " .. U.ToString(testResult) .. ")" end

	local errorMessage = "[" .. source .. "] " .. errorMsg
	local valType; valType = U.Type(checkVal)
	local valString; valString = U.ToString(checkVal)

	if valType == "userdata" then
		if U.isGameObject(checkVal) then
			valType = checkVal.type
		elseif U.isPlayer(checkVal) then
			if checkVal.steam_id then
				valType = "Player"
			else
				valType = "INVALID Player"
			end
		end
		valString = "'" .. valString .. "'"
	elseif valType == "table" then
		if U.isArray(checkVal) then
			valType = "array"
		end
		logStyle("validate", {0.8, 0.8, 0}, "\n\n{", "}")
		log(checkVal, nil, "validate")
		valString = "'" .. valString .. "' (SEE LOG)"
	end

	errorMessage = errorMessage .. " [VAL = " .. valString .. "] (" .. valType .. ")"

	if params.isSilent then return false end

	if params.isThrowing then
		log(debug.traceback())
		error(errorMessage, 2)
	end

	U.AlertGM(errorMessage, Color(1,0,0))
	return false
end

function U.ToString(val) return val ~= nil and tostring(val) or "NIL" end
function U.Type(val) return val ~= nil and type(val) or "nil" end

function U.Assert(source, val, typeOrTest, tableType, isSilent)
	local errorMessage
	if typeOrTest == nil then typeOrTest = "check" end
	if typeOrTest == "check" then
		if val ~= true then
			errorMessage = "Failed boolean check"
		end
	elseif U.Type(typeOrTest) == "function" or U.Type(typeOrTest) == "boolean" then
		local result
		if U.Type(typeOrTest) == "boolean" then result = typeOrTest
		else result = typeOrTest(val) end
		if result ~= true then
			if result == false or result == nil then
				errorMessage = "Test Failed for param '" .. U.ToString(val) .. "'"
			else
				errorMessage = "Test Failed - '" .. U.ToString(result) .. "'"
			end
		end
	elseif U.Type(typeOrTest) == "string" then
		if val == nil and typeOrTest ~= "nil" then
			errorMessage = "Expected " .. typeOrTest .. ", got 'nil'"
		elseif U.Type(val) == "table" and tableType ~= nil then
			U.forEach(val, function(v)
				if not U.Assert(source, v, tableType, nil, true) then
					errorMessage = "Table elements must all be type '" .. tableType .. "' -- Check log for table output"
				end
			end)
			if errorMessage ~= nil then
				logStyle("assert", {0.8, 0.8, 0}, "\n\n{", "}")
				log(val, nil, "assert")
			end
		elseif U.Type(val) == typeOrTest then return true
		elseif typeOrTest == "Player" then
			if not U.isPlayer(val) then
				errorMessage = "Not a Valid Player: TOSTRING = '" .. U.ToString(val) .. "' TYPE = (" .. U.Type(val) .. "), STEAMID = '" .. U.ToString(val.steam_id) .. "'"
			end
		elseif typeOrTest == "PlayerColor" then
			if not U.isIn(val, Player.getAvailableColors()) then
				errorMessage = "Not a Valid Player Color: '" .. U.ToString(val) .. "' (" .. U.Type(val) .. ")"
			end
		elseif typeOrTest == "Object" then
			if not U.isGameObject(val) then
				errorMessage = "Not a Valid Game Object: TOSTRING = '" .. U.ToString(val) .. "' TYPE = (" .. U.Type(val) .. "), GUID = '" .. U.ToString(val.guid) .. "'"
			end
		elseif string.match(typeOrTest, "^%u") then
			if not U.isGameObject(val) then
				errorMessage = "Not a Valid Game Object: '" .. U.ToString(val) .. "' (" .. U.Type(val) .. ")"
			elseif typeOrTest ~= val.type then
				errorMessage = "Not a Valid " .. typeOrTest .. ": '" .. U.ToString(val) .. "' (" .. U.Type(val) .. ")"
			end
		else
			errorMessage = "Not a Valid " .. typeOrTest .. ": '" .. U.ToString(val) .."' (" .. U.Type(val) .. ")"
		end
	end

	if errorMessage ~= nil then
		if not isSilent then
			U.error(source, errorMessage, val)
		end
		return false
	end

	return true
end

function U.forEach(tbl, func)
	U.Assert("U.forEach", tbl, "table")
	U.Assert("U.forEach", func, "function")
	for key, val in pairs(tbl) do
		func(val, key)
	end
end

function U.iForEach(tbl, func)
	U.Assert("U.iForEach", tbl, "table")
	U.Assert("U.iForEach", func, "function")
	for key, val in ipairs(tbl) do
		func(val, key)
	end
end

-- function U.forEach(tbl, func, delayStep)
-- 	if delayStep == nil then delayStep = 0 end

-- 	local funcs = U.map(tbl, function(val, key) return function() func(val, key) end end)

-- 	U.sequence(funcs, delayStep, false)
-- end

function U.waitRestingSequence(funcs, maxTime, isLoose)
	-- funcs is a table of functions, each of which returns an object or a table of objects
	-- U.waitRestingSequence will wait until the object is resting, before
	-- calling the next function
		-- can set a timeout optionally
		-- can pass 'false' to have function error out rather than continue on timeout

	local delay = 0.5
	local objTargets

	local function callNext()
		if #funcs == 0 then return end
		local func = table.remove(funcs, 1)
		if U.Type(func) == "function" then
			if objTargets ~= nil then
				Wait.time(function()
					Wait.condition(function()
						objTargets = func(objTargets)
						if objTargets ~= nil and U.Type(objTargets) ~= "table" then
							objTargets = {objTargets}
						end
						callNext()
					end, function()
						if objTargets ~= nil and U.Type(objTargets) ~= "table" then
							objTargets = {objTargets}
						end
						for _, objTarget in pairs(objTargets) do
							if objTarget.loading_custom == true then return false end
							if objTarget.resting ~= true then return false end
						end
						return true
					end, maxTime)
				end, delay)
				delay = 0.5
			else
				objTargets = func(objTargets)
				callNext()
			end
		elseif U.Type(func) == "number" then
			delay = delay + func
		end
	end

	callNext()
end

function U.map(tb, func)
	U.Assert("U.map", tb, "table")
	U.Assert("U.map", func, "function")
  local new_table = {}
  for k,v in pairs(tb) do
    new_table[k] = func(v,k)
  end
  return new_table
end

function U.iMap(tb, func)
	U.Assert("U.iMap", tb, "table")
	U.Assert("U.iMap", func, "function")
  local new_table = {}
  for k,v in ipairs(tb) do
    new_table[k] = func(v,k)
  end
  return new_table
end

function U.keyMap(tb, keyFunc, valFunc)
	U.Assert("U.keyMap", tb, "table")
	U.Assert("U.keyMap", keyFunc, "function")
	U.Assert("U.keyMap", valFunc, "function")
	local new_table = {}
	for k,v in pairs(tb) do
		new_table[keyFunc(k, v)] = valFunc(v,k)
	end
	return new_table
end

function U.filter(tb, func)
	U.Assert("U.filter", tb, "table")
	U.Assert("U.filter", func, "function")
  local new_table = {}
  local index = 0
  for k,v in pairs(tb) do
    index = index + 1
    if (func(v, k)) then
      if (k == index) then
        table.insert(new_table, v)
      else
        new_table[k] = v
      end
    end
  end
  return new_table
end

function U.invert(tb)
	local new_table = {}
	for k,v in pairs(tb) do
		if U.isIn(v, {"string", "number"}) then
			new_table[v] = k
		elseif U.isIn(v, {"boolean", "nil", "table", "function"}) then
			new_table[JSON.encode(v)] = k
		else
			new_table.user_data = k
		end
	end
	return new_table
end

function U.shuffle(arr)
	for i = #arr, 2, -1 do
		local j = math.random(i)
		arr[i], arr[j] = arr[j], arr[i]
	end
	return arr
end

function U.sample(arr) return U.shuffle(U.clone(arr))[1] end

function U.concat(...)
	local args = {...}
	local tb = {}
	U.forEach(args, function(arg)
		if U.Type(arg) == "table" then
			for i = 1, #arg do
        tb[#tb+1] = arg[i]
    	end
		else
			table.insert(tb, arg)
		end
	end)
	return tb
end

function U.slice(arr, iStart, iEnd)
	U.Assert("U.Slice", arr, "table")
	if iStart == nil then iStart = 1 end
	if iEnd == nil then iEnd = #arr end
	U.Assert("U.Slice - Array start must be lower than end", iStart <= iEnd)
	local newArr = {}
	for i = iStart, iEnd do
		table.insert(newArr, arr[i])
	end
	return newArr
end

function U.merge(...)
	local args = {...}
	U.Assert("U.merge", args[1], "table")
	local newTable = U.clone(U.shift(args))
	U.iForEach(args, function(nextTable)
		U.Assert("U.merge", nextTable, "table")
		nextTable = U.clone(nextTable)
		U.forEach(nextTable, function(val, key)
			if U.Type(val) == "table" then
				if U.Type(newTable[key]) == "table" then
					newTable[key] = U.merge(newTable[key], val)
				else
					newTable[key] = U.clone(val)
				end
			else
				newTable[key] = val
			end
		end)
	end)
	return newTable
end

function U.join(tb, delim)
	if delim == nil then delim = "|" end
	local returnString = ""
	for _, val in ipairs(tb) do
		returnString = returnString .. delim .. val
	end
	return string.gsub(returnString, "^%s*" .. delim, "")
end

function U.pop(arr)
	if U.Type(arr) ~= "table" or #arr == 0 then return nil end
	return table.remove(arr)
end
function U.push(elem, arr) table.insert(arr, elem) end
function U.shift(arr)
	if U.Type(arr) ~= "table" or #arr == 0 then return nil end
	return table.remove(arr, 1)
end
function U.unshift(elem, arr) table.insert(arr, 1, elem) end
function U.pluck(arr, func)
	local index = U.findIndex(arr, func)
	if index == nil then return nil end
	return table.remove(arr, index)
end

function U.flatten(tb)
	local newTable = {}
	for _, val in pairs(tb) do
		if U.Type(val) == "table" then
			newTable = U.concat(newTable, U.flatten(val))
		else
			table.insert(newTable, val)
		end
	end
	return newTable
end

function U.find(tb, func)
	U.Assert("U.find", tb, "table")
	U.Assert("U.find", func, "function")
  for k,v in pairs(tb) do
    if (func(v,k)) then return v end
  end
  return nil
end

function U.sumVals(tb)
	local total = 0
	U.forEach(U.getValues(tb), function(v) total = total + v end)
	return total
end

function U.findIndex(tb, func)
	U.Assert("U.findIndex", tb, "table")
	U.Assert("U.findIndex", func, "function")
  for k,v in pairs(tb) do
    if (func(v,k)) then return k end
  end
	return nil
end

function U.compact(tb)


end

function U.reverse(tb)
    local rev = {}
    for i = #tb, 1, -1 do
    	rev[#rev+1] = tb[i]
    end
    return rev
end

function U.isIn(elem, tb)
	U.Assert("U.isIn", tb, U.Type(tb) == "table" or U.Type(tb) == "userdata")

	if U.Type(tb) == "table" then
		-- check values first, before checking keys
		for _, value in pairs(tb) do
			if value == elem then
				return true
			end
		end
	end

	-- check key
	local function hasProperty(object, prop)
			local t = object[prop]
			if t == nil then error("Bad Property") end
	end
	if pcall(function() hasProperty(tb, elem) end) then
		return true
	end

	return false
end

function U.isGameObject(val)
	return val
		and U.Type(val) == "userdata"
		and U.ToString(val) ~= "LuaPlayer"
		and val.guid ~= nil
end

function U.isPlayer(val)
	return val
		and U.Type(val) == "userdata"
		and U.ToString(val) == "LuaPlayer"
		and val.steam_id ~= nil
end

function U.isInstance(val, super)
	super = U.ToString(super)
	local mt = getmetatable(val)
	while true do
		if mt == nil then return false end
		if U.ToString(mt) == super then return true end
		mt = getmetatable(mt)
	end
end

function U.isArray(val)
	if U.Type(val) ~= "table" then return false end
	if #val == 0 and #U.getKeys(val) > 0 then return false end
	return true
end

function U.isFlipped(obj)
	if obj == nil then return end
  local zRot = U.pAngle(obj.getRotation().z, 90)
  return zRot == 180
end

function U.splashUIElement(elemID, duration, delay)
  if (duration == nil) then duration = 5 end
  if (delay == nil or delay == 0) then
    UI.show(elemID)
    Wait.time(function() UI.hide(elemID) end, duration)
  else
    Wait.time(function() U.splashUIElement(elemID, duration, 0) end, delay)
  end
end

function U.AlertGM(message, color)
	if color == nil then color = Color(1, 1, 0) end
	broadcastToColor(message, U.getHost().color, color)
end
function U.Alert(message, color)
	if color == nil then color = Color(1, 1, 1) end
	broadcastToAll(message, color)
end

function U.hasAnyTag(obj, tags)
	for _, tag in pairs(tags) do
		if obj.hasTag(tag) then return true end
	end
	return false
end

function U.findTag(obj, tagList)
	for _, tag in pairs(tagList) do
		if obj.hasTag(tag) then return tag end
	end
	return false
end

function U.findColorTag(obj)
	U.Assert("U.findColorTag", obj, "userdata")
	U.Assert("U.findColorTag", obj.hasTag, "function")
	return U.find(Player.getAvailableColors(), function(color) return obj.hasTag(color) end)
end

local UIDS = {}
function U.getUID(length)
	if length == nil then length = 10 end
  local chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
  local uid = ""
	while string.len(uid) < length do
		local randomNumber = math.random(1, #chars)
    uid = uid .. string.sub(chars, randomNumber, randomNumber)
  end
	if U.isIn(uid, UIDS) then
		return U.getUID()
	else
		table.insert(UIDS, uid)
		return uid
	end
end

function U.getHost()
	local hosts = U.filter(Player.getPlayers(), function(player) return player.host end)
	if #hosts == 1 then return hosts[1] end
	-- If there are multiple hosts, this is a hotseat game being debugged: "Eunomiac", "Player 0" or "Player 1" is the assumed host.
	local host = U.find(Player.getPlayers(), function(player) return player.steam_name == "Eunomiac" end)
	if host == nil then
		host = U.find(Player.getPlayers(), function(player) return player.steam_name == "Player 0" end)
	end
	if host == nil then
		host = U.find(Player.getPlayers(), function(player) return player.steam_name == "Player 1" end)
	end
	return host
end

function U.getZoneBounds(zone)
	local zoneExtent = U.map(zone.getScale(), function(val) return 0.5 * val end)
	local zonePos = zone.getPosition()
	return U.map(zonePos, function(coord, axis) return {min = coord - zoneExtent[axis], max = coord + zoneExtent[axis]} end)
end
--#endregion

function U.isInside(zone, pos, ignoreY)
	if ignoreY == nil then ignoreY = true end
	local zoneBounds = U.getZoneBounds(zone)
	return pos.x >= zoneBounds.x.min and pos.x <= zoneBounds.x.max
		and (ignoreY or pos.y >= zoneBounds.y.min and pos.y <= zoneBounds.y.max)
		and pos.z >= zoneBounds.z.min and pos.z <= zoneBounds.z.max
end

function U.parsePosition(obj)
	local posVals, rotVals
	if U.Type(obj) ~= "userdata" then return end
	local desc = obj.getDescription()
	if U.Type(desc) ~= "string" or string.find(desc, "^{%d+.%d+, %d+.%d+, %d+.%d+}") == nil then return end
	local posRotSplit = U.split(desc, "|")
	local posString, rotString = posRotSplit[1], posRotSplit[2]
	if U.Type(posString) == "string" then
		posString = string.gsub(string.sub(posString, 2, #posString - 1), " ", "")
		posVals = U.map(U.split(posString, ","), function(strVal) return 1 * strVal end)
		if #posVals == 3 then
			posVals = {x = posVals[1], y = posVals[2], z = posVals[3]}
		end
	end
	if U.Type(rotString) == "string" then
		rotString = string.gsub(string.sub(rotString, 2, #rotString - 1), " ", "")
		rotVals = U.map(U.split(rotString, ","), function(strVal) return 1 * strVal end)
		if #rotVals == 3 then
			rotVals = {x = rotVals[1], y = rotVals[2], z = rotVals[3]}
		end
	end
	return posVals, rotVals
end

function U.getHandZone(color)
	return U.find(Hands.getHands(), function(hZone) return hZone.getData().FogColor == color end)
end

-- function U.try(fn, ...)
--   local arg = {...}
--   return xpcall(
--     -- function wrapper to pass function arguments
--     function(...) return fn(unpack(arg)) end,
--     -- error function
--     function(msg) return error(msg, 3) end
--   )
-- end

function U.round(num, sigDigits)
  if (sigDigits == nil) then sigDigits = 1 end
  local roundMult = 10 ^ sigDigits
	return (math.floor(num * roundMult + 0.5)) / roundMult
end

function U.roundTableVals(tb, sigDigits)
  local newTable = {}
  for key, val in pairs(tb) do
    newTable[key] = U.round(val, sigDigits)
  end
  return newTable
end

function U.cycle(val, min, max)
	local cycleRange = max - min
	while val > max do
		val = val - cycleRange
	end
	while val < min do
		val = val + cycleRange
	end
	return val
end


function U.getValues(tb)
	local values = {}
	for _, val in pairs(tb) do
		-- log({key = key, val = val})
		table.insert(values, val)
	end
	return values
end

function U.getKeys(tb)
	local keys = {}
	for key in pairs(tb) do
		table.insert(keys, key)
	end
	return keys
end

function U.changeLighting(params)
	if params == nil then return nil end

	U.sequence({
		function()
			for param, val in pairs(params) do
				-- log("CHANGING " .. param .. " to " .. val)
				if string.match(param, "^set") then
					Lighting[param](val)
				else
					Lighting[param] = val
				end
			end
		end,
		Lighting.apply
	}, 0.5)
end

function U.setRotationSlow(obj, rotation, duration, easing, isColliding)
	if duration == nil then duration = 0.5 end
	if isColliding == nil then isColliding = false end
	return U.Lerp(function(rotation) obj.setRotationSmooth(rotation, isColliding, false) end, obj.getRotation(), rotation, duration, true, easing)
end

function U.setPositionSlow(obj, position, duration, easing, isColliding)
	if duration == nil then duration = 0.5 end
	if isColliding == nil then isColliding = false end
	return U.Lerp(function(pos) obj.setPositionSmooth(pos, isColliding, false) end, obj.getPosition(), position, duration, false, easing)
end

function U.setScaleSlow(obj, scale, duration, easing)
	if duration == nil then duration = 0.5 end
	return U.Lerp(function(sc) obj.setScale(sc) end, obj.getScale(), scale, duration, false, easing)
end

-- WaitUntil(afterFunc, testRef, isForcing, maxWait, testFrequency)
	-- Delays execution of a function until a provided test function returns true.
	-- @param afterFunc - {function} the function that will be called when the test returns true
	-- @param testRef - {varies} a value that determines what the test function will be:
			-- {function}: can define a test function directly, which must return true when some condition is met
			-- {number}: executes the function when this many seconds have elapsed (can be 0 to run instantly)
			-- {GameObject}: executes the function when the object has finished spawning *and* is at rest
			-- {nil}: executes the function after a default delay of 0.5 s
			-- {table}: a table containing any combination of the above will execute the function when ALL tests are passed
					-- e.g. passing {gameObject, number, testFunc} will execute the function when
					-- 			... <gameObject> has spawned and is at rest
					--      ... at least <number> seconds have elapsed
					--      ... AND <testFunc> returns 'true'
  -- @param isForcing - {boolean} determines whether <afterFunc> will be called if WaitUntil times out before
		                  -- the test function returns true (default = false)
	-- @param maxWait - {number} the maximum number of frames to wait before timing out (default = 1000)
	-- @param testFrequency - {number} how many frames to wait between each check of the test function (default = 15)
function U.waitUntil(afterFunc, testRef, isForcing, maxWait, testFrequency)
	if afterFunc == nil then return end
	if isForcing == nil then isForcing = false end
	if maxWait == nil then maxWait = 9999 end
	if testFrequency == nil then testFrequency = 15 end

	local frameCount = 0
	local hasWaited = false

	-- parseCheckFunc(testRef): Converts testRef into a test function (recursively, if testRef is a table)
	local function parseCheckFunc(tRef)
		if tRef == nil then tRef = 0.5 end
		if U.Type(tRef) == "function" then return tRef
		elseif U.Type(tRef) == "number" then
			testFrequency = math.max(1, math.min(testFrequency, tRef * 10))
			return function() return frameCount >= (tRef * 30) end
		elseif U.isGameObject(tRef) then
			return function() return tRef and tRef.resting and not tRef.loading_custom end
		elseif U.Type(tRef) == "table" then
			local checkFuncs = U.map(tRef, function(tr) return parseCheckFunc(tr) end)
			return function()
				checkFuncs = U.filter(checkFuncs, function(cf) return cf() == false end)
				return #checkFuncs == 0
			end
		end
	end

	local pCheckFunc = parseCheckFunc(testRef)

	local afterReturnVal

	function CheckCoroutine()
		if pCheckFunc ~= nil then
			while not pCheckFunc() do
				local waitFrames = testFrequency
				frameCount = frameCount + waitFrames
				if (maxWait < 9999 and frameCount > maxWait) and not hasWaited then
					log(debug.traceback())
					hasWaited = true
					if isForcing then
						U.AlertGM("Coroutine Timeout: Forcing ResultFunc")
						break
					end
					U.AlertGM("Coroutine Still Waiting! (See Log Traceback)")
				end

				while waitFrames > 0 do
					coroutine.yield(0)
					waitFrames = waitFrames - 1
				end
			end
		end

		if afterFunc ~= nil then
			afterReturnVal = afterFunc()
		end

		return 1
	end

	startLuaCoroutine(self, "CheckCoroutine")

	return function() return afterReturnVal ~= nil end
end

-- RunSequence({...functions}, maxWait, frequency)
	-- Runs a series of functions sequentially via WaitUntil.
	-- The return value of each function becomes the testRef that will determine when the next function in line is executed

function U.RunSequence(funcs, maxWait, frequency)
	U.Assert("U.RunSequence", funcs, "table", "function")

	local isDone = false

	local function runNextFunc(lastFuncReturnTest)
		local thisFunc = U.shift(funcs)
		U.waitUntil(function()
			if thisFunc == nil then
				isDone = true
				return
			end
			runNextFunc(thisFunc())
		end, lastFuncReturnTest, false, maxWait, frequency)
	end

	local func = U.shift(funcs)
	if func == nil then
		isDone = true
	else
		runNextFunc(func())
	end
	return function() return isDone == true end
end



-- local container = Containers.GetMainStorage()
-- local fetchedObj, playerReply


-- U.RunSequence({
-- 	function() -- Take an object out of a container, clear its name, then delay the next function until
-- 						 -- the retrieved object has finished spawning, has stopped moving, AND at least five
-- 					   -- seconds have elapsed
-- 		fetchedObj = container.takeObject({
-- 			position = container.getPosition:add(Vector(0,3,0)),
-- 			callback_function = function(obj) obj.setName("") end
-- 		})
-- 		return {fetchedObj, 5} -- <- the <testRef> that will determine execution of function #2: in this case,
-- 													 --    a table containing the fetched object and the minimum delay in seconds.
-- 	end,
-- 	function() -- Prompt the Red player to name the object, and execute the third function
-- 		         -- after the player has responded.
-- 		Player.Red.showInputDialog(
-- 			"What shall we name it?",
-- 			"Fetched Object",
-- 			function (fetchedObjName) fetchedObj.setName(fetchedObjName) end
-- 		)
-- 		return function() -- <- this <testRef> defines the test function directly, periodically checking
-- 											--    the name and returning true when it has changed.
-- 			return fetchedObj.getName() ~= ""
-- 		end
-- 	end,
-- 	function() fetchedObj.highlightOn(Color.fromString("Red")) end, -- <- No <testRef> returned = default delay of 0.5s
-- 	Lights.RaiseLighting, 			-- <- If no parameters and no <testRef> needed, can just list functions: they'll
-- 	Containers.StowMainStorage  --    execute every 0.5s
-- })

-- - U.WaitSequence
--   - accepts table of functions to run in sequence
--   - runs function, storing return value to variable
--     - each function's return value controls how the next function is run
--       - if return type is ...
--         - a game object: wait until object is finished spawning and is at rest
--         - a number: wait that many seconds (return '0' to run next function instantly)
--         - nil: wait the default delay of 0.5 seconds
--         - a function: waits until the function returns 'true'
--         - a table of the above: waits until ALL are passed (so a number would represent minimum amount of time to wait)

function U.sequence(funcs, timeDelay)
	timeDelay = timeDelay or 0.5 -- Set default value if none provided
	local delay = 0 -- Initialize delay to 0
	for i, func in ipairs(funcs) do
			if U.Type(func) == "function" then
				if delay == 0 then
					func()
				else
					Wait.time(function()
							func()
					end, delay)
				end
				delay = delay + timeDelay -- Increment delay by timeDelay
			elseif U.Type(func) == "number" then
				delay = delay + func + timeDelay -- Increment delay by func + timeDelay
			else
				error("Invalid element in funcs table")
			end
	end
	return delay
end

function U.roundVector(vec, sigDigits)
	if sigDigits == nil then sigDigits = 2 end
	return Vector(
		U.round(vec[1], sigDigits),
		U.round(vec[2], sigDigits),
		U.round(vec[3], sigDigits)
	)
end

function U.Lerp(setFunc, paramStart, paramEnd, duration, isRotationLerp, easing)
	if duration == nil then duration = 0.5 end
	if U.isInstance(paramStart, Vector) or U.isInstance(paramStart, Color) then
		if paramStart:equals(paramEnd) then return 0 end
	elseif U.Type(paramStart) == "number" then
		if paramStart == paramEnd then return 0 end
	end

	if isRotationLerp then
		local function parseAngleLerp(start, finish)
			-- 350 -> 10,  -10 -> 350
			if math.abs(finish - start) > math.abs(finish + 360 - start) then
				finish = finish + 360
			end
			if math.abs(finish - start) > math.abs(finish - 360 - start) then
				finish = finish - 360
			end
			return finish
		end
		paramEnd = Vector(
			parseAngleLerp(paramStart.x, paramEnd.x),
			parseAngleLerp(paramStart.y, paramEnd.y),
			parseAngleLerp(paramStart.z, paramEnd.z)
		)
	end

	local function getParam(t)
		if t == 1 then return paramEnd end
		if easing ~= nil then
			if easing == "speedUp" then
				t = t * t
			end
		end
		if U.isInstance(paramStart, Vector) or U.isInstance(paramStart, Color) then
			return paramStart:lerp(paramEnd, t)
		elseif U.Type(paramStart) == "number" then
			local deltaVal = paramEnd - paramStart
			return paramStart + (deltaVal * t)
		end
	end

	local startTime = os.time()

	function LerpCoroutine()
		local timeFrac = (os.time() - startTime)/duration
		while timeFrac < 1 do
			setFunc(getParam(timeFrac))
			coroutine.yield(0)
			timeFrac = (os.time() - startTime) / duration
		end
		setFunc(getParam(1))
		return 1
	end

	startLuaCoroutine(self, "LerpCoroutine")

	return duration
end

function U.randBetween(min, max, isInt)
	if U.Type(min) ~= "number" or U.Type(max) ~= "number" then return end
	if min > max then return end
	if isInt == true then
		return U.round(min + math.random() * (max - min), 0)
	end
	return min + math.random() * (max - min)
end

function U.clone(t, isDeepCloning)
	if U.Type(t) ~= "table" then return t end
  local t2 = {}
  for k,v in pairs(t) do
    t2[k] = v
  end
  return t2
end

return U

end)
__bundle_register("kingsdilemma.core.state", function(require, _LOADED, __bundle_register, __bundle_modules)
-- #region IMPORTS ~
local U = require("lib.utilities")
local C = require("kingsdilemma.lib.constants")
local OU = require("kingsdilemma.objects.objUtilities")

local S = {}
-- #endregion

local INITGAMESTATE = {
	gameState = {
		chronicleType = "",
		gameCount = 0,
		gameMode = C.Modes.NONE,
		gamePhase = C.Phases.NONE,
		kingName = "Harald V",
		kingTitle = "King",
		endState = nil,
		startTime = nil,
		endTime = nil,
		gameDuration = nil,
		leader = nil,
		moderator = nil
	},
	roundState = {
    roundNum = 0,
    currentTurn = nil,
    ayeTotal = 0,
    nayTotal = 0,
    passModClaimed = false,
		voteResult = nil,
    boardTokens = { momentum = {}, positions = {} },
    consequences = { N = {}, P = {} }
	},
	turnState = {},
	playerData = {},
	playerStorage = {
		[C.AdminID] = {
			crave = 0,
			house = "Olwyn",
			houseName = "Silverlight",
			id = C.AdminID,
			prestige = 0.05
		}
	},
	gameStorage = {},
	lights = {}
}

-- #region Initializing, Refreshing, Resetting Game State ~
function S.GetSeatCount() return #Player.getAvailableColors() end

function S.ArePlayersSeated()
	local players = Player.getPlayers()
	if #players < 3 then return false end
	for i = 1, 5 do
		if i > #players then return true end
		local thisPlayer = U.pluck(players, function(player) return player.color == C.SeatColors[i] end)
		if thisPlayer == nil then return false end
	end
	-- log("All Players Confirmed Seated.")
	return true
end

function S.getSeatAngles()
	local angleSpan = C.SeatAngleSpan
	local startAngle = 180 - 0.5 * angleSpan
	local angleStep = angleSpan / (#S.getPlayers() - 1)
	return U.iMap(S.getPlayers(), function(_, i)
		return startAngle + angleStep * (i - 1)
	end)
end

function S.UpdatedSeatedPlayerData()
	if not S.ArePlayersSeated() then return nil end
	local angles = S.getSeatAngles()
	local playerData = {}
	U.iForEach(S.getPlayers(), function(player, i)
		playerData[player.color] = {
			id = S.getStorageID(player),
			color = player.color,
			num = i,
			angle = angles[i]
		}
	end)
	S.setStateVal(playerData, "playerData")
	S.setPlayerVal(playerData.color, "curColor")
end

function S.InitializeGameState(save_data)
	Global.setSnapPoints(C.SnapPoints.Global)
	OU.SetBoardSnapPoints()
	if U.Type(save_data) == "string" then
		save_data = JSON.decode(save_data)
	end
	if save_data then
		save_data = U.merge(INITGAMESTATE, save_data)
		S.setGameState(save_data)
	else
		S.resetGameState()
	end
	S.UpdatedSeatedPlayerData()
end

function S.resetGameState()
	local newState = U.clone(INITGAMESTATE, true)
	local state = Global.getTable("gameState")

	if state.playerStorage ~= nil then
		newState.playerStorage = state.playerStorage
	end

	U.forEach(U.getKeys(newState.playerStorage), function(id)
		newState.playerStorage[id].curColor = nil
	end)

	newState.gameState.chronicleType = state.gameState.chronicleType
	newState.gameState.gameCount = state.gameState.gameCount
	newState.gameState.gameMode = C.Modes.NONE
	newState.gameState.gamePhase = C.Modes.NONE
	newState.gameState.kingName = state.gameState.kingName or newState.gameState.kingName
	newState.gameState.kingTitle = state.gameState.kingTitle or newState.gameState.kingTitle
	newState.gameStorage = state.gameStorage

	Global.setTable("gameState", newState)
	-- S.UpdatedSeatedPlayerData()
	S.refreshStateDebug()
	Global.call("UpdatePhaseDisplay")
	UI.hide("gameStatusDisplay")
	UI.show("sessionInitDisplay")
	UI.show("splashScreen")
	UI.setValue("gameNumText", "")
end

function S.resetRoundState()
	S.setStateVal(U.clone(INITGAMESTATE.roundState), "roundState")
	S.setStateVal({}, "turnState")
end

function S.refreshStateDebug(stateData)
	local function parseCode(val, excludeKeys)
		local encodeString
		if val == nil then return "nil" end
		if excludeKeys == nil then
			encodeString = JSON.encode_pretty(val)
		else
			encodeString = JSON.encode_pretty(U.filter(val, function(_, key) return not U.isIn(key, excludeKeys) end))
		end
		return string.gsub(encodeString, "% % ", "..")
	end

	if (stateData == nil) then stateData = Global.getTable("gameState") end
	UI.setValue("stateDisplay_1", parseCode(stateData, {"lights", "playerData", "playerStorage", "gameState", "roundState", "turnState"}))
	UI.setValue("stateDisplay_2", parseCode({gameState = stateData.gameState, roundState = stateData.roundState, turnState = stateData.turnState}))
	UI.setValue("stateDisplay_3", parseCode({playerData = stateData.playerData, lights = stateData.lights}))
	UI.setValue("stateDisplay_4", parseCode({playerStorage = stateData.playerStorage}))
end

-- #endregion

local function getFromTable(tableData, ...)
	local keys = {...}

	while #keys > 0 do
		U.Val("getFromTable()", tableData, tableData and U.Type(tableData) == "table", "Cannot navigate past non-table.")
		local thisKey = U.shift(keys)
		tableData = tableData[thisKey]
		if tableData == nil then return nil end
	end

	return tableData
end

local function setInTable(value, tableData, ...)
	local keys = {...}
	local finalKey = U.pop(keys)
	local tableRef = tableData
	local subTableKey, subTableData, subTableRef
	while #keys > 0 do
		U.Val("setInTable()", tableData, tableData and U.Type(tableData) == "table", "Cannot navigate past non-table.")
		local thisKey = U.shift(keys)
		if tableRef[thisKey] == nil then
			subTableKey = thisKey
			subTableData = {}
			subTableRef = subTableData
			break
		end
		tableRef = tableRef[thisKey]
	end

	while #keys > 0 do
		local thisKey = U.shift(keys)
		subTableRef[thisKey] = {}
		subTableRef = subTableRef[thisKey]
	end

	if subTableKey ~= nil then
		subTableRef[finalKey] = value
		tableRef[subTableKey] = subTableData
	else
		tableRef[finalKey] = value
	end

	return tableData
end

S.GetFromTable = getFromTable
S.SetInTable = setInTable

S.HotseatNameLinks = {
	["Player 0"] = "76561198002132577", -- Silverlight (Euno)
	["Player 1"] = "76561198002132577", -- Silverlight (Euno)
	["Player 2"] = "76561198071469619", -- Lunargent (Brett)
	["Player 3"] = "76561198074782853", -- Concordia (Cory)
	["Player 4"] = "76561198847347865", -- Protosia (Callie)
	["Player 5"] = "76561199015564654"  -- Hedwyn (Roarshack)
}


-- #region Basic Getters & Setters ~
function S.getGameState()
	S.refreshStateDebug()
	return Global.getTable("gameState")
end

function S.setGameState(data)
	Global.setTable("gameState", data)
	S.refreshStateDebug(data)
	return
end

function S.getStateVal(...)
	local state = Global.getTable("gameState")
	S.refreshStateDebug(state)
	return getFromTable(state, ...)
end

-- 	if not state[key] then return state[key] end
-- 	if subKey then return state[key][subKey] end
-- 	return state[key]
-- end

function S.setStateVal(value, ...)
	local state = Global.getTable("gameState")
	state = setInTable(value, state, ...)
	Global.setTable("gameState", state)
	S.refreshStateDebug(state)
end

-- 	if not U.isIn(key, U.getKeys(INITGAMESTATE)) then
-- 		U.AlertGM("WARNING: Setting Unregistered State Val: '" .. key .. "' = '" .. U.ToString(value) .. "'")
-- 	end
-- 	if (subKey) then
-- 		if (state[key] == nil) then state[key] = {} end
-- 		state[key][subKey] = value
-- 	else
-- 		state[key] = value
-- 	end
-- 	Global.setTable("gameState", state)
-- 	S.refreshStateDebug(state)
-- end

function S.setStateVals(stateData)
	local state = Global.getTable("gameState")
	for key, val in pairs(stateData) do
		state[key] = val
	end
	Global.setTable("gameState", state)
	S.refreshStateDebug(state)
end

function S.getRoundState()

end
-- #endregion

-- #region Basic PlayerData Getters & Setters ~
function S.getStorageID(playerRef)
	local player = S.getPlayer(playerRef)
	if player == nil then return nil end
	if U.isIn(player.steam_name or " ", S.HotsetNameLinks) then
		return S.HotseatNameLinks[player.steam_name]
	end
	return U.ToString(player.steam_id)
end

function S.getPlayerData(playerRef)
	local player = S.getPlayer(playerRef)
	if player == nil then return S.getStateVal("playerStorage") end
	return S.getStateVal("playerStorage", S.getStorageID(player))
end

function S.setPlayerData(playerRef, pData)
	local player = S.getPlayer(playerRef)
	S.setStateVal(pData, "playerStorage", S.getStorageID(player))
end

function S.getPlayerVal(playerRef, ...)
	local player = S.getPlayer(playerRef)
	if player == nil then return end

	local response = S.getStateVal("playerData", player.color, ...)

	if response == nil then
		return S.getStateVal("playerStorage", S.getStorageID(player), ...)
	end

	return response
end

function S.setPlayerVal(value, playerRef, ...)
	local player = S.getPlayer(playerRef)
	if player == nil then return end
	local pState = S.getStateVal("playerStorage", S.getStorageID(player))
	if pState == nil then
		pState = {};
		pState.id = S.getStorageID(player)
	end
	pState = setInTable(value, pState, ...)
	S.setPlayerData(player, pState)
end

function S.getPlayerTurnVal(playerRef, ...)
	local player = S.getPlayer(playerRef)
	if player == nil then return end
	return S.getStateVal("turnState", player.color, ...)
end

function S.setPlayerTurnVal(value, playerRef, ...)
	local player = S.getPlayer(playerRef)
	if player == nil then return end
	return S.setStateVal(value, "turnState", player.color, ...)
end
-- #endregion

-- #region Player Instance Getters ~
function S.getPlayer(playerRef)
	if playerRef == nil then return end
	if U.Type(playerRef) == "userdata" then
		if U.isPlayer(playerRef) then return playerRef end
		if U.isGameObject(playerRef) then return S.getPlayerOf(playerRef) end
	elseif U.Type(playerRef) == "string" then
		if playerRef == "Host" or playerRef == "Admin" then
			return U.find(S.getPlayers(), function(player)
				return U.ToString(player.steam_id) == C.AdminID
			end)
		end
		return U.find(S.getPlayers(), function(player)
			return player.color == playerRef
					or U.ToString(player.steam_id) == playerRef
					or U.ToString(player.steam_name) == playerRef
		end)
	elseif U.Type(playerRef) == "number" then
		return S.getPlayers()[playerRef]
	end
end

function S.getPlayers()
	return U.filter(U.iMap(Player.getAvailableColors(), function(color) return Player[color] end), U.isPlayer)
end

-- #endregion

-- #region PLAYER DATA
function S.getPlayerColor(playerRef) return S.getPlayer(playerRef).color end

function S.getOpenColors() return U.filter(Player.getAvailableColors(), function(color) return not U.isPlayer(Player[color]) end) end

function S.getOtherColors(playerRef)
	local pColor
	if U.isIn(playerRef, C.SeatColors) then
		pColor = playerRef
	elseif U.isPlayer(playerRef) then
		pColor = playerRef.color
	else
		local player = S.getPlayer(playerRef)
		if player == nil then return error("No player found for ref'" .. tostring(playerRef) .. "'") end
		pColor = player.color
	end
	return U.filter(Player.getAvailableColors(), function(color) return color ~= pColor end)
end

function S.getNextPlayer(playerRef)
	local player = S.getPlayer(playerRef)
	local playerColors = Player.getAvailableColors()
	local playerIndex = U.findIndex(playerColors, function(color) return color == player.color end)
	if playerIndex == #playerColors then
		return S.getPlayer(playerColors[1])
	else
		return S.getPlayer(playerColors[playerIndex + 1])
	end
end

function S.getPlayerNum(playerRef)
	if playerRef == 0 or playerRef == nil then return 0 end
	return S.getPlayerVal(playerRef, "num")
end

function S.getPlayerAngle(playerRef)
	if playerRef == 0 or playerRef == nil then return 0 end
	return S.getPlayerVal(playerRef, "angle")
end

function S.getPlayerOf(obj)
	if obj == nil then return nil end
	local playerColor = U.findColorTag(obj)
	if playerColor ~= nil then
		return Player[playerColor]
	elseif obj.hasTag("sourceObj") then
		return nil
	else
		local playerAngle = OU.GetNearestAngle(obj, S.getSeatAngles())
		if playerAngle == 0 then return 0 end
		local playerData = U.find(S.getStateVal("playerData"), function(pData) return pData.angle == playerAngle end)
		if playerData == nil then return U.AlertGM("Error finding player of object '" .. U.ToString(obj) .. "'") end
		return S.getPlayer(playerData.num)
	end
end

function S.getPlayerOfHouse(houseName) -- returns COLOR is player is present, ID if player is not present, and false if house is unclaimed
	-- check if any present players have claimed that house
	for _, pData in pairs(S.getStateVal("playerData")) do
		if S.getPlayerHouse(pData.id) == houseName then
			return pData.color
end
end

	-- check if any stored players have claimed that house
	for _, sData in pairs(S.getStateVal("playerStorage")) do
		if sData.house == houseName then
			return sData.id
end
end

	return false
end

function S.getPlayerHouse(playerRef) return S.getPlayerVal(playerRef, "house") end

function S.getPlayerHouseName(playerRef) return S.getPlayerVal(playerRef, "houseName") end

function S.getPlayerPrestige(playerRef) return S.getPlayerVal(playerRef, "prestige") end

function S.getPlayerCrave(playerRef) return S.getPlayerVal(playerRef, "crave") end

function S.getPlayerVoteStatus(playerRef) return S.getPlayerTurnVal(playerRef, "vote") end

function S.getPlayerPowerCommitted(playerRef) return S.getPlayerTurnVal(playerRef, "powerCommitted") end

-- #endregion


-- #region Game Phase Tracking
function S.isInMode(modes)
	if U.Type(modes) == "string" then modes = { modes } end
	return U.isIn(S.getStateVal("gameState", "gameMode"), modes)
end

function S.isInPhase(phases)
	if U.Type(phases) == "string" then phases = { phases } end
	return U.isIn(S.getStateVal("gameState", "gamePhase"), phases)
end

function S.flattenModesAndPhases()
	local modePhases = {}
	local modes = U.getKeys(C.Modes)
	U.iForEach(modes, function(mode)
		if mode == "CHRONSETUP" and S.getStateVal("gameState", "gameCount") ~= 0 then return end
		if U.Type(C.Phases[mode]) == "string" then
			table.insert(modePhases, {mode = mode, phase = C.Phases[mode]})
		else
			local phases = U.getKeys(C.Phases[mode])
			U.iForEach(phases, function(phase)
				table.insert(modePhases, {mode = mode, phase = phase})
			end)
		end
	end)
	return modePhases
end

function S.getNextPhase(curMode, curPhase)
	if curMode == nil then curMode = S.getStateVal("gameState", "gameMode") end
	if curPhase == nil then curPhase = S.getStateVal("gameState", "gamePhase") end

	local modePhases = S.flattenModesAndPhases()
	local modePhaseIndex = U.findIndex(modePhases, function(mData) return mData.mode == curMode and mData.phase == curPhase end)
	local nextPhaseIndex
	if modePhaseIndex == #modePhases then
		nextPhaseIndex = 1
	else
		nextPhaseIndex = modePhaseIndex + 1
	end

	local nextModePhase = modePhases[nextPhaseIndex]

	return nextModePhase.mode, nextModePhase.phase
end
-- #endregion

function S.LogGameStartTime() S.setStateVal(os.time(), "gameState", "startTime") end
function S.LogGameEndTime()
	S.setStateVal(os.time(), "gameState", "endTime")
	S.setStateVal(U.round((S.getStateVal("gameState", "endTime") - S.getStateVal("gameState", "startTime")) / 3600, 1), "gameState", "gameDuration")
end

function S.RecordFinishedGame(scores, tokenPositions)
	if scores == nil then return end
	local gData = {
		gameNum = S.getStateVal("gameState", "gameCount"),
		kingName = S.getStateVal("gameState", "kingName"),
		kingTitle = S.getStateVal("gameState", "kingTitle"),
		endTrigger = S.getStateVal("gameState", "endState"),
		boardPositions = tokenPositions,
		playerResults = scores,
		gameStart = S.getStateVal("gameState", "startTime"),
		gameEnd = S.getStateVal("gameState", "endTime"),
		gameDuration = S.getStateVal("gameState", "gameDuration")
	}
	local gameStorage = S.getStateVal("gameStorage")
	table.insert(gameStorage, gData)
	S.setStateVal(gameStorage, "gameStorage")
	log([[

======== GAME ]] .. gData.gameNum .. [[ RECORD ========

]] .. JSON.encode_pretty(gData) .. [[

=========================================================

]])
end

return S

end)
__bundle_register("kingsdilemma.core.messaging", function(require, _LOADED, __bundle_register, __bundle_modules)
local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
local C = require("kingsdilemma.lib.constants")

local MSG = {}

local DefaultDisplayTime = 1.5
local DefaultDisplayBuffer = 0.5

local defaultTextAttributes = {
	color = U.GetHex(Color.White),
	fontSize = "40",
	font = "Fonts/Friz",
	alignment = "MiddleCenter"
}

local function showPanel(panelID, displayTime)
	UI.setAttribute(panelID, "active", "false")
	UI.show(panelID)
	return displayTime
end

local function hidePanel(panelID, displayBuffer) UI.hide(panelID); return displayBuffer + 0.5 end

function MSG.Splash(messageLines, playerRef, displayTime, attributes)
	attributes = U.merge(defaultTextAttributes, attributes or {})
	local dTime, dBuffer = displayTime or DefaultDisplayTime, DefaultDisplayBuffer
	if type(displayTime) == "table" then
		dTime, dBuffer = displayTime.displayTime or DefaultDisplayTime, displayTime.displayBuffer or DefaultDisplayBuffer
	end
	if type(messageLines) ~= "table" then messageLines = {messageLines} end
	local panelRef = playerRef
	if panelRef == nil then panelRef = "All" end
	if U.Type(panelRef) ~= "string" or not string.match(panelRef, "^All") then
		panelRef = S.getPlayer(playerRef).color
	end
	local panelID, textID = "splashPanel_" .. panelRef, "splashText_" .. panelRef

	return U.RunSequence({
		function()
			UI.setAttribute(panelID, "active", "false")
			UI.setValue(textID, U.join(messageLines, "\n"))
			if attributes then
				UI.setAttributes(textID, attributes)
			end
			return showPanel(panelID, dTime)
		end,
		function()
			return hidePanel(panelID, dBuffer)
		end
	})
end

local currentQuery
function MSG.QueryResponse(index)
	if currentQuery ~= nil then
		Wait.time(function() currentQuery.response = currentQuery[U.getKeys(currentQuery)[index]] end, 0.25)
	end
	UI.hide("splashQuery_" .. currentQuery.player.color)
end

function MSG.SplashQuery(query, displayName, responseObj, playerRef)

	currentQuery = responseObj

	local player = S.getPlayer(playerRef)
	-- log({query=query, displayName = displayName, responseObj = responseObj, playerRef = playerRef, player = player, pColor = player.color})

	UI.setAttribute("splashQuery_" .. player.color, "active", "false")
	UI.setValue("splashQueryPlayerPrompt_" .. player.color, displayName .. ":")
	UI.setAttribute("splashQueryPlayerPrompt_" .. player.color, "color", U.GetHex(Color[player.color]:lerp(Color.White, 0.5)))
	UI.setValue("splashQueryPrompt_" .. player.color, query)

	local answerText = U.getKeys(responseObj)

	for i = 1, #answerText do
		UI.setAttribute("splashQueryContainer_Option" .. i .. "_" .. player.color, "active", "true")
		UI.setValue("splashQueryText_Option" .. i .. "_" .. player.color, answerText[i])
	end

	for i = #answerText + 1, 5 do
		UI.setAttribute("splashQueryContainer_Option" .. i .. "_" .. player.color, "active", "false")
		UI.setValue("splashQueryText_Option" .. i .. "_" .. player.color, "")
	end

	UI.show("splashQuery_" .. player.color)

	currentQuery.player = player

	return function() return currentQuery.response ~= nil end
end

function MSG.Show(id)
	UI.setAttribute(id, "active", "false")
	UI.show(id)
	-- Wait.time(function() UI.setAttribute(id, "active", "true") end, 1)
end

function MSG.Hide(id)
	UI.hide(id)
	Wait.time(function() UI.setAttribute(id, "active", "false") end, 1)
	Wait.time(function() UI.setAttribute(id, "active", "false") end, 2)
end

function MSG.HideAll()
	local elemIDs = {}
	U.forEach({
		"splashPanel_",
		"consequencesQuery_",
		"turnHUD_"
	}, function(prefix)
		U.forEach(C.SeatColors, function(color)
			table.insert(elemIDs, prefix .. color)
		end)
	end)

	U.forEach(elemIDs, function(id) MSG.Hide(id) end)

	return 2.5
end

return MSG
end)
__bundle_register("kingsdilemma.core.lighting", function(require, _LOADED, __bundle_register, __bundle_modules)
local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
local C = require("kingsdilemma.lib.constants")
-- local O = require("kingsdilemma.lib.objects")

local L = {}

local DefaultTransitionTime = 0.5

local function generateLightModes(lightTag)
	if U.isIn(lightTag, {"lightInfluence", "lightWealth", "lightMorale", "lightWelfare", "lightKnowledge"}) then
		local resource = string.match(lightTag, "light(.*)")
		local function getTokenPos()
			local token = getObjectsWithTag(resource)[1]
			if token == nil then
				return Vector(C.Spots.Board.ResourceTokens[resource].center.position)
			else
				U.Assert("generateLightModes", token, "Object")
				return token.getPosition()
			end
		end
		return {
			loadRotation = Vector(0, 0, 0),
			default = "off",
			off = function()
				return {
					enabled = false,
					color = Color.Grey,
					range = 66,
					angle = 20,
					intensity = 0.75,
					rotation = Vector({0, 0, 0}),
					position = getTokenPos():add(Vector({0, 2.5, 0}))
				}
			end,
			ambient = function()
				return {
					enabled = true,
					color = Color.Grey,
					range = 66,
					angle = 20,
					intensity = 0.75,
					rotation = Vector({0, 0, 0}),
					position = getTokenPos():add(Vector({0, 2.5, 0}))
				}
			end,
			momentumUp1 = function()
				return {
					enabled = true,
					color = C.RootColors.Amber,
					range = 66,
					angle = 25,
					intensity = 0.75,
					rotation = Vector({-53.31, 0, 0}),
					position = getTokenPos():add(Vector({0, 1.96, -2.38}))
				}
			end,
			momentumUp2 = function()
				return {
					enabled = true,
					color = Color.Yellow,
					range = 66,
					angle = 20,
					intensity = 1.5,
					rotation = Vector({-67.41, 0.00, 0.00}),
					position = getTokenPos():add(Vector({0, 1.52, -3}))
				}
			end,
			momentumDown1 = function()
				return {
					enabled = true,
					color = C.RootColors.Amber,
					range = 66,
					angle = 25,
					intensity = 0.75,
					rotation = Vector({53.31, 0, 0}),
					position = getTokenPos():add(Vector({0, 1.96, 2.38}))
				}
			end,
			momentumDown2 = function()
				return {
					enabled = true,
					color = Color.Yellow,
					range = 66,
					angle = 20,
					intensity = 1.5,
					rotation = Vector({67.41, 0.00, 0.00}),
					position = getTokenPos():add(Vector({0, 1.52, 3}))
				}
			end
		}
	elseif lightTag == "lightPlayerSpotlight" then
		return {
			off = {
				enabled = false,
				rotation = Vector({0, 0, 0})
			},
			player1 = generateLightModes("player1"),
			player2 = generateLightModes("player2"),
			player3 = generateLightModes("player3"),
			player4 = generateLightModes("player4"),
			player5 = generateLightModes("player5")
		}
	elseif string.match(lightTag, "^player%d") then
		local pIndex = string.match(lightTag, "%d") * 1
		return function()
			return {
				enabled = true,
				color = Color.Grey,
				range = 60,
				angle = 40,
				intensity = 10,
				--position = Vector({0.00, 30.00, 0.00}),
				rotation = Vector({300, S.getPlayerAngle(Player.getAvailableColors()[pIndex]), 0})
			}
		end
	end
end

local focusLightColorKey = {
	x = Color.Grey,
	w = Color.White,
	a = C.RootColors.Amber,
	b = Color.Blue,
	r = Color.Red,
	g = Color.Green
}
local focusLightRangeKey = {
	{range = 50, angle = 15, intensity = 3},
	{range = 50, angle = 30, intensity = 2},
	{range = 50, angle = 60, intensity = 1.5},
	{range = 50, angle = 90, intensity = 1},
	{range = 50, angle = 120, intensity = 1}
}

L.LIGHTMODES = {
	lightMapAnkist = {
		default = "ambient",
		off = {
			enabled = false
		},
		bright = {
			enabled = true,
			color = Color.Grey,
			range = 80,
			angle = 130,
			intensity = 3,
			rotation = Vector(90, 180, 0)
		},
		ambient = {
			enabled = true,
			color = Color.Grey,
			range = 80,
			angle = 110,
			intensity = 1.75,
			rotation = Vector(90, 180, 0)
		},
		dim = {
			enabled = true,
			color = Color.Grey,
			range = 80,
			angle = 110,
			intensity = 1,
			rotation = Vector(90, 180, 0)
		}
	},
	lightMapWorld = {
		default = "ambient",
		off = {
			enabled = false
		},
		bright = {
			enabled = true,
			color = Color.Grey,
			range = 80,
			angle = 130,
			intensity = 3,
			rotation = Vector(90, 180, 0)
		},
		ambient = {
			enabled = true,
			color = Color.Grey,
			range = 80,
			angle = 110,
			intensity = 1.75,
			rotation = Vector(90, 180, 0)
		},
		dim = {
			enabled = true,
			color = Color.Grey,
			range = 80,
			angle = 110,
			intensity = 1,
			rotation = Vector(90, 180, 0)
		}
	},
	lightMapFocusA = {
		-- lua light = getObjectFromGUID("4d3248"); lComp = light.getChildren()[1].getChildren()[2].getComponents()[2]
		default = "off",
		off = {
			enabled = false
		},
		on = function() local lightRef = "A"
			local lightData = S.getStateVal("gameState", "mapLights", "lightData", lightRef)
			if lightData == nil then return { enabled = false } end

			local lData = {
				enabled = true,
				position = Vector(lightData.worldPos),
				rotation = Vector(90, 180, 0),
				color = focusLightColorKey[lightData.colorRef or "x"]
			}

			-- get range settings
			local rangeData = focusLightRangeKey[lightData.rangeRef + 1]

			if lightData.isWorldDerived then
				rangeData.angle = 0.415 * rangeData.angle
				rangeData.intensity = 0.415 * rangeData.intensity
			end

			local finalLData = U.merge(lData, rangeData)
			log{["FocusLight" .. lightRef] = JSON.encode_pretty(finalLData)}

			return U.merge(lData, rangeData)
		end
	},
	lightMapFocusB = {
		-- lua light = getObjectFromGUID("4d3248"); lComp = light.getChildren()[1].getChildren()[2].getComponents()[2]
		default = "off",
		off = {
			enabled = false
		},
		on = function() local lightRef = "B"
			local lightData = S.getStateVal("gameState", "mapLights", "lightData", lightRef)
			if lightData == nil then return { enabled = false } end

			local lData = {
				enabled = true,
				position = Vector(lightData.worldPos),
				rotation = Vector(90, 180, 0),
				color = focusLightColorKey[lightData.colorRef or "x"]
			}

			-- get range settings
			local rangeData = focusLightRangeKey[lightData.rangeRef + 1]

			if lightData.isWorldDerived then
				rangeData.angle = 0.5 * rangeData.angle
				rangeData.intensity = 0.5 * rangeData.intensity
			end

			local finalLData = U.merge(lData, rangeData)
			log{["FocusLight" .. lightRef] = JSON.encode_pretty(finalLData)}

			return U.merge(lData, rangeData)
		end
	},
	lightLectern = {
		default = "ambient",
		off = {
			enabled = false
		},
		ambient = {
			enabled = true,
			color = Color.Grey,
			range = 200,
			angle = 55,
			intensity = 2,
			rotation = Vector(300, 0, 0)
		},
		spotlightChronicleCard = {
			enabled = true,
			color = Color.Grey:lerp(Color.Yellow, 0.25),
			range = 200,
			angle = 35,
			intensity = 2,
			rotation = Vector(312, 0, 0)
		},
		spotlightEnvelope = {
			enabled = true,
			color = Color.Grey,
			range = 200,
			angle = 30,
			intensity = 2,
			rotation = Vector(290, 0, 8)
		},
		spotlightSticker = {
			enabled = true,
			color = Color.Grey,
			range = 200,
			angle = 30,
			intensity = 2,
			rotation = Vector(290, 0, 352)
		},
		spotlightMystery = {
			enabled = true,
			color = Color.Grey,
			range = 200,
			angle = 33,
			intensity = 2,
			rotation = Vector(275, 0, 0)
		},
		spotlightPlinth = {
			enabled = true,
			color = Color.Grey,
			range = 200,
			angle = 30,
			intensity = 2,
			rotation = Vector(290, 0, 0)
		},
		spotlightTransit = {
			enabled = true,
			color = Color.Grey,
			range = 200,
			angle = 50,
			intensity = 1,
			rotation = Vector(304, 0, 0)
		},
		spotlightDilemmaDeck = {
			enabled = true,
			color = Color.Grey,
			range = 200,
			angle = 25,
			intensity = 1.5,
			rotation = Vector({342, 0.00, 0.00 })
		},
		storyCard = {
			enabled = true,
			color = Color.Grey,
			range = 200,
			angle = 25,
			intensity = 1.5,
			rotation = Vector({371.21, 0.00, 0.00 })
		}
	},
	lightPlayerSpotlight = generateLightModes("lightPlayerSpotlight"),
	lightMainTop = {
		default = "ambient",
		off = {
			enabled = false
		},
		ambient = {
			enabled = true,
			color = Color.Grey,
			range = 83,
			angle = 60,
			intensity = 1.5
		}
	},
	lightMainBottom = {
		default = "ambient",
		off = {
			enabled = false
		},
		ambient = {
			enabled = true,
			color = Color.Grey,
			range = 83,
			angle = 60,
			intensity = 1.5
		}
	},
	lightFeature = {
		loadRotation = Vector(0, 0, 0),
		default = "off",
		off = {
			enabled = false,
			angle = 0
		},
		on = {
			enabled = true,
			color = C.RootColors.Amber,
			range = 50,
			angle = 40,
			intensity = 1.7
		}
	},
	lightLeader = {
		default = "off",
		off = {
			enabled = false
		},
		on = {
			enabled = true,
			color = Color.White,
			range = 66,
			angle = 30,
			intensity = 4
		}
	},
	lightModerator = {
		default = "off",
		off = {
			enabled = false
		},
		on = {
			enabled = true,
			color = Color.White,
			range = 66,
			angle = 30,
			intensity = 4
		}
	},
	lightStability = {
		loadRotation = Vector(0, 0, 0),
		off = {
			enabled = false,
			color = Color.White,
			range = 12,
			angle = 20,
			intensity = 1
		},
		on = function()
			local stabilityToken = getObjectsWithTag("StabilityMarker")[1]
			local stabilityPos = stabilityToken.getPosition()
			local distRatio = C.Spots.Board.StabilityToken.center.position:distance(stabilityPos) / C.Spots.Board.StabilityToken.center.position:distance(C.Spots.Board.StabilityToken.top.position)
			local lerpAngle = Vector(20,0,0):lerp(Vector(28,0,0), distRatio).x
			local lerpIntensity = Vector(1,0,0):lerp(Vector(2,0,0), distRatio).x
			local lerpRange = Vector(12,0,0):lerp(Vector(18,0,0), distRatio).x
			local lerpColor
			if distRatio <= 0.5 then
				lerpColor = C.Colors.StabilityToken.center:lerp(C.Colors.StabilityToken.half, 2 * distRatio)
			else
				lerpColor = C.Colors.StabilityToken.half:lerp(C.Colors.StabilityToken.ends, 2 * (distRatio - 0.5))
			end

			stabilityPos:setAt("x", C.Spots.Board.StabilityToken.center.position.x):setAt("y", C.BoardHeight + 4)

			if S.isInMode(C.Modes.END) then
				stabilityPos:setAt("z", C.Spots.Board.StabilityToken.center.position.z)
			else
				stabilityPos:setAt("z", math.min(
					math.max(
						stabilityPos.z,
						C.Spots.Board.StabilityToken.bottom.position.z
					),
					C.Spots.Board.StabilityToken.top.position.z
				))
			end
			-- log({distRatio = distRatio})
			local lData = {
				enabled = true,
				color = lerpColor,
				range = lerpRange,
				angle = lerpAngle,
				intensity = lerpIntensity,
				position = stabilityPos:setAt("y", C.BoardHeight + 4)
			}
			-- log(lData)
			return lData
		end
	},
	lightInfluence = generateLightModes("lightInfluence"),
	lightWealth = generateLightModes("lightWealth"),
	lightMorale = generateLightModes("lightMorale"),
	lightWelfare = generateLightModes("lightWelfare"),
	lightKnowledge = generateLightModes("lightKnowledge"),
	lightBalance = {
		loadRotation = Vector({16.91, 0, 0}),
		default = function()
			if S.isInMode({C.Modes.NONE, C.Modes.SESSIONINIT, C.Modes.CHRONSETUP}) then
				return "off"
			else
				return "on"
			end
		end,
		off = {
			enabled = false
		},
		on = {
			enabled = true,
			color = Color.Grey,
			range = 30,
			angle = 30,
			intensity = 2,
			rotation = Vector({16.91, 0, 0})
		},
		bright = {
			enabled = true,
			color = Color.White,
			range = 40,
			angle = 40,
			intensity = 4,
			rotation = Vector({16.91, 0, 0})
		}
	},
	lightBehind = {
		isPlayerLight = true,
		isSpawned = true,
		off = {
			enabled = false
		},
		ambient = {
			enabled = true,
			color = Color.Grey,
			range = 50,
			angle = 60,
			intensity = 4
		},
		dim = {
			enabled = true,
			color = Color.Grey,
			range = 50,
			angle = 60,
			intensity = 2
		}
	},
	lightFront = {
		isPlayerLight = true,
		isSpawned = true,
		off = {
			enabled = false,
			color = Color.Grey,
			range = 25,
			angle = 85,
			intensity = 4
		},
		ambient = {
			enabled = true,
			color = Color.Grey,
			range = 25,
			angle = 85,
			intensity = 4
		},
		dim = {
			enabled = true,
			color = Color.Grey,
			range = 25,
			angle = 85,
			intensity = 1
		},
		bright = {
			enabled = true,
			color = Color.White,
			range = 25,
			angle = 85,
			intensity = 4
		},
		aye = {
			enabled = true,
			color = Color.Blue,
			range = 25,
			angle = 85,
			intensity = 2.75
		},
		nay = {
			enabled = true,
			color = Color.Red,
			range = 25,
			angle = 85,
			intensity = 1.5
		}
	},
	lightVote = {
		isPlayerLight = true,
		isSpawned = true,
		off = {
			enabled = false,
			color = Color.Grey,
			range = 55,
			angle = 57,
			intensity = 1
		},
		ambient = {
			enabled = true,
			color = Color.Grey,
			range = 55,
			angle = 57,
			intensity = 1
		},
		aye = {
			enabled = true,
			color = Color.Blue,
			range = 55,
			angle = 50,
			intensity = 1
		},
		nay = {
			enabled = true,
			color = Color.Red,
			range = 55,
			angle = 50,
			intensity = 1
		}
	},
	lightDilemmaMain = {
		loadRotation = Vector(180, 0, 0),
		default = "off",
		off = {
			enabled = false,
			rotation = Vector(180, 0, 0)
		},
		on = {
			enabled = true,
			color = Color.Grey,
			range = 60,
			angle = 100,
			intensity = 2,
			rotation = Vector(270, 0, 0) -- position = {0.00, 32.49, 26.14}
		},
		Aye = {
			enabled = true,
			color = Color.Blue,
			range = 60,
			angle = 100,
			intensity = 2,
			rotation = Vector(310, 0, 0) -- position = {0.00, 32.49, 26.14}
		},
		Nay = {
			enabled = true,
			color = Color.Red,
			range = 60,
			angle = 100,
			intensity = 2,
			rotation = Vector(310, 0, 0) -- position = {0.00, 32.49, 26.14}
		}
	},
	lightDilemmaRef = {
		isPlayerLight = true,
		default = "off",
		isSpawned = true,
		off = {
			enabled = false
		},
		on = {
			enabled = true,
			color = Color.Grey,
			range = 33,
			angle = 40,
			intensity = 2
		}
	},
	lightDilemmaAye = {
		loadRotation = Vector(10, 180, 180),
		default = "off",
		off = {
			enabled = false,
			rotation = Vector(10, 180, 180)
		},
		on = {
			enabled = true,
			color = Color.Blue,
			range = 60,
			angle = 40,
			intensity = 2,
			rotation = Vector(330, 180, 180) -- position = {9.32, 27.20, 39.96}
		}
	},
	lightDilemmaNay = {
		loadRotation = Vector(270, 0, 0),
		default = "off",
		off = {
			enabled = false,
			rotation = Vector(270, 0, 0)
		},
		on = {
			enabled = true,
			color = Color.Red,
			range = 25,
			angle = 20,
			intensity = 2.5,
			rotation = Vector({270.00, 73, 0.00}) -- position = {-18.52, 14.79, 38.96}
		}
	}
}

local function getComp(light, isSilent)
	local lComp
	if pcall(function() lComp = light.getChildren()[1].getChildren()[2].getComponents()[2] end) then
		return lComp
	elseif isSilent then
		return nil
	end
	U.Val("getComp", light, U.isGameObject(light), "Invalid Light Object")
	local lComp = light.getChildren()
	U.Val("getComp", {light = light, children = lComp}, #lComp > 0, "Light has no Children")
	lComp = lComp[1].getChildren()
	U.Val("getComp", {light = light, grandchildren = lComp}, #lComp > 1, "Light has too few Grandchildren")
	lComp = lComp[2].getComponents()
	U.Val("getComp", {light = light, components = lComp}, #lComp > 1, "Light has too few components")
	U.Val("getComp", {light = light, comp = lComp[2]}, lComp[2].name == "Light", "Can't find 'Light' component")
	return lComp[2]
end

local function getLight(lightName, playerRef, isSilent)
	local player
	local tags = { lightName }
	if playerRef ~= nil then
		player = S.getPlayer(playerRef)
		table.insert(tags, player.color)
	end
	local lights = getObjectsWithAllTags(tags)

	U.Val("getLight", {tags = tags, lights = lights}, #lights > 0, "No lights found", {isSilent = isSilent})
	U.Val("getLight", {tags = tags, lights = lights}, #lights < 2, "Multiple lights found", {isSilent = false, isThrowing = isSilent ~= true})

	return lights[1]
end

local function getAllLights()
	return U.filter(getObjects(), function(obj)
		return obj.getChildren ~= nil
				and obj.getChildren()[1] ~= nil
				and string.match(obj.getChildren()[1].name, "^spotlight")
				and getComp(obj, true).name == "Light"
	end)
end


local function showArrow(light)
	if light == nil then return U.forEach(getAllLights(), showArrow) end
	light.AssetBundle.playLoopingEffect(0)
	local playerColor = U.findColorTag(light)
	if playerColor ~= nil then
		return light.highlightOn(Color[playerColor])
	else
		return light.highlightOn(Color.White)
	end
end

local function hideArrow(light)
	if light == nil then return U.forEach(getAllLights(), hideArrow) end
	light.AssetBundle.playLoopingEffect(1)
	light.highlightOff()
end



local function setEnabled(light, enabled, transitionTime)
	local lComp = getComp(light)
	if lComp == nil then return end
	if lComp.get("enabled") ~= enabled then
		if transitionTime == nil then transitionTime = DefaultTransitionTime end
		if enabled == true then
			local finalIntensity = lComp.get("intensity")
			lComp.set("intensity", 0)
			lComp.set("enabled", true)
			return U.Lerp(
				function(intensity) lComp.set("intensity", intensity) end,
				0,
				finalIntensity,
				transitionTime
			)
		else
			local startingIntensity = lComp.get("intensity")
			return U.RunSequence({
				function()
					return U.Lerp(
						function(intensity) lComp.set("intensity", intensity) end,
						startingIntensity,
						0,
						transitionTime
					)
				end,
				function()
					lComp.set("enabled", false)
					return 0.5
				end,
				function()
					lComp.set("intensity", startingIntensity)
				end
			})
		end
	end
end
local function setRange(light, range) getComp(light).set("range", range) end
local function setIntensity(light, intensity) getComp(light).set("intensity", intensity) end
local function setColor(light, color) getComp(light).set("color", Color(color)) end
local function setAngle(light, angle) getComp(light).set("spotAngle", angle) end

local function getEnabled(light) return getComp(light).get("enabled") end
local function getRange(light) return getComp(light).get("range") end
local function getIntensity(light) return getComp(light).get("intensity") end
local function getColor(light) return getComp(light).get("color") end
local function getAngle(light) return getComp(light).get("spotAngle") end

function L.InitLights()
	U.forEach(S.getStateVal("lights"), function(mData, lightName)
		if U.Type(mData) == "string" then
			L.SetLightMode(lightName, mData, nil, 0.5)
		else
			U.forEach(mData, function(mode, pColor)
				L.SetLightMode(lightName, mode, pColor, 0.5)
			end)
		end
	end)
end

local function setLightMode(lightName, mode, player, transitionTime, colorShift)
	if transitionTime == nil then transitionTime = DefaultTransitionTime end
	if U.Type(lightName) == "table" then
		return U.map(lightName, function(lName) return setLightMode(lName, mode, player, transitionTime) end)
	end

	U.Val("setLightMode", lightName, U.Type(lightName) == "string" and L.LIGHTMODES[lightName] ~= nil, "Mode Data Not Found")
	local lData; lData = L.LIGHTMODES[lightName]
	local isSpawned = lData.isSpawned

	if lData.isPlayerLight then
		if player == nil then
			return U.map(S.getPlayers(), function(player) return setLightMode(lightName, mode, player, transitionTime) end)
		end
		player = S.getPlayer(player)
		U.Val("setLightMode", {lightName, player}, U.isPlayer(player), "Invalid Player")
	else
		U.Val("setLightMode", {lightName, player}, player == nil, "Player submitted to non-player light", {isThrowing = false})
		player = nil
	end

	local light = getLight(lightName, player, true)
	if light == nil and lData.isSpawned then return false end
	U.Val("setLightMode", {lightName, player}, U.isGameObject(light), "No light found")

	if player then
		local sData = S.getStateVal("lights", lightName)
		if sData == nil then sData = {} end
		sData[player.color] = mode
		S.setStateVal(sData, "lights", lightName)
	else
		S.setStateVal(mode, "lights", lightName)
	end

	if U.Type(mode) == "function" then mode = mode(player) end
	U.Val("setLightMode", mode, U.Type(mode) == "string" and lData[mode] ~= nil, "No such mode for '" .. lightName .. "'")
	lData = lData[mode]
	if U.Type(lData) == "function" then lData = lData() end
	if U.Type(lData) == "table" then lData = U.clone(lData) end

	local function activateLight()
		local afterVals = {}

		if lData.enabled ~= nil then
			if lData.enabled == getEnabled(light) then lData.enabled = nil
			elseif lData.enabled == true then
				setIntensity(light, 0)
				setAngle(light, 0)
				setEnabled(light, true)
			else
				afterVals.intensity = getIntensity(light)
				afterVals.angle = getAngle(light)
				lData.intensity = 0
				lData.angle = 0
			end
		end

		if lData.color ~= nil and colorShift then
			lData.color = Color(lData.color):lerp(Color(colorShift), 0.5)
		end

		return U.RunSequence({
			function()
				local lerpFuncs = {}

				if lData.range ~= nil then
					table.insert(lerpFuncs, U.Lerp(function(range) setRange(light, range) end, getRange(light), lData.range, transitionTime))
				end
				if lData.intensity ~= nil then
					table.insert(lerpFuncs, U.Lerp(function(intensity) setIntensity(light, intensity) end, getIntensity(light), lData.intensity, transitionTime))
				end
				if lData.angle ~= nil then
					table.insert(lerpFuncs, U.Lerp(function(angle) setAngle(light, angle) end, getAngle(light), lData.angle, transitionTime))
				end
				if lData.color ~= nil then
					table.insert(lerpFuncs, U.Lerp(function(color) setColor(light, color) end, getColor(light), lData.color, transitionTime))
				end
				if lData.rotation ~= nil then
					table.insert(lerpFuncs, U.setRotationSlow(light, lData.rotation, transitionTime))
				end
				if lData.position ~= nil then
					table.insert(lerpFuncs, U.setPositionSlow(light, lData.position, transitionTime))
				end

				return lerpFuncs
			end,
			function()
				if lData.enabled == false then
					setEnabled(light, false)
					setIntensity(light, afterVals.intensity)
					setAngle(light, afterVals.angle)
				end
			end
		})
	end

	if isSpawned and not getComp(light, true) then
		return U.waitUntil(activateLight, function() return not not getComp(light, true) end, false)
	end

	return activateLight()
end

function L.PulseLight(lightName, playerRef, peakColor)
	if not lightName or not L.LIGHTMODES[lightName] then return end
	if L.LIGHTMODES[lightName].isPlayerLight and playerRef == nil then
		return U.map(S.getPlayers(), function(player) return L.PulseLight(lightName, player, peakColor) end)
	end

	local light = getLight(lightName, playerRef)
	local baseColor = getColor(light)
	local baseIntensity = getIntensity(light)
	local baseAngle = getAngle(light)
	local baseRange = getRange(light)
	if peakColor == nil then peakColor = Color(baseColor):lerp(Color.White, 0.5) end
	local peakIntensity = 2 * baseIntensity
	local peakAngle = 1.5 * baseAngle
	local peakRange = 2 * baseRange

	U.Lerp(function(color) setColor(light, color) end, baseColor, peakColor, 0.5)
	U.Lerp(function(intensity) setIntensity(light, intensity) end, baseIntensity, peakIntensity, 0.5)
	U.Lerp(function(angle) setAngle(light, angle) end, baseAngle, peakAngle, 0.5)
	U.Lerp(function(range) setRange(light, range) end, baseRange, peakRange, 0.5)
	Wait.time(function()
		U.Lerp(function(color) setColor(light, color) end, peakColor, baseColor, 0.5)
		U.Lerp(function(intensity) setIntensity(light, intensity) end, peakIntensity, baseIntensity, 0.5)
		U.Lerp(function(angle) setAngle(light, angle) end, peakAngle, baseAngle, 0.5)
		U.Lerp(function(range) setRange(light, range) end, peakRange, baseRange, 0.5)
	end, 0.5)

	return 1
end

function L.ResetLights()
	U.forEach(L.LIGHTMODES, function(modes, name)
		if modes.loadRotation then
			local light = getLight(name)
			local lComp = getComp(light)
			if lComp == nil then return end
			lComp.set("enabled", false)
			light.setRotation(Vector(180, 0, 0))
		end
	end)
end

function L.PrimeLights()
	U.forEach(L.LIGHTMODES, function(modes, name)
		if modes.loadRotation then
			local light = getLight(name)
			local lComp = getComp(light)
			if lComp == nil then return end
			lComp.set("enabled", false)
			light.setRotationSmooth(modes.loadRotation)
		end
	end)
end

function L.LoadLights(lightNames, lightMode, transitionTime, playerRef)
	if U.Type(lightNames) == "string" then lightNames = {lightNames} end
	if lightMode == nil then lightMode = "default" end
	if transitionTime == nil then transitionTime = 3 end
	local lightModes = U.clone(L.LIGHTMODES)
	if U.Type(lightNames) == "table" then
		lightModes = U.filter(lightModes, function(_, name) return U.isIn(name, lightNames) end)
	end
	-- log({lightNames = lightNames, lightMode = lightMode, transitionTime = transitionTime, playerRef = playerRef})
	U.forEach(lightModes, function(modes, name)
		if modes[lightMode] == nil then
			U.AlertGM("No Such Mode: " .. U.ToString(lightMode) .. " for light '" .. U.ToString(name) .. "'")
			return end
		if lightMode == "default" then
			setLightMode(name, modes[lightMode], playerRef, transitionTime)
		else
			setLightMode(name, lightMode, playerRef, transitionTime)
		end
	end)
	return transitionTime
end
L.ShowArrows = showArrow
L.HideArrows = hideArrow
L.SetLightMode = setLightMode

L.LerpEnable = setEnabled
L.GetLight = getLight
L.GetAllLights = getAllLights

L.SetIntensity = setIntensity
L.SetAngle = setAngle
L.SetColor = setColor
L.SetRange = setRange

return L

end)
__bundle_register("kingsdilemma.core.voting", function(require, _LOADED, __bundle_register, __bundle_modules)
 local P = require("kingsdilemma.core.players")
local S = require("kingsdilemma.core.state")
local U = require("lib.utilities")
local O = require("kingsdilemma.lib.objects")
local L = require("kingsdilemma.core.lighting")
local C = require("kingsdilemma.lib.constants")
local OU = require("kingsdilemma.objects.objUtilities")
local MSG = require("kingsdilemma.core.messaging")


local V = {}

local riserPowerMax = 10
local riserMaxElevation = Vector(0, 5, 0)
local riserMinElevation = Vector(0, 2, 0)

local function getVoteObjects(playerRef)
	local player = S.getPlayer(playerRef)
	return P.GetPlayerZone(player, "Aye"),
		P.GetPlayerZone(player, "Nay"),
		P.GetPlayerZone(player, "Public"),
		getObjectsWithAllTags({"ayeCard", player.color})[1],
		getObjectsWithAllTags({"nayCard", player.color})[1],
		getObjectsWithAllTags({"PassCard", player.color})[1]
end

local function elevateRiser(playerRef, powerValue)
	local player = S.getPlayer(playerRef)
	local publicZone = P.GetPlayerZone(player, "Public")
	local riser = getObjectsWithAllTags({player.color, "plinthRiser"})[1]
	if powerValue == nil then powerValue = 0 end
	if powerValue > riserPowerMax then powerValue = riserPowerMax end
	local riserPos = riser.getPosition()
	local riserElevation = Vector(riserMinElevation):lerp(Vector(riserMaxElevation), powerValue / riserPowerMax)
	local deltaElevation = math.abs(riserPos.y - riserElevation.y)
	riserPos:setAt("y", riserElevation.y)

	-- Lock and simultaneously elevate any power tokens on riser
	local powerTokens = U.filter(publicZone.getObjects(), function(obj) return obj.hasTag("PowerToken") end)
	return {
		U.Lerp(function(pos) riser.setPositionSmooth(pos) end, riser.getPosition(), riserPos, 3 * (deltaElevation / 3)),
		unpack(U.map(powerTokens, function(token)
			token.setLock(true)
			Wait.time(function() token.setLock(false) end, 3 * (deltaElevation / 3) + 1)
			return U.Lerp(function(pos) token.setPositionSmooth(pos) end, token.getPosition(), Vector(token.getPosition()):add(Vector(0, deltaElevation, 0)), 3 * (deltaElevation / 3))
		end))
	}
end

function V.LowerRiser(playerRef)
	local player = S.getPlayer(playerRef)
	local riser = getObjectsWithAllTags({player.color, "plinthRiser"})[1]
	local riserPos = riser.getPosition()
	local deltaElevation = math.abs(riserPos.y - C.TableHeight)
	riserPos:setAt("y", C.TableHeight)
	return U.Lerp(function(pos) riser.setPositionSmooth(pos) end, riser.getPosition(), riserPos, 3 * (deltaElevation / 3))
end

function V.ElevateBalance()
	local plinth = O.Pieces.BalancePlinth()
	local plinthPos = plinth.getPosition()
	plinthPos.y = 3
	return U.Lerp(function(pos) plinth.setPositionSmooth(pos) end, plinth.getPosition(), plinthPos, 1)
end

function V.LowerBalance()
	local plinth = O.Pieces.BalancePlinth()
	local plinthPos = plinth.getPosition()
	plinthPos.y = 1.94
	L.SetLightMode("lightBalance", "off", nil, 3)
	return U.Lerp(function(pos) plinth.setPositionSmooth(pos) end, plinth.getPosition(), plinthPos, 1)
end

function V.SpawnBalanceTokens(numTokens)
	local plinth = O.Pieces.BalancePlinth()
	local seqFuncs = {}

	local function spawnToken(tokenSize)
		local sourceObj = O.SpawnSources["powerToken" .. tokenSize]()
		local spawnData = sourceObj.getData()
		spawnData.Value = tokenSize
		spawnData.Transform = OU.unfoldTransform({
			position = U.getScatterPosition(plinth, 3, 0.6),
			rotation = Vector({
				U.randBetween(-45, 45, true),
				U.randBetween(-45, 45, true),
				U.randBetween(-45, 45, true)
			}),
			scale = sourceObj.getScale()
		})
		spawnData.Tags = {"PowerToken", "Value" .. tokenSize}
		spawnObjectData({
			data = spawnData,
			callback_function = function(obj) obj.setLock(false) end
		})
		return 0.1
	end

	while math.floor(numTokens / 10) > 0 do
		numTokens = numTokens - 10
		table.insert(seqFuncs, function() return spawnToken(10) end)
	end
	while math.floor(numTokens / 5) > 0 do
		numTokens = numTokens - 5
		table.insert(seqFuncs, function() return spawnToken(5) end)
	end
	while numTokens > 0 do
		numTokens = numTokens - 1
		table.insert(seqFuncs, function() return spawnToken(1) end)
	end

	return U.RunSequence(seqFuncs, nil, 1)
end

function V.SetVotingLights(playerRef)
	if playerRef == nil then return U.map(S.getPlayers(), function(ply) return V.SetVotingLights(ply) end) end
	local player = S.getPlayer(playerRef)
	local playerColor = S.getPlayerColor(playerRef)
	local currentPlayer = S.getStateVal("roundState", "currentTurn")
	local voteStatus = S.getStateVal("turnState", playerColor, "vote")

	if playerColor == currentPlayer then
		local playerNum = S.getPlayerNum(player)
		if voteStatus == false then
			return {
				L.SetLightMode("lightPlayerSpotlight", "player" .. playerNum, nil, 0.5),
				L.SetLightMode("lightBehind", "ambient", player),
				L.SetLightMode("lightFront", "ambient", player),
				L.SetLightMode("lightVote", "ambient", player)
			}
		elseif voteStatus == "Aye" then
			return {
				L.SetLightMode("lightPlayerSpotlight", "player" .. playerNum, nil, 0.5, Color.Blue),
				L.SetLightMode("lightBehind", "ambient", player),
				L.SetLightMode("lightFront", "aye", player),
				L.SetLightMode("lightVote", "aye", player)
			}
		elseif voteStatus == "Nay" then
			return {
				L.SetLightMode("lightPlayerSpotlight", "player" .. playerNum, nil, 0.5, Color.Red),
				L.SetLightMode("lightBehind", "ambient", player),
				L.SetLightMode("lightFront", "nay", player),
				L.SetLightMode("lightVote", "nay", player)
			}
		else
			return {
				L.SetLightMode("lightPlayerSpotlight", "off", nil, 0.5),
				L.SetLightMode("lightBehind", "dim", player),
				L.SetLightMode("lightFront", "off", player),
				L.SetLightMode("lightVote", "off", player)
			}
		end
	else
		if voteStatus == false then
			return {
				L.SetLightMode("lightBehind", "ambient", player),
				L.SetLightMode("lightFront", "dim", player),
				L.SetLightMode("lightVote", "ambient", player)
			}
		elseif voteStatus == "Aye" then
			return {
				L.SetLightMode("lightBehind", "ambient", player),
				L.SetLightMode("lightFront", "aye", player),
				L.SetLightMode("lightVote", "aye", player)
			}
		elseif voteStatus == "Nay" then
			return {
				L.SetLightMode("lightBehind", "ambient", player),
				L.SetLightMode("lightFront", "nay", player),
				L.SetLightMode("lightVote", "nay", player)
			}
		elseif voteStatus == "Pass" or voteStatus == "PassMod" then
			return {
				L.SetLightMode("lightBehind", "dim", player),
				L.SetLightMode("lightFront", "off", player),
				L.SetLightMode("lightVote", "off", player)
			}
		end
	end
end

function V.InitCountZones(playerRef)
	if playerRef == nil then return U.map(S.getPlayers(), V.InitCountZones) end
	local player = S.getPlayer(playerRef)
	local ayeZone, nayZone, publicZone, ayeCard, nayCard, passCard = getVoteObjects(player)
	local voteStatus = S.getStateVal("turnState", player.color, "vote")

	if not S.isInPhase(C.Phases.PLAY.Vote) or voteStatus == false then
		if ayeCard then
			ayeCard.setPositionSmooth(ayeCard.getPosition():setAt("y", C.TableHeight))
		end
		if nayCard then
			nayCard.setPositionSmooth(nayCard.getPosition():setAt("y", C.TableHeight))
		end
		if passCard then
			passCard.setPositionSmooth(passCard.getPosition():setAt("y", C.TableHeight))
			passCard.setRotationSmooth(passCard.getRotation():setAt("z", 0))
			passCard.setLock(not S.isInPhase(C.Phases.PLAY.Vote))
		end

		if ayeZone then
			ayeZone.call("SetCountTag", "PowerToken")
			ayeZone.call("SetColor", Color(0, 1, 1, 1))
			ayeZone.call("UnLinkPublic")
		end
		if nayZone then
			nayZone.call("SetCountTag", "PowerToken")
			nayZone.call("SetColor", Color(1, 0, 0, 1))
			nayZone.call("UnLinkPublic")
		end
		if ayeZone and nayZone then
			ayeZone.call("LinkToOpp", nayZone)
			nayZone.call("LinkToOpp", ayeZone)
		end

		if ayeZone then ayeZone.call("Activate") end
		if nayZone then nayZone.call("Activate") end
		if publicZone then publicZone.call("Deactivate") end
	elseif voteStatus == "Aye" then
		if ayeCard then
			ayeCard.setPositionSmooth(ayeCard.getPosition():setAt("y", C.TableHeight))
		end
		if nayCard then
			nayCard.setPositionSmooth(nayCard.getPosition():setAt("y", C.TableHeight - 3))
		end
		if passCard then
			passCard.setLock(true)
			passCard.setPositionSmooth(passCard.getPosition():setAt("y", C.TableHeight - 3))
		end
		if ayeZone then
			ayeZone.call("SetCountTag", "PowerToken")
			ayeZone.call("SetColor",Color(0, 1, 1, 1))
			ayeZone.call("UnLinkOpp")
			if publicZone then ayeZone.call("LinkToPublic", publicZone) end
		end
		if publicZone then
			publicZone.call("SetCountTag", "PowerToken")
			publicZone.call("SetColor",Color(0, 1, 1, 1))
			publicZone.call("SetScale", "0.4")
			publicZone.call("SetIcon", "powerIcon")
			publicZone.call("SetIconColor", Color(0, 0, 1))
		end
		if ayeZone then ayeZone.call("Activate") end
		if nayZone then nayZone.call("Deactivate") end
		if publicZone then publicZone.call("Activate") end
	elseif voteStatus == "Nay" then
		if ayeCard then
			ayeCard.setPositionSmooth(ayeCard.getPosition():setAt("y", C.TableHeight - 3))
		end
		if nayCard then
			nayCard.setPositionSmooth(nayCard.getPosition():setAt("y", C.TableHeight))
		end
		if passCard then
			passCard.setLock(true)
			passCard.setPositionSmooth(passCard.getPosition():setAt("y", C.TableHeight - 3))
		end
		if nayZone then
			nayZone.call("SetCountTag", "PowerToken")
			nayZone.call("SetColor", Color(1, 0, 0, 1))
			nayZone.call("UnLinkOpp")
			if publicZone then nayZone.call("LinkToPublic", publicZone) end
		end
		if publicZone then
			publicZone.call("SetCountTag", "PowerToken")
			publicZone.call("SetColor", Color(1, 0, 0, 1))
			publicZone.call("SetScale", "0.4")
			publicZone.call("SetIcon", "powerIcon")
			publicZone.call("SetIconColor", Color(0.5, 0, 0))
		end
		if ayeZone then ayeZone.call("Deactivate") end
		if nayZone then nayZone.call("Activate") end
		if publicZone then publicZone.call("Activate") end
	else
		if ayeCard then
			ayeCard.setPositionSmooth(ayeCard.getPosition():setAt("y", C.TableHeight - 3))
		end
		if nayCard then
			nayCard.setPositionSmooth(nayCard.getPosition():setAt("y", C.TableHeight - 3))
		end
		if passCard then
			passCard.setLock(true)
			passCard.setPositionSmooth(passCard.getPosition():setAt("y", C.TableHeight))
			passCard.setRotationSmooth(passCard.getRotation():setAt("z", 0))
		end
		if ayeZone then ayeZone.call("Deactivate") end
		if nayZone then nayZone.call("Deactivate") end
		if publicZone then publicZone.call("Deactivate") end
	end
end

function V.StartTurn(playerRef)
	local player = S.getPlayer(playerRef)
	-- log("Starting Next Turn - " .. player.color)
	return U.RunSequence({
		function() S.setStateVal(player.color, "roundState", "currentTurn") end,
		function()
			V.InitCountZones(player)
			return V.SetVotingLights(player)
		end
	})
end

function V.UpdateHUD(player, isForcing)
	-- if isForcing == nil then isForcing = false end
	-- if not isForcing and UI.getAttribute("turnHUD_" .. player.color, "active") == "false" then return end
	local ayeZone, nayZone = getVoteObjects(player)
	local voteStatus = S.getPlayerVoteStatus(player)
	local ayeCount, nayCount = 0, 0

	if ayeZone then ayeCount = ayeZone.call("GetCount") end
	if nayZone then nayCount = nayZone.call("GetCount") end

	local elemVisibility = {
		voteAye = true,
		voteNay = true,
		passMod = true,
		pass = true,
		stay = true
	}
	local elemText = {
		voteAye = "Vote Aye",
		voteNay = "Vote Nay",
		passMod = "Pass",
		pass = "Pass",
		stay = "Stay"
	}

	if voteStatus == false then
		elemVisibility.voteAye = ayeCount > 0 and nayCount == 0
		elemVisibility.voteNay = nayCount > 0 and ayeCount == 0
		elemVisibility.passMod = ayeCount == 0 and nayCount == 0 and not S.getStateVal("roundState", "passModClaimed")
		elemVisibility.pass = ayeCount == 0 and nayCount == 0
		elemVisibility.stay = false
	elseif voteStatus == "Aye" then
		elemVisibility.voteAye = ayeCount > 0
		elemVisibility.voteNay = false
		elemVisibility.passMod = false
		elemVisibility.pass = false
		elemVisibility.stay = ayeCount == 0
		elemText.voteAye = "Add Power"
	elseif voteStatus == "Nay" then
		elemVisibility.voteAye = false
		elemVisibility.voteNay = nayCount > 0
		elemVisibility.passMod = false
		elemVisibility.pass = false
		elemVisibility.stay = nayCount == 0
		elemText.voteNay = "Add Power"
	end

	local elemVisibilityReport = {[player.color] = elemVisibility}
	elemVisibilityReport[player.color].actions = ""
	U.forEach(elemVisibility, function(isVisible, elemRef)
		if isVisible then
			UI.setValue("turnHUD_" .. elemRef .. "_Text_" .. player.color, elemText[elemRef])
			elemVisibilityReport[player.color].actions = elemVisibilityReport[player.color].actions .. [[
Showing 'turnHUD_]] .. elemRef .. "_container_" .. player.color .. "'"
			MSG.Show("turnHUD_" .. elemRef .. "_container_" .. player.color)
			-- UI.setAttribute("turnHUD_" .. elemRef .. "_container_" .. player.color, "active", "true")
		else
			elemVisibilityReport[player.color].actions = elemVisibilityReport[player.color].actions .. [[
HIDING 'turnHUD_]] .. elemRef .. "_container_" .. player.color .. "'"
			MSG.Hide("turnHUD_" .. elemRef .. "_container_" .. player.color)
		end
	end)
	log([[

=============================
]] .. JSON.encode_pretty(elemVisibilityReport) .. [[
==============================

]])
end

local function updateAyeTotal(addedPower)
	S.setStateVal(S.getStateVal("roundState", "ayeTotal") + addedPower, "roundState", "ayeTotal")
end

local function updateNayTotal(addedPower)
	S.setStateVal(S.getStateVal("roundState", "nayTotal") + addedPower, "roundState", "nayTotal")
end

function V.CheckForLeaderChange(playerRef)
	local player = S.getPlayer(playerRef)
	if player.color == P.GetLeader().color then return 0 end
	local powerCommitted = U.map(S.getStateVal("turnState"), function(pData) return pData.powerCommitted end)
	local playerPowerCommitted = powerCommitted[player.color]
	powerCommitted[player.color] = nil
	for pColor, power in pairs(powerCommitted) do
		if pColor ~= player.color and power >= playerPowerCommitted then
			return 0
		end
	end
	return U.RunSequence({
		function()
			MSG.Splash({P.GetPlayerName(player) .. " claims Leadership over the vote."})
			return P.AssignLeader(player)
		end
	})
end

function V.EndTurn(isPassMod)
	local player = S.getPlayer(S.getStateVal("roundState", "currentTurn"))
	local ayeZone, nayZone, publicZone, ayeCard, nayCard, passCard = getVoteObjects(player)
	local voteStatus = S.getStateVal("turnState", player.color, "vote")

	if voteStatus == false then
		local ayeCount = ayeZone.call("GetCount")
		local nayCount = nayZone.call("GetCount")
		if ayeCount > 0 then
			S.setStateVal("Aye", "turnState", player.color, "vote")
			S.setStateVal(ayeCount, "turnState", player.color, "powerCommitted")
			V.InitCountZones(player)
			return U.RunSequence({
				function()
					MSG.Splash(P.GetPlayerName(player) .. " Votes 'Aye' with " .. ayeCount .. " Power", "AllMid", nil, {color = U.GetHex(Color.Blue)})
					elevateRiser(player, ayeCount)
					return 2
				end,
				function()
					OU.TransferObjects(ayeZone, publicZone, "PowerToken")
					return V.SetVotingLights(player)
				end,
				function()
					updateAyeTotal(ayeCount)
					return V.CheckForLeaderChange(player)
				end,
				function() return 0 end
			})
		elseif nayCount > 0 then
			S.setStateVal("Nay", "turnState", player.color, "vote")
			S.setStateVal(nayCount, "turnState", player.color, "powerCommitted")
			V.InitCountZones(player)
			return U.RunSequence({
				function()
					MSG.Splash(P.GetPlayerName(player) .. " Votes 'Nay' with " .. nayCount .. " Power", "AllMid", nil, {color = U.GetHex(Color.Red)})
					return elevateRiser(player, nayCount) end,
				function()
					OU.TransferObjects(nayZone, publicZone, "PowerToken")
					return V.SetVotingLights(player)
				end,
				function()
					updateNayTotal(nayCount)
					return V.CheckForLeaderChange(player)
				end
			})
		elseif isPassMod then
			S.setStateVal("PassMod", "turnState", player.color, "vote")
			S.setStateVal(true, "roundState", "passModClaimed")
			V.InitCountZones(player)
			return U.RunSequence({
				function()
					MSG.Splash(P.GetPlayerName(player) .. " Passes to Become Moderator", "AllMid", nil, {color = U.GetHex(Color.Yellow)})
					return V.LowerRiser(player)
				end,
				function() return P.AssignModerator(player) end,
				function() return V.SetVotingLights(player) end
			})
		else
			S.setStateVal("Pass", "turnState", player.color, "vote")
			V.InitCountZones(player)
			return U.RunSequence({
				function()
					MSG.Splash(P.GetPlayerName(player) .. " Passes to Gather Power", "AllMid", nil, {color = U.GetHex(C.RootColors.Amber)})
					return V.LowerRiser(player)
				end,
				function() return V.SetVotingLights(player) end
			})
		end
	elseif voteStatus == "Aye" then
		local ayeCount = ayeZone.call("GetCount")
		local totalAyeCount = ayeCount + S.getStateVal("turnState", player.color, "powerCommitted")
		if ayeCount > 0 then
			S.setStateVal(totalAyeCount, "turnState", player.color, "powerCommitted")
			V.InitCountZones(player)
			return U.RunSequence({
				function()
					MSG.Splash(P.GetPlayerName(player) .. " Supports 'Aye' with another " .. ayeCount .. " Power", "AllMid", nil, {color = U.GetHex(Color.Blue)})
					return elevateRiser(player, totalAyeCount) end,
				function()
					OU.TransferObjects(ayeZone, publicZone, "PowerToken")
					return V.SetVotingLights(player)
				end,
				function()
					updateAyeTotal(ayeCount)
					return V.CheckForLeaderChange(player)
				end
			})
		else
			return U.RunSequence({
				function() return MSG.Splash(P.GetPlayerName(player) .. " Stays", "AllMid", nil, {color = U.GetHex(Color.Blue)}) end
			})
		end
	elseif voteStatus == "Nay" then
		local nayCount = nayZone.call("GetCount")
		local totalNayCount = nayCount + S.getStateVal("turnState", player.color, "powerCommitted")
		if nayCount > 0 then
			S.setStateVal(totalNayCount, "turnState", player.color, "powerCommitted")
			V.InitCountZones(player)
			return U.RunSequence({
				function()
					MSG.Splash(P.GetPlayerName(player) .. " Supports 'Nay' with another " .. nayCount .. " Power", "AllMid", nil, {color = U.GetHex(Color.Red)})
					return elevateRiser(player, totalNayCount) end,
				function()
					OU.TransferObjects(nayZone, publicZone, "PowerToken")
					return V.SetVotingLights(player)
				end,
				function()
					updateNayTotal(nayCount)
					return V.CheckForLeaderChange(player)
				end
			})
		else
			return U.RunSequence({
				function() return MSG.Splash(P.GetPlayerName(player) .. " Stays", "AllMid", nil, {color = U.GetHex(Color.Red)}) end
			})
		end
	end
end

return V
end)
__bundle_register("kingsdilemma.hud", function(require, _LOADED, __bundle_register, __bundle_modules)
-- #region IMPORTS ~
local DIR = require("kingsdilemma.core.director")
local P = require("kingsdilemma.core.players")
local O = require("kingsdilemma.lib.objects")
local C = require("kingsdilemma.lib.constants")
local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
-- local HouseScreen = require("kingsdilemma.objs.p3screen")
local L = require("kingsdilemma.core.lighting")
-- local V = require("kingsdilemma.core.voting")
-- local OU = require("kingsdilemma.objects.objUtilities")
local MSG = require("kingsdilemma.core.messaging")
-- #endregion

MessageQueue, QueueStatus = {}, {}

local TESTFUNCS = {
	-- OpAgendas = function(button)
	-- 	local isNegative = button == "-2"
	-- 	local player = U.getHost()
	-- 	local playerOptions = U.iMap(S.getPlayers(), function(player) return player.color end)
	-- 	local resOptions = C.Resources
	-- 	player.showOptionsDialog("Which Player?", playerOptions, 1, function(_, i)
	-- 		local targetPlayer = S.getPlayer(playerOptions[i])
	-- 		player.showOptionsDialog(isNegative and "Which Negative Agenda?" or "Which Positive Agenda?", resOptions, 1, function(_, i)
	-- 			local targetRes = resOptions[i]
	-- 			local openAgendas = S.getPlayerVal(targetPlayer, "openAgendas")
	-- 			if openAgendas == nil then openAgendas = {positive = {}, negative = {}} end
	-- 			if openAgendas[isNegative and "negative" or "positive"] == nil then
	-- 				openAgendas[isNegative and "negative" or "positive"] = {}
	-- 			end
	-- 			table.insert(openAgendas[isNegative and "negative" or "positive"], targetRes)
	-- 			S.setPlayerVal(openAgendas, targetPlayer, "openAgendas")
	-- 		end)
	-- 	end)
	-- end,
	Stickers = function() log(JSON.encode_pretty(DIR.GetStickerData())) end,
	Fetcher = function(button)

	end
}

function InitTestFuncButtons()
	local count = 0
	for i, name in ipairs(U.getKeys(TESTFUNCS)) do
		count = count + 1
		UI.setAttributes("debug_testFunc" .. count, {
			text = "  T: " .. name,
			colors = "#666666|#AAAAAA|#FFFFFF|rgba(0.5, 0.5, 0.5, 0.5)",
			textAlignment = "MiddleLeft"
		})
	end
	TESTFUNCS = U.getValues(TESTFUNCS)
end

function UpdatePhaseDisplay()
	local mode, phase = S.getStateVal("gameState", "gameMode"), S.getStateVal("gameState", "gamePhase")
	UI.setValue("currentGameModeDisplay", mode)
	if mode ~= phase then
		UI.setValue("currentGamePhaseDisplay", phase)
		MSG.Show("currentGamePhaseContainer")
	else
		MSG.Hide("currentGamePhaseContainer")
	end
	local nextMode, nextPhase = S.getNextPhase()
	UI.setValue("nextGameModeDisplay", nextMode)
	if nextMode ~= nextPhase then
		UI.setValue("nextGamePhaseDisplay", nextPhase)
		MSG.Show("nextGamePhaseContainer")
	else
		MSG.Hide("nextGamePhaseContainer")
	end
end

-- #region Primary UI Event Functions
local captureRow = -1
local function toggleXmlElement(elemID, button)
	-- log("Toggling " .. elemID)
	if elemID == "stateDisplayPanel" then
		S.refreshStateDebug()
		toggleXmlElement("stateDisplayPanel_1", button)
		toggleXmlElement("stateDisplayPanel_2", button)
		toggleXmlElement("stateDisplayPanel_3", button)
		toggleXmlElement("stateDisplayPanel_4", button)
		return
	end

	if string.lower(UI.getAttribute(elemID, "active")) == "false" then
		UI.setAttribute(elemID, "active", "true")
		if elemID == "debugControls" then
			MSG.Hide("splashScreen")
			if button ~= "-2" then
				Lighting.ambient_intensity = 1.5
				Lighting.ambient_type = 1
			end
		end
		UI.setAttribute("toggleElem_" .. elemID, "text", "")
	else
		UI.setAttribute(elemID, "active", "false")
		if elemID == "debugControls" then
			Lighting.ambient_intensity = 0
		end
		UI.setAttribute("toggleElem_" .. elemID, "text", "")
	end
end
local function promptSimClick(player, button)
	local players = S.getPlayers()
	if button == "-2" then
		local otherColors = U.map(U.filter(players, function(pl)
			return pl.color ~= player.color
		end), function(pl) return pl.color end)
		log("Simulating clicks on " .. U.join(otherColors, ", "))
		local houses = U.shuffle(U.clone(C.Houses))
		for _, col in pairs(otherColors) do
			local clickElemID = "houseHUD_Button_" .. U.shift(houses)
			log("Simulating " .. col .. " Player clicking '" .. clickElemID .. "'")
			House_HUD_Click(Player[col], "-1", clickElemID)
		end
	else
		local playerOptions = U.map(players, function(pl, i)
			return "#" .. i .. " " .. pl.color .. " (" .. pl.steam_name .. ")"
		end)
		player.showOptionsDialog("Which player is clicking?", playerOptions, 1, function(_, i)
			local targetPlayer = players[i]
			player.showOptionsDialog("Which territory?", C.Houses, 1, function(houseName)
				if houseName == nil then return end
				local clickElemID = "houseHUD_Button_" .. houseName
				log("Simulating " .. targetPlayer.color .. " Player clicking '" .. clickElemID .. "'")
				House_HUD_Click(targetPlayer, "-1", clickElemID)
			end)
		end)
	end
end
local function promptAssignHouseName(player)
	local players = S.getPlayers()
	local playerOptions = U.map(players, function(pl, i)
		return "#" .. i .. " " .. pl.color .. " (" .. pl.steam_name .. ")"
	end)
	player.showOptionsDialog("Name which player's house?", playerOptions, 1, function(_, i)
		local targetPlayer = players[i]
		player.showInputDialog(
			"What is their House Name?",
			S.getPlayerVal(targetPlayer, "house"),
			function (houseName)
				S.setPlayerVal(houseName, targetPlayer, "houseName")
				P.GetPlayerScreen(targetPlayer).call("UpdateXMLTable")
				P.GetPlayerScreen(targetPlayer).call("Activate")
			end)
	end)
end

function HUD_Click(player, button, id)
	-- log({player = player, button = button, id = id})
	if string.match(id, "^splashQuery_Option") then
		local _, optionRef, color = unpack(U.split(id, "_"))
		local stringIndex = string.gsub(optionRef, "Option", "")
		MSG.QueryResponse(tonumber(stringIndex))
	elseif string.match(id, "^toggleElem_") then
		toggleXmlElement(string.gsub(id, "^toggleElem_", ""), button)
	elseif id == "initPreflight" then
		DIR.InitPreflight()
	elseif id == "initSession" then
		DIR.InitSession(button == "-2")
	elseif id == "advanceGamePhase" then
		DIR.ADVANCE()
	elseif id == "prompt_simClick" then
		promptSimClick(player, button)
	elseif id == "prompt_assignHouseName" then
		promptAssignHouseName(player)
	elseif id == "clearPlayers" then
		P.ClearSeats()
	elseif id == "transferToTestPlayers" then
		local players = Player.getPlayers()
		local storedData = U.filter(U.getValues(S.getStateVal("playerStorage")), function(sData) return not string.match(sData.id, "^Player") and sData.curColor ~= nil end)
		U.RunSequence({
			function()
				U.forEach(getObjectsWithTag("HouseCard"), function(obj) obj.setRotation(obj.getRotation():setAt("z", 180)) end)
				return U.sequence(U.map(players, function(player) return function() player.changeColor("Grey") end end), 0.5)
			end,
			function()
				local hostPlayer = U.pluck(players, function(player) return player.steam_name == "Eunomiac" end)
				if hostPlayer == nil then
					hostPlayer = U.pluck(players, function(player) return player.steam_name == "Player 0" end)
				end
				if hostPlayer == nil then
					hostPlayer = U.pluck(players, function(player) return player.steam_name == "Player 1" end)
				end
				if hostPlayer == nil then
					error("No player named 'Eunomiac', 'Player 0', or 'Player 1' found to be Host.")
				end
				hostPlayer.changeColor(S.getStateVal("playerStorage", C.AdminID, "curColor"))
				U.pluck(storedData, function(sData) return sData.curColor == S.getStateVal("playerStorage", C.AdminID, "curColor") end)
				if hostPlayer.steam_name ~= "Eunomiac" then
					local sData = S.getStateVal("playerStorage", C.AdminID)
					sData.id = hostPlayer.steam_name
					S.setStateVal(sData, "playerStorage", hostPlayer.steam_name)
				end
				return 0.5
			end,
			function()
				return U.sequence(U.iMap(players, function(player) return function()
					local sData = U.shift(storedData)
					sData.id = player.steam_name
					player.changeColor(sData.curColor)
					S.setStateVal(sData, "playerStorage", player.steam_name)
				end end), 0.5)
			end
		})
	elseif id == "resetTable" then
		DIR.RESET()
	elseif id == "hideHouseCards" then
		U.forEach(getObjectsWithTag("HouseCard"), function(obj) obj.setRotation(obj.getRotation():setAt("z", button == "-2" and 0 or 180)) end)
	elseif id == "fetchSticker" then
		DIR.PromptForSticker(U.getHost())
	elseif id == "fetchEnvelope" then
		DIR.PromptForEnvelope(U.getHost())
	elseif id == "setNextKing" then
		DIR.PromptForKingName(P.GetWinners())
	elseif id == "captureNext" then
		if button == "-2" then
			captureRow = 0
		else
			captureRow = captureRow + 1
		end
		if captureRow > 6 then
			U.forEach(getObjectsWithTag("Capture"), function(obj) obj.destruct() end)
			player.setCameraMode("ThirdPerson")
			P.SetCamera("BehindScreen", player)
		else
			local cameraData = U.clone(C.CameraAngles.ScreenCapture)
			cameraData.cameraMode = nil
			cameraData.position = Vector(C.CameraAngles.ScreenCapture.position):add(Vector(0, 0, C.CaptureCoords.cameraZoneZShift):scale(1, 1, captureRow + (captureRow == 0 and 0 or 0.25)))
			player.lookAt(cameraData)
			player.setCameraMode("TopDown")
		end
	elseif id == "setChronicleType" then
		DIR.SetChronicleType(true)
	elseif string.match(id, "^debug_testFunc") then
		id = string.gsub(id, "^debug_testFunc", "") * 1
		TESTFUNCS[id](button, player)
	elseif id == "debug_logState" then
		log(JSON.encode_pretty(S.getGameState()))
	elseif id == "logGameToStorage" then
		local tokenData = DIR.GetTokenPositionsFromBoard()
		local scoreData = DIR.GetFinalStandings()
		-- log({tokenData = tokenData, scoreData = scoreData})
		S.RecordFinishedGame(scoreData, tokenData)
	elseif id == "debug_logScores" then
		log(JSON.encode_pretty(DIR.GetFinalStandings()))
	elseif id == "debug_resetState" then
		S.resetGameState()
		Global.call("UpdatePhaseDisplay")
	elseif id == "debug_primeLights" then
		L.ResetLights()
		L.HideArrows()
	elseif id == "debug_setCamera" then
		if button == "-2" then
			P.SetCamera("BehindScreen", Turns.turn_color, "Brown")
		else
			local player = U.getHost()
			local playerOptions = U.getKeys(C.CameraAngles)
			player.showOptionsDialog("Which Camera Mode?", playerOptions, 1, function(_, i)
				local cameraAngle = playerOptions[i]
				if C.CameraAngles[cameraAngle].isPlayerAngle then
					player.showOptionsDialog("Of which player?", Player.getAvailableColors(), 1, function(_, i)
						local camRef = Player.getAvailableColors()[i]
						P.SetCamera(cameraAngle, camRef, player)
					end)
				else
					P.SetCamera(cameraAngle, player)
				end
			end)
		end
	elseif id == "debug_setLight" then
		player.showInputDialog("Which light?",
			"lightName, lightMode, playerColor",
			function(response)
				local rComps = U.split(response, ",")
				local name, mode, pColor = rComps[1], rComps[2], rComps[3]
				L.SetLightMode(name, mode, pColor)
			end)
	elseif id == "debug_resetPlayers" then
		S.resetGameState(true)
		Global.call("UpdatePhaseDisplay")
	elseif id == "debug_setArrows" then
		if button == "-1" then
			L.ShowArrows()
		else
			L.HideArrows()
		end
	elseif string.match(id, "^houseHover_") then
		local houseName = string.match(id, "^houseHover_(.-)_.-$")
		DIR.HouseHUDClick(player, houseName)
	end
end

function HUD_HoverOn(player, returnString, id)
	if string.match(id, "^houseHover_") then
		local houseName = string.match(id, "^houseHover_(.-)_.-$")
		DIR.HouseHUDHoverOn(player, houseName)
	elseif string.match(id, "^splashQuery_") then
		local _, optionRef, color = unpack(U.split(id, "_"))
		UI.setAttribute(id, "color", "#FFD700FF")
		UI.setAttribute("splashQueryText_" .. optionRef .. "_" .. color, "color", "#FFFFFFFF")
	end
end

function HUD_HoverOff(player, returnString, id)
	-- log({player = player, returnString = returnString, id = id})
	if string.match(id, "^houseHover_") then
		local houseName = string.match(id, "^houseHover_(.-)_.-$")
		DIR.HouseHUDHoverOff(player, houseName)
	elseif string.match(id, "^splashQuery_") then
		local _, optionRef, color = unpack(U.split(id, "_"))
		UI.setAttribute(id, "color", "#FFD70011")
		UI.setAttribute("splashQueryText_" .. optionRef .. "_" .. color, "color", "#FFFFFF44")
	end
end
-- #endregion

-- #region House HUD~
function House_HUD_Click(player, _, id)
	local _, _, houseName = unpack(U.split(id, "_"))
	DIR.HouseHUDClick(player, houseName)
end

function House_HUD_HoverOn(player, _, id)
	local _, _, buttonRef = unpack(U.split(id, "_"))
	DIR.HouseHUDHoverOn(player, buttonRef)
end

function House_HUD_HoverOff(player, _, id)
	local _, _, buttonRef = unpack(U.split(id, "_"))
	DIR.HouseHUDHoverOff(player, buttonRef)
end
-- #endregion

-- #region Turn HUD~
function Turn_HUD_Click(_, _, id)
	local _, action, color = unpack(U.split(id, "_"))
	DIR.TurnHUDClick(action, color)
end

function Turn_HUD_HoverOn(_, _, id)
	local _, action, color = unpack(U.split(id, "_"))
	UI.setAttribute("turnHUD_" .. action .. "_Text_" .. color, "color", "rgba(1,1,1,1)")
	if action == "voteAye" then
		UI.setAttribute(id, "color", "rgba(0,1,1,1)")
	elseif action == "voteNay" then
		UI.setAttribute(id, "color", "rgba(1,0,0,1)")
	elseif action == "stay" then
		UI.setAttribute(id, "color", "rgba(0.6, 0.47, 0, 1)")
	else
		UI.setAttribute(id, "color", "rgba(0.6, 0.47, 0, 1)")
	end
end

function Turn_HUD_HoverOff(_, _, id)
	local _, action, color = unpack(U.split(id, "_"))
	UI.setAttribute("turnHUD_" .. action .. "_Text_" .. color, "color", "rgba(1,1,1,0.5)")
	if id == "voteAye" then
		UI.setAttribute(id, "color", "rgba(0,1,1,0.5)")
	elseif id == "voteNay" then
		UI.setAttribute(id, "color", "rgba(1,0,0,0.5)")
	elseif id == "stay" then
		UI.setAttribute(id, "color", "rgba(0.6, 0.47, 0,0.5)")
	else
		UI.setAttribute(id, "color", "rgba(0.6, 0.47, 0,0.5)")
	end
end
-- #endregion

-- #region Consequence HUD~
function Consequence_HUD_Click(_, button, id)
	local _, outcome, conType, resource, color = unpack(U.split(id, "_"))
	MSG.Hide(id)
	if conType ~= "O" then
		MSG.Hide(string.gsub(string.gsub(id, "consequence", "conDisplay"), "_" .. color, ""))
	end
	if button == "-2" then
		conType = "O"
	else
		conType = ({O = "P", P = "N", N = "O"})[conType]
	end
	S.setStateVal(conType, "roundState", "consequences", outcome, resource)
	MSG.Show("consequence_" .. outcome .. "_" .. conType .. "_" .. resource .. "_" .. color)
	if conType ~= "O" then
		MSG.Show("conDisplay_" .. outcome .. "_" .. conType .. "_" .. resource)
	end
end

function Consequence_HUD_HoverOn(_, _, id)
	local _, outcome, conType, _ = unpack(U.split(id, "_"))
	if conType == "O" then
		UI.setAttribute(id, "color", "#7F7F7FFF")
	elseif outcome == "P" then
		UI.setAttribute(id, "color", "#1E87FFFF")
	elseif outcome == "N" then
		UI.setAttribute(id, "color", "#DA1917FF")
	end
end

function Consequence_HUD_HoverOff(_, _, id)
	local _, outcome, conType, _ = unpack(U.split(id, "_"))
	if conType == "O" then
		UI.setAttribute(id, "color", "#7F7F7F7F")
	elseif outcome == "P" then
		UI.setAttribute(id, "color", "#1E87FF7F")
	elseif outcome == "N" then
		UI.setAttribute(id, "color", "#DA19177F")
	end
end
-- #endregion

-- #region Input HUD~
function InputHUD_Sticker(player, value)
	DIR.ConfirmFetchSticker(player, value)
end

function InputHUD_Envelope(player, value)
	DIR.ConfirmFetchEnvelope(player, value)
end

local curKingName
function InputHUD_KingUpdate(player, value)
	curKingName = value
end

function InputHUD_ToggleKingTitle(player)
	if S.getStateVal("gameState", "kingTitle") == "Queen" then
		S.setStateVal("King", "gameState", "kingTitle")
	else
		S.setStateVal("Queen", "gameState", "kingTitle")
	end
	UI.setValue("kingQuery_kingTitle_" .. player.color, S.getStateVal("gameState", "kingTitle"))
end

function InputHUD_KingConfirm(player, _, id)
	-- log({CLICKED = curKingName})
	if not curKingName or #U.trim(U.ToString(curKingName)) < 3 then return end
	local house = S.getPlayerHouse(player)
	local houseName = S.getPlayerHouseName(player)
	local parsedValue = U.join(U.map(U.filter(
		U.split(U.trim(curKingName), " "),
		function(word) return
			not string.match(string.lower(word), "^king$")
			and not string.match(string.lower(word), "^queen$")
			and not string.match(string.lower(word), "^house$")
			and not string.match(string.lower(word), "^" .. U.lCase(house) .. "$")
			and not string.match(string.lower(word), "^" .. U.lCase(houseName) .. "$")
		end
		),
		function (word, i)
			if string.match(string.lower(word), "^of$")
				or string.match(string.lower(word), "^the$")
				or string.match(string.lower(word), "^and$") then
					if i == 1 then return U.tCase(word) end
					return U.lCase(word)
			end
			if string.match(string.upper(word), "^[IVXL]+$") then return U.uCase(word) end
			return U.tCase(word)
		end), " ")
	if not (string.match(parsedValue, " [IVXL]+$") or string.match(parsedValue, " [IVXL]+ ")) then
		parsedValue = parsedValue .. " I"
	end

	local splashValue = string.gsub(parsedValue, " [IVXL]+$", "")
	local splashTitle
	if string.match(C.HousePrefixes[house], "Mark") then
		if S.getStateVal("gameState", "kingTitle") == "Queen" then
			splashTitle = "Marchioness"
		else
			splashTitle = "Marquis"
		end
	else
		if S.getStateVal("gameState", "kingTitle") == "Queen" then
			splashTitle = "Duchess"
		else
			splashTitle = "Duke"
		end
	end

	MSG.Hide("kingQuery_" .. player.color)

	local splashTime = 2
	MSG.Splash(
			splashTitle .. " " .. splashValue .. " " .. houseName .. " Will Inherit the Throne!",
			"AllMid",
			splashTime,
			{color = "#FFDD00"}
		)
		Wait.time(function()
			S.setStateVal(parsedValue .. " of House " .. S.getPlayerHouseName(player), "gameState", "kingName")
		end, splashTime)

end
-- #endregion

-- #region Reference HUD~
local lockedPopupImage = {}
local function hideActiveSubmenus(color, activeMenu)
	U.forEach({"Help", "View", "Map", "Lore"}, function(param)
		if param == activeMenu then return end
		local targetMenuID = "refHUD_SubmenuContents_" .. param .. "_" .. color
		if string.lower(UI.getAttribute(targetMenuID, "active") or "true") == "true" then
			MSG.Hide(targetMenuID)
		end
	end)
end

function Ref_HUD_Click(player, _, id)
	local _, mode, param, color = unpack(U.split(id, "_"))
	-- log({mode = mode, param = param, color = color, pColor = player.color})
	if mode == "Popup" then
		hideActiveSubmenus(player.color)
		local popupID = "refHUD_PopupImage_" .. param .. "_" .. player.color
		if lockedPopupImage[player.color] == popupID then
			lockedPopupImage[player.color] = nil
			MSG.Hide(popupID)
			return
		elseif lockedPopupImage[player.color] ~= nil then
			MSG.Hide(lockedPopupImage[player.color])
		end
		UI.setAttribute(popupID, "active", "false")
		MSG.Show(popupID)
		lockedPopupImage[player.color] = popupID
	elseif mode == "Camera" then
		if param == "Screen" then
			P.SetCamera("BehindScreen", player)
		elseif param == "Board" then
			P.SetCamera("MainBoard", player)
		elseif param == "Resources" then
			P.SetCamera("Resources", player)
		elseif param == "Stickers" then
			P.SetCamera("Stickers", player)
		end
	end
end

function Ref_HUD_HoverOn(player, _, id)
	local _, mode, param, color = unpack(U.split(id, "_"))

	if mode == "Submenu" then
		hideActiveSubmenus(player.color, param)
		UI.setAttribute(id .. "_" .. player.color, "active", "false")
		MSG.Show(id .. "_" .. player.color)
		UI.setAttribute("refHUD_SubmenuContents_" .. param .. "_" .. player.color, "active", "false")
		MSG.Show("refHUD_SubmenuContents_" .. param .. "_" .. player.color)
	elseif mode == "Popup" then
		if lockedPopupImage[player.color] ~= nil then return end
		local popupID = "refHUD_PopupImage_" .. param .. "_" .. player.color
		UI.setAttribute(popupID, "active", "false")
		MSG.Show(popupID)
	end
end

function Ref_HUD_HoverOff(player, _, id)
	local _, mode, param, color = unpack(U.split(id, "_"))
	if mode == "Submenu" then
		MSG.Hide(id .. "_" .. player.color)
	elseif mode == "SubmenuContents" then
		MSG.Hide(id)
		MSG.Hide(string.gsub(id, "Contents", ""))
	elseif mode == "Popup" then
		if lockedPopupImage[player.color] ~= nil then return end
		local popupID = "refHUD_PopupImage_" .. param .. "_" .. player.color
		MSG.Hide(popupID)
	end
end
-- #endregion

-- #region Map Light HUD~
function MapHUD_Update(_, value, id)
	local _, _, index = unpack(U.split(id, "_"))
	local x, z, rc = string.match(value, "(%d+)x, (%d+)y,? ?(%w?%w?)")
	if x == nil or z == nil then
		S.setStateVal({}, "gameState", "mapLights", "mapInputs", index)
		return
	end
	if rc == nil then rc = "" end
	x = x * 1; z = z * 1

	S.setStateVal({Vector(x, 0, z), rc}, "gameState", "mapLights", "mapInputs", index)
end

function MapHUD_Confirm()
	local coordsA, rcA = unpack(S.getStateVal("gameState", "mapLights", "mapInputs", "A") or {})
	local coordsB, rcB = unpack(S.getStateVal("gameState", "mapLights", "mapInputs", "B") or {})

	-- don't need to separate lights between maps, just have one be for first coord and second for second
	-- only one coord AND it's on AnkistMap?  show same location on WorldMap, scaling light properly
	-- only one coord AND it's on WorldMap?  Dim or turn off Ankist map light entirely

	if coordsA == nil then
		if coordsB == nil then return end
		coordsA = Vector(coordsB)
		rcA = rcB
		coordsB = nil
		rcB = nil
	end

	if coordsB == nil then
		coordsB = Vector(coordsA)
		rcB = nil
	end

	local isDerivingWorld = false
	if coordsA.x == coordsB.x and coordsA.z == coordsB.z then
		local rA = (string.match(rcA or "", "(%d)") or "1") * 1
		local cA = string.match(rcA or "", "(%a)") or "x"
		local rB = string.match(rcB or "", "(%d)") or ""
		local cB = string.match(rcB or "", "(%a)") or ""

		if cB == "" then cB = cA end
		if rB == "" then
			isDerivingWorld = true
			rB = rA
		end

		rcB = cB .. rB
	end

	-- S.setStateVal({mapInputs = {}, lightData = {}}, "gameState", "mapLights")

	-- lua aMap = getObjectFromGUID("ec2fcc"); wMap = getObjectFromGUID("378389")
	local function ankistToWorld(ankistLightData)

		local ankistBounds = {
			x = {min = -0.966, max = 0.994},
			z = {min = -0.953, max = 0.964}
		}

		local ankistWorldBounds = {
			x = {min = -0.28, max = 0.535},
			z = {min = -0.58, max = 0.191}
		}

		local ankistDeltas = {
			x = ankistBounds.x.max - ankistBounds.x.min,
			z = ankistBounds.z.max - ankistBounds.z.min
		}

		local ankistWorldDeltas = {
			x = ankistWorldBounds.x.max - ankistWorldBounds.x.min,
			z = ankistWorldBounds.z.max - ankistWorldBounds.z.min
		}

		local lightRatios = {
			x = (ankistLightData.localPos.x - ankistBounds.x.min) / ankistDeltas.x,
			z = (ankistLightData.localPos.z - ankistBounds.z.min) / ankistDeltas.z
		}

		local ankistWorldCoords = {
			x = ankistWorldBounds.x.min + (lightRatios.x * ankistWorldDeltas.x),
			z = ankistWorldBounds.z.min + (lightRatios.z * ankistWorldDeltas.z)
		}

		local ankistWorldLightData = U.clone(ankistLightData)
		ankistWorldLightData.localPos = Vector(
			ankistWorldCoords.x,
			ankistLightData.localPos.y,
			ankistWorldCoords.z
		)

		ankistWorldLightData.worldPos = O.Maps.MapWorld().positionToWorld(ankistWorldLightData.localPos):setAt("z", 75)
		ankistWorldLightData.mapRef = "MapWorld"
		-- ankistWorldLightData.map = O.Maps.MapWorld()

		if ankistWorldLightData.rangeRef > 0 then
			ankistWorldLightData.rangeRef = ankistWorldLightData.rangeRef - 1
		end

		return ankistWorldLightData
	end

	local function parseInputData(coords, rc, isDerivingWorld)
		if coords == nil then return {} end

		local mapRef
		if coords.x > 1000 then
			coords:setAt("x", coords.x - 1000)
			mapRef = "MapWorld"
		else
			mapRef = isDerivingWorld and "MapWorld" or "MapAnkist"
		end

		-- convert to local coordinates
		coords:scale(Vector(-0.002, 1, 0.002)):add(Vector(1, 0, -1))

		-- get range number and color reference
		local r = (string.match(rc or "", "(%d)") or "1") * 1
		local c = string.match(rc or "", "(%a)") or "x"

		-- get world coordinates
		local map = O.Maps[mapRef]()
		local worldPos = map.positionToWorld(coords):setAt("z", 75)

		return {
			localPos = coords,
			worldPos = worldPos,
			mapRef = mapRef,
			-- map = map,
			colorRef = c,
			rangeRef = r,
			isWorldDerived = mapRef == "MapWorld" and isDerivingWorld
		}
	end

	local lightDataA, lightDataB = parseInputData(coordsA, rcA), parseInputData(coordsB, rcB, isDerivingWorld)
	local mapAnkistMode, mapWorldMode = "off", "off"

	if U.isIn("MapAnkist", {lightDataA.mapRef, lightDataB.mapRef}) then mapAnkistMode = "dim" end
	if U.isIn("MapWorld", {lightDataA.mapRef, lightDataB.mapRef}) then mapWorldMode = "dim" end

	if isDerivingWorld or (lightDataA.mapRef == "MapAnkist" and lightDataB.mapRef == nil) then
		lightDataB = ankistToWorld(lightDataA)
		mapWorldMode = "dim"
	end

	S.setStateVal(lightDataA, "gameState", "mapLights", "lightData", "A")
	S.setStateVal(lightDataB, "gameState", "mapLights", "lightData", "B")

	L.SetLightMode("lightMapAnkist", mapAnkistMode)
	L.SetLightMode("lightMapWorld", mapWorldMode)
	L.SetLightMode({"lightMapFocusA", "lightMapFocusB"}, "on")
end



-- #endregion
end)
__bundle_register("vscode/console", function(require, _LOADED, __bundle_register, __bundle_modules)
require("Console/console++")

-- function prototype
function onExternalCommand(command) end

-- Overwrite onChat function if you rather be handled by onExternalMessage
-- function onChat(message, player) end

function onExternalMessage(data)
  if data.input ~= nil then onExternalCommand(data.input) end
  if data.command ~= nil then
    local hostPlayer
    local players = getSeatedPlayers()
    for key, value in pairs(players) do
      if Player[value].host then
        hostPlayer = Player[value]
      end
    end
    if data.command ~= '' then
      local command = ''
      local command_function = nil
      local parameters = {hostPlayer}
      local requires_admin = false
      local command_mode = console.in_command_mode[hostPlayer.steam_id]
      if command_mode and console.active then
          command, command_function, parameters, requires_admin = console.get_command(data.command, hostPlayer)
      elseif data.command:sub(1, 1) == console.command_char and console.active then
          if data.command:len() > 1 then
              command, command_function, parameters, requires_admin = console.get_command(data.command:sub(2), hostPlayer)
          else
              command, command_function, parameters, requires_admin = console.get_command(console.command_char, hostPlayer)
          end
      else
          for i, f in ipairs(console.validation_functions) do
              local valid, response = f(data.command)
              if response == nil then response = '' end
              if not valid then
                  printToColor(response, hostPlayer.color, console.invalid_color)
                  return false
              end
          end
          return true
      end
      if console.active then
          if command_function and (hostPlayer.admin or not requires_admin) then
              if command_mode then
                  data.command = console.command_char .. console.command_char .. data.command
              end
              local response, mute = command_function(unpack(parameters))
              if response ~= nil or mute ~= nil then
                  if not mute then
                      printToColor('\n'..data.command, hostPlayer.color, console.command_color)
                  end
                  if response then
                      printToColor(response, hostPlayer.color, console.output_color)
                  end
              end
              if console.in_command_mode[hostPlayer.steam_id] then console.display_prompt(hostPlayer) end
              return false
          else
              printToColor('\n'..data.command, hostPlayer.color, console.command_color)
              printToColor(console.error_bb .. "<command '" .. command .. "' not found>[-]", hostPlayer.color, console.output_color)
              return false
          end
      end
    end
  end
end

end)
__bundle_register("Console/console++", function(require, _LOADED, __bundle_register, __bundle_modules)
require("Console/console")

if not console.plusplus then
    console.plusplus = true

    -- Change these values as you wish
    console.seperator         = '/'
    console.wildcard          = '*'
    console.literal           = '`'  -- string parameters will be treated as paths where apt unless prefixed with this
    console.result            = '~'  -- refers to the most recently returned result from a call
    console.command_seperator = ';'  -- used in batch files to seperate commands
    console.indent            = '  '
    console.crop_string_at = 20
    console.builtin_path = 'sys'
    console.table_bb    = '[EEDD88]'
    console.hidden_bb   = '[DDAAAA]'
    console.function_bb = '[AADDAA]'
    console.value_bb    = '[88EE88]'
    console.boolean_bb  = '[CCCCFF]'
    console.object_bb   = '[CCBBCC]'
    console.guid_bb     = '[BBBBBB]'

    console.autoexec         = ''
    console.autoexec_options = '-s'

    -- Exposed methods:

    function console.hide_globals(label)
        -- all globals present when you call this will be hidden under <label> (unless built-in or already hidden)
        local hidden = {}
        for global, _ in pairs(_G) do
            local found = false
            for _, globals in pairs(console.hidden_globals) do
                if globals[global] then
                    found = true
                    break
                end
            end
            if not found then
                table.insert(hidden, global)
            end
        end
        if console.hidden_globals[label] == nil then
            console.hidden_globals[label] = {}
        end
        for _, global in ipairs(hidden) do
            console.hidden_globals[label][global] = true
        end
    end

    function console.load()
        -- call this function in an onLoad event to enable the autoexec
        console.cd = console.seperator
        for _, player in pairs(getSeatedPlayers()) do
            if Player[player].admin then
                console.commands['exec'].command_function(Player[player], console.seperator..'console'..console.seperator..'autoexec', console.autoexec_options)
                break
            end
        end
    end

    function console.update()
        -- call this function in an onUpdate event to enable the watch list
        if console.watch_list and not console.watch_list_paused then
            for variable, watch in pairs(console.watch_list) do
                if watch.throttle == 0 or watch.last_check + watch.throttle < os.clock() then
                    watch.last_check = os.clock()
                    local node, id, parent, found
                    if watch.is_guid then
                        node = getObjectFromGUID(variable)
                        found = tostring(node) ~= 'null'
                    else
                        node, id, parent, found = console.node_from_path(variable)
                    end
                    if node ~= nil and found then
                        if type(node) == 'userdata' then
                            if tostring(node) ~= 'null' then
                                local p = function (x) return math.floor(x * 100) * 0.01 end
                                local r = function (x) return math.floor(x + 0.5) end
                                local position = node.getPosition()
                                local rotation = node.getRotation()
                                if p(position.x) ~= p(watch.position.x) or r(rotation.x) ~= r(watch.rotation.x) or
                                   p(position.y) ~= p(watch.position.y) or r(rotation.y) ~= r(watch.rotation.y) or
                                   p(position.z) ~= p(watch.position.z) or r(rotation.z) ~= r(watch.rotation.z) then
                                   watch.position = position
                                   watch.rotation = rotation
                                   node = '  '..r(rotation.x)..' '..r(rotation.y)..' '..r(rotation.z) ..
                                        console.boolean_bb..'     '..p(position.x)..'   '..p(position.y)..'   '..p(position.z)
                                   if watch.is_guid then
                                       variable = console.format_guid(variable)
                                   else
                                       variable = console.object_bb .. variable .. '[-]'
                                   end
                                   printToColor(variable .. console.value_bb .. node .. '[-]', watch.player, console.output_color)
                                end
                            end
                        elseif type(node) == 'function' then
                            local result = node(unpack(watch.parameters))
                            if watch.property and (type(result) == 'table' or type(result) == 'userdata') then
                                result = result[watch.property]
                                if type(result) == 'function' then
                                    result = result()
                                end
                            end
                            if result ~= watch.value then
                                watch.value = result
                                result = tostring(result)
                                if result:len() > console.crop_string_at then result = result:sub(1, console.crop_string_at) .. '...' end
                                if result:len() == 6 and watch.label:lower():find('guid') then result = console.format_guid(result) end
                                printToColor(watch.label .. console.value_bb .. result .. '[-]', watch.player, console.output_color)
                            end
                        else
                            if node ~= watch.value then
                                watch.value = node
                                if type(node) == 'boolean' then
                                    if node then
                                        node = 'true'
                                    else
                                        node = 'false'
                                    end
                                elseif type(node) == 'string' then
                                    if node:len() > console.crop_string_at then node = node:sub(1, console.crop_string_at):gsub('\n', ' ') .. '...' end
                                end
                                printToColor(variable .. ': ' .. console.value_bb .. node .. '[-]', watch.player, console.output_color)
                            end
                        end
                    end
                end
            end
        end
    end

    -- simple swear-blocking validation
    console.add_validation_function(
        function (message)
            local message = message:lower()
            for i, bad_word in pairs({'fuck', 'cunt'}) do
                if message:find(bad_word) then
                    return false, "No swearing!"
                end
            end
            return true
        end
    )

    -- End of exposed methods.  You shouldn't need to interact with anything below (under normal circumstances)


    -- override default prompt with one which displays current table
    function console.display_prompt(player)
        printToColor(console.cd .. ' ' .. console.command_char..console.command_char, player.color, console.prompt_color)
    end


    -- console++ follows

    console.cd = console.seperator
    console.hidden_globals = {}
    console.hide_globals(console.builtin_path)

    function console.is_hidden(label)
        for _, globals in pairs(console.hidden_globals) do
            if globals[label] then
                return true
            end
        end
        return false
    end

    function console.escape_bb(s)
        local s = tostring(s)
        if s == '' then
            return ''
        else
            local r = ''
            for c = 1, s:len() do
                local char = s:sub(c, c)
                if char == '[' then
                    r = r .. '[\u{200B}'
                elseif char == ']' then
                    r = r .. '\u{200B}]'
                else
                    r = r .. char
                end
            end
            return r
        end
    end

    function console.format_guid(guid)
        return console.guid_bb .. '' .. guid .. '[-]'
    end

    function console.fill_path(path)
        local path = path
        local filter = nil
        if path == nil then
            return console.cd, filter
        end
        local c = path:len()
        if path:sub(c) ~= console.seperator then
            local found = false
            while c > 0 do
                local char = path:sub(c, c)
                if char == console.wildcard then
                    found = true
                elseif char == console.seperator then
                    break
                end
                c = c - 1
            end
            if found then
                filter = '^'
                for i = c + 1, path:len() do
                    local char = path:sub(i, i)
                    if char == console.wildcard then
                        filter = filter .. '.*'
                    else
                        filter = filter .. char
                    end
                end
                filter = filter .. '$'
                path = path:sub(1, c)
            end
        end
        if path:sub(1,1) == console.seperator then
            return path, filter
        else
            return console.cd .. path, filter
        end
    end

    function console.node_from_path(path)
        local node = _G
        local id = {''}
        local parent = {nil}
        local found = true
        local depth = 0
        local stack = {}
        local hidden = nil
        local ends_with_table = {true}
        if path == 'true' then
            node = true
        elseif path == 'false' then
            node = false
        elseif path ~= console.seperator then
            for i, part in ipairs(console.split(path, console.seperator)) do
                if part == '..' then
                    if depth > 0 then
                        node = table.remove(parent)
                        table.remove(id)
                        table.remove(stack)
                        table.remove(ends_with_table)
                        depth = depth - 1
                    end
                elseif part == '.' then
                    ; -- do nothing, . = where we are
                elseif part == console.result then
                    table.insert(parent, node)
                    table.insert(id, part)
                    table.insert(stack, part)
                    node = console.returned_value
                    table.insert(ends_with_table, type(node) == 'table')
                    depth = depth + 1
                elseif node[part] ~= nil then
                    table.insert(parent, node)
                    table.insert(id, part)
                    table.insert(stack, part)
                    node = node[part]
                    table.insert(ends_with_table, type(node) == 'table')
                    depth = depth + 1
                elseif node == _G and console.hidden_globals[part] then
                    hidden = console.hidden_globals[part]
                else
                    table.insert(id, part)
                    found = false
                    break
                end
            end
        end
        path = ''
        for i, part in ipairs(stack) do
            path = path .. console.seperator .. part
        end
        if table.remove(ends_with_table) then
            path = path .. console.seperator
        end
        return node, table.remove(id), table.remove(parent), found, path, hidden
    end


    -- commands

    console.add_admin_command('cd', '[<table>]',
        'Display current table or change current table',
        function (player, path)
            if path == nil then
                return console.cd
            else
                path = tostring(path)
            end
            local location = console.fill_path(path)
            local node, id, parent, found, location = console.node_from_path(location)
            local text = nil
            if node ~= nil and found and type(node) == 'table' then
                console.cd = location
                if not console.in_command_mode[player.steam_id] then text = console.cd end
            else
                text = console.error_bb .. '<not found>[-]'
            end
            return text, false
        end
    )
    console.add_admin_command('cd..', '', 'Change current table to parent table.', 'cd', {'..'})

    console.add_admin_command('ls', '[' .. console.option .. '?afotv] [' .. console.option .. 'r[#]] [<table>]',
        'Display variables in current table or specified table',
        function (player, ...)
            local help_details = console.header_bb .. 'Options[-]\n' ..
                'Show:\n '..console.option..'f functions\n '..console.option..'o objects\n '..
                console.option..'v variables (defaults to on)\n '..console.option..'t tables (defaults to on)\n '..
                console.option..'a all\n\n' ..console.option..'r[#] recurse [# layers if specified]'
            local path = console.cd
            local display_functions = false
            local display_objects = false
            local display_variables = false
            local display_tables = false
            local display_all = false
            local recursions_left = 0
            for i, arg in ipairs({...}) do
                arg = tostring(arg)
                if arg:len() > 1 and arg:sub(1,1) == console.option then
                    local c = 2
                    while c <= arg:len() do
                        local option = arg:sub(c,c)
                        if option == 'f' then
                            display_functions = not display_functions
                        elseif option == 'o' then
                            display_objects = not display_objects
                        elseif option == 'v' then
                            display_variables = not display_variables
                        elseif option == 't' then
                            display_tables = not display_tables
                        elseif option == 'a' then
                            display_all = not display_all
                        elseif option == 'r' then
                            local n = ''
                            local j = c + 1
                            while j <= arg:len() do
                                local char = arg:sub(j, j)
                                if char:match('%d') then
                                    n = n .. char
                                else
                                    break
                                end
                                j = j + 1
                            end
                            c = j - 1
                            if n == '' then
                                recursions_left = 20
                            else
                                recursions_left = tonumber(n)
                            end
                        elseif option == '?' or option == 'h' then
                            return help_details
                        else
                            return console.error_bb .. "<option '" .. console.option .. option .. "' not recognized>[-]\n"
                        end
                        c = c + 1
                    end
                else
                    path = arg
                end
            end
            local default_variables = not (display_tables or display_objects or display_functions or display_variables)
            if display_functions or display_objects or display_variables then
                display_tables = not display_tables
            end
            if display_all then
                display_functions = true
                display_objects = true
                display_variables = true
                display_tables = true
            elseif default_variables then
                display_functions = false
                display_objects = false
                display_variables = true
                display_tables = true
            end
            local location, filter = console.fill_path(path)
            return console.ls(player, location, filter, display_functions, display_objects, display_variables, display_tables, recursions_left)
        end
    )
    console.add_admin_command('dir', nil, nil, 'ls')
    console.add_admin_command(console.result, '', "Calls 'ls "..console.option.."a "..console.result.."'", 'ls', {console.option..'a', console.result})

    function console.ls(player, path, filter, display_functions, display_objects, display_variables, display_tables, recursions_left, indent)
        local text = ''
        local indent = indent or ''
        local node, id, parent, found, location, hidden = console.node_from_path(path)
        local paths = {}
        if node ~= nil and (found or hidden) then
            if type(node) == 'table' then
                local tables = {}
                local entries = {}
                for k, v in pairs(node) do
                    if (node ~= _G or (not hidden and not console.is_hidden(k)) or (hidden and hidden[k])) and (filter == nil or k:match(filter)) then
                        if type(v) == 'table' then
                            local t = console.table_bb .. k .. '[-]'
                            table.insert(tables, t)
                            paths[t] = path .. console.seperator .. k
                        else
                            if type(v) == 'function' then
                                if display_functions then
                                    table.insert(entries, console.function_bb .. k .. '[-]()')
                                end
                            elseif type(v) == 'userdata' then
                                if display_objects then
                                    local tag = tostring(v)
                                    if tag:find('(LuaGameObjectScript)') and not tag:gsub('(LuaGameObjectScript)',''):find('Script ') then
                                        tag = v.tag .. ' ' .. console.format_guid(v.getGUID())
                                    end
                                    if type(k) == 'number' and math.floor(k) == k then k = string.format('%04d', k) end
                                    table.insert(entries, console.object_bb .. k .. '[-]: '  .. tag)
                                end
                            elseif display_variables then
                                if type(v) == 'boolean' then
                                    if v then
                                        v = 'true'
                                    else
                                        v = 'false'
                                    end
                                    table.insert(entries, k .. ': ' .. console.boolean_bb .. v .. '[-]')
                                else
                                    local is_guid = false
                                    if type(v) == 'string' then
                                        if v:len()> console.crop_string_at then v = v:sub(1, console.crop_string_at):gsub('\n', ' ') .. '...' end
                                        if type(k) == 'string' and k:lower():find('guid') and v:len() == 6 then
                                            is_guid = true
                                        end
                                    end
                                    if is_guid then
                                        table.insert(entries, k .. ': ' .. console.format_guid(v) .. '[-]')
                                    else
                                        table.insert(entries, k .. ': ' .. console.value_bb .. console.escape_bb(v) .. '[-]')
                                    end
                                end
                            end
                        end
                    end
                end
                local cmp = function (a, b)
                    if not a then
                        return true
                    elseif not b then
                        return false
                    else
                        local la = a:len()
                        local lb = b:len()
                        local c = 1
                        repeat
                            if c > la and c <= lb then
                                return true
                            elseif c > lb and c <= la then
                                return false
                            elseif c > la then
                                return false
                            else
                                local ba = a:sub(c, c):byte()
                                local bb = b:sub(c, c):byte()
                                if ba < bb then
                                    return true
                                elseif bb < ba then
                                    return false
                                end
                            end
                            c = c + 1
                        until false
                    end
                end
                table.sort(tables, cmp)
                table.sort(entries, cmp)
                local cr = ''
                if display_tables then
                    for i, t in ipairs(tables) do
                        text = text .. cr .. indent .. t .. console.seperator
                        if recursions_left ~= 0 then
                            text = text .. '\n' .. console.ls(player, paths[t], filter,
                                display_functions, display_objects, display_variables, display_tables,
                                recursions_left-1, indent..console.indent)
                        end
                        cr = '\n'
                    end
                    if node == _G and not hidden then
                        for label, _ in pairs(console.hidden_globals) do
                            if (filter == nil or label:match(filter)) then -- and label ~= console.builtin_path
                                text = text .. cr .. indent .. console.hidden_bb .. label .. console.seperator .. '[-]'
                                cr = '\n'
                            end
                        end
                    end
                end
                for _, entry in ipairs(entries) do
                    text = text .. cr .. indent .. entry
                    cr = '\n'
                end
            elseif type(node) == 'userdata' then
                local tag = tostring(node)
                if tag ~= 'null' and tag:find('(LuaGameObjectScript)') and not tag:gsub('(LuaGameObjectScript)',''):find('Script ') then
                    tag = node.tag .. ' ' .. console.format_guid(node.getGUID())
                end
                text = indent .. console.object_bb .. id .. '[-]: ' .. tag
            elseif type(node) == 'function' then
                text = indent .. console.function_bb .. id .. '[-]()'
            elseif type(node) == 'boolean' then
                if node then
                    text = indent .. id .. ': ' .. console.boolean_bb .. 'true[-]'
                else
                    text = indent .. id .. ': ' .. console.boolean_bb .. 'false[-]'
                end
            else
                if type(id) == 'string' and id:lower():find('guid') and type(node) == 'string' and node:len() == 6 then
                    text = indent .. id .. ': ' .. console.format_guid(node) .. '[-]'
                else
                    text = indent .. id .. ': ' .. console.value_bb .. console.escape_bb(node) .. '[-]'
                end
            end
        else
            text = indent .. console.error_bb .. '<not found>[-]'
        end
        return text
    end

    console.add_admin_command('call', '<function> [<parameter>...]',
        'Call function with parameters and display result.',
        function (player, ...)
            local path = nil
            local parameters = {}
            for i, arg in ipairs({...}) do
                if i == 1 then
                    path = tostring(arg)
                else
                    if type(arg) == 'string' then
                        if arg:len() > 2 and arg:sub(1,1) == console.literal then
                            arg = arg:sub(2)
                        else
                            local node, id, parent, found = console.node_from_path(console.fill_path(arg))
                            if node ~= nil and found then
                                arg = node
                            end
                        end
                    end
                    table.insert(parameters, arg)
                end
            end
            if path == nil then
                return console.error_bb .. '<you must supply a function>[-]'
            end
            local location = console.fill_path(path)
            local node, id, parent, found, location = console.node_from_path(location)
            local text = nil
            if node ~= nil and found and type(node) == 'function' then
                console.returned_value = node(unpack(parameters))
                text = tostring(console.returned_value)
                if console.deferred_assignment then
                    local da = console.deferred_assignment
                    if da.command == 'set' then
                        if da.parent[da.id] ~= nil then
                            if da.force or type(console.returned_value) == type(da.parent[da.id]) then
                                da.parent[da.id] = console.returned_value
                                text = text .. '\n' .. console.header_bb .. "<set '" .. da.id .. "'>[-]"
                            else
                                text = text .. '\n' .. console.error_bb .. "<cannot set '" .. da.id .. "': it is of type '" .. type(da.parent[da.id]) .. "'>[-]"
                            end
                        else
                            text = text .. '\n' .. console.error_bb .. "<cannot set '" .. da.id .. "': it does not exist>[-]"
                        end
                    elseif da.command == 'add' then
                        if da.parent[da.id] == nil then
                            da.parent[da.id] = console.returned_value
                            text = text .. '\n' .. console.header_bb .. "<added '" .. da.id .. "'>[-]"
                        else
                            text = text .. '\n' .. "<cannot add '" .. da.id .. "': it already exists>[-]"
                        end
                    end
                    console.deferred_assignment = nil
                end
            else
                text = console.error_bb .. '<not found>[-]'
            end
            return text, false
        end
    )

    console.add_admin_command('set', '['..console.option..'f] <variable> [<value>]',
        "Set variable to value.  If no value specified then the next value returned from 'call' is used.\n" ..
            console.option ..'f  force overwrite ignoring type',
        function (player, ...)
            local variable = nil
            local value = nil
            local force = false
            for _, arg in ipairs({...}) do
                if type(arg) == 'string' and arg:len() > 1 and arg:sub(1, 1) == console.option then
                    local c = 2
                    while c <= arg:len() do
                        local option = arg:sub(c, c)
                        if option == "f" then
                            force = not force
                        else
                            return console.error_bb .. "<option '" .. option .. "' not recognized>[-]"
                        end
                        c = c + 1
                    end
                elseif variable == nil then
                    variable = tostring(arg)
                else
                    value = arg
                end
            end
            if variable == nil then
                return console.error_bb .. '<you must supply a variable>[-]'
            end
            variable = console.fill_path(variable)
            local node, id, parent, found = console.node_from_path(variable)
            local text = ''
            if node ~= nil and found then
                if value == nil then
                    console.deferred_assignment = {command = 'set', parent = parent, id = id, force = force}
                    text = id .. ': ' .. console.header_bb .. "<awaiting 'call'>[-]"
                else
                    console.deferred_assignment = nil
                    if type(value) == 'string' and value:len() > 0  then
                        if value:sub(1, 1) == console.literal then
                            value = value:sub(2)
                        else
                            local value_node, value_id, value_parent, value_found = console.node_from_path(value)
                            if value_node ~= nil and value_found then
                                value = value_node
                            else
                                return console.error_bb .. '<not found>[-]'
                            end
                        end
                    end
                    if type(node) == 'boolean' then
                        if not value or tostring(value):lower() == 'false' then
                            value = false
                        else
                            value = true
                        end
                    end
                    if type(node) == type(value) or force then
                        parent[id] = value
                        text = id .. ': ' .. console.value_bb .. tostring(parent[id]) .. '[-]'
                    else
                        return console.error_bb .. "<cannot set '" .. id .. "': it is of type '" .. type(node) .. "'>[-]"
                    end
                end
            else
                text = console.error_bb .. '<not found>[-]'
            end
            return text
        end
    )

    console.add_admin_command('toggle', '<boolean>',
        'Toggle specified boolean variable',
        function (player, variable)
            if variable == nil then
                return console.error_bb .. '<you must supply variable>'
            else
                variable = tostring(variable)
            end
            local variable = console.fill_path(variable)
            local node, id, parent, found = console.node_from_path(variable)
            local text = ''
            if node ~= nil and found then
                if type(node) == 'boolean' then
                    if node then
                        parent[id] = false
                        text = id .. ': ' .. console.value_bb .. 'false[-]'
                    else
                        parent[id] = true
                        text = id .. ': ' .. console.value_bb .. 'true[-]'
                    end
                else
                    text = console.error_bb .. '<can only toggle a boolean>[-]'
                end
            else
                text = console.error_bb .. '<not found>[-]'
            end
            return text
        end
    )
    console.add_admin_command('tgl', nil, nil, 'toggle')

    console.add_admin_command('rm', '<variable>',
        'Remove specified variable',
        function (player, variable)
            if variable == nil then
                return console.error_bb .. '<you must supply variable>'
            else
                variable = tostring(variable)
            end
            local variable = console.fill_path(variable)
            local node, id, parent, found = console.node_from_path(variable)
            local text = ''
            if node ~= nil and found then
                parent[id] = nil
                text = id .. " removed!"
            else
                text = console.error_bb .. '<not found>[-]'
            end
            return text
        end
    )
    console.add_admin_command('del', nil, nil, 'rm')

    console.add_admin_command('add', '<variable> [<value>]',
        "Create a variable set to value.   If no value specified then the next value returned from 'call' is used.",
        function (player, variable, value)
            if variable == nil then
                return console.error_bb .. '<you must supply variable>[-]'
            else
                variable = tostring(variable)
            end
            local variable = console.fill_path(variable)
            local node, id, parent, found = console.node_from_path(variable)
            local text = ''
            if found then
                return console.error_bb .. '<already exists>[-]'
            elseif node == nil or id == '' then
                return console.error_bb .. '<not found>[-]'
            else
                if value == nil then
                    console.deferred_assignment = {command = 'add', parent = node, id = id}
                    text = id .. ': ' .. console.header_bb .. "<awaiting 'call'>[-]"
                else
                    console.deferred_assignment = nil
                    if type(value) == 'string' and value:len() > 0  then
                        if value:sub(1, 1) == console.literal then
                            value = value:sub(2)
                        else
                            local value_node, value_id, value_parent, value_found = console.node_from_path(value)
                            if value_node ~= nil and value_found then
                                value = value_node
                            else
                                return console.error_bb .. '<not found>[-]'
                            end
                        end
                    end
                    node[id] = value
                    text = id .. ': ' .. console.value_bb .. tostring(value) .. '[-]'
                end
            end
            return text
        end
    )

    console.add_admin_command('exec', '['..console.option..'?qsv] <commands>',
        'Execute a series of commands held in a string: commands are seperated by a new line or '..console.command_seperator,
        function (player, ...)
            local help_details = console.option..'q    quiet: will not output anything except final output\n' ..
                                 console.option..'s    silent: will not output anything at all\n'..
                                 console.option..'v    verbose: will output commands as they execute\n'
            local commands = nil
            local verbose = false
            local quiet = false
            local silent = false
            for _, arg in ipairs({...}) do
                if type(arg) == 'string' and arg:len() > 1 and arg:sub(1,1) == console.option then
                    local c = 2
                    while c <= arg:len() do
                        local option = arg:sub(c,c)
                        if option == '?' then
                            return help_details
                        elseif option == 'q' then
                            quiet = not quiet
                        elseif option == 's' then
                            silent = not silent
                        elseif option == 'v' then
                            verbose = not verbose
                        else
                            return console.error_bb .. "<option '" .. option .. "' not recognized>"
                        end
                        c = c + 1
                    end
                elseif commands == nil then
                    commands = tostring(arg)
                end
            end
            if silent then quiet = true end
            if commands:len() > 1 and commands:sub(1, 1) == console.literal then
                commands = commands:sub(2)
            else
                local variable = console.fill_path(commands)
                local node, id, parent, found = console.node_from_path(variable)
                if node ~= nil and found then
                    commands = node
                else
                    return console.error_bb .. '<not found>[-]'
                end
            end
            if commands:find('\n') then
                commands = console.split(commands, '\n')
            else
                commands = console.split(commands, console.command_seperator)
            end
            local end_result = nil
            for _, command_text in ipairs(commands) do
                local command = ''
                local command_function = nil
                local parameters = {player}
                local requires_admin = false
                command, command_function, parameters, requires_admin = console.get_command(command_text, player)
                if command ~= '' then
                    if command_function and (player.admin or not requires_admin) then
                        local response, mute = command_function(unpack(parameters))
                        if response ~= nil or mute ~= nil then
                            if not mute and verbose and not quiet then
                                printToColor('\n'..command_text, player.color, console.command_color)
                            end
                            if response then
                                end_result = response
                                if not quiet then
                                    printToColor(response, player.color, console.output_color)
                                end
                            end
                        end
                    elseif not quiet then
                        if verbose then printToColor('\n'..command_text, player.color, console.command_color) end
                        printToColor(console.error_bb .. "<command '" .. command .. "' not found>[-]", player.color, console.output_color)
                    end
                end
            end
            if end_result and not silent then
                printToColor(end_result, player.color, console.output_color)
            end
        end
    )

    console.add_admin_command('watch', '['..console.option..'?cgp] ['..console.option..'t#] ['..console.option..console.seperator..'<property>] [<variable>]',
        'Watch a variable or object and display it whenever it changes.\n' .. console.hidden_bb ..
        'Requires you to add a '..console.function_bb..'console.update()[-] call to an ' ..
        console.function_bb .. 'onUpdate[-] event in your code.[-]\n',
        function (player, ...)
            local help_details = 'Call without a parameter to display watched items, or with a variable to add it to watch list.\n' ..
                                console.option..'c will clear variable if specified, or all.\n' ..
                                console.option..'g will let you specify an object by its GUID.\n' ..
                                console.option..'t# will throttle output to # seconds.\n' ..
                                console.option..console.seperator..'<property> will watch the property of the variable.\n' ..
                                console.option..'p will pause or unpause watching.\n'
            local path = nil
            local clearing = false
            local throttle = nil
            local pause_changed = false
            local by_guid = false
            local parameters = {}
            local labels = {}
            local property = nil
            for _, arg in ipairs({...}) do
                if type(arg) == 'string' and arg:len() > 1 and arg:sub(1,1) == console.option then
                    local c = 2
                    while c <= arg:len() do
                        local option = arg:sub(c,c)
                        if option == '?' then
                            return help_details
                        elseif option == 'c' then
                            clearing = not clearing
                        elseif option == 'p' then
                            pause_changed = not pause_changed
                        elseif option == 'g' then
                            by_guid = not by_guid
                        elseif option == console.seperator then
                            if arg:len() > c then
                                property = arg:sub(c + 1)
                                c = arg:len() + 1
                            end
                        elseif option == 't' then
                            local n = ''
                            local j = c + 1
                            while j <= arg:len() do
                                local char = arg:sub(j, j)
                                if char:match('[0-9.]') then
                                    n = n .. char
                                else
                                    break
                                end
                                j = j + 1
                            end
                            c = j - 1
                            if n == '' then
                                return console.error_bb .. '<you must provide a throttle duration (in seconds)>[-]'
                            else
                                throttle = tonumber(n)
                            end
                        else
                            return console.error_bb .. "<option '" .. option .. "' not recognized>"
                        end
                        c = c + 1
                    end
                else
                    if path == nil then
                        path = tostring(arg)
                    else
                        local label = tostring(arg)
                        if type(arg) == 'string' then
                            if arg:len() > 2 and arg:sub(1,1) == console.literal then
                                arg = arg:sub(2)
                                label = arg
                            else
                                local node, id, parent, found = console.node_from_path(console.fill_path(arg))
                                if node ~= nil and found then
                                    arg = node
                                end
                            end
                        end
                        table.insert(labels, label)
                        table.insert(parameters, arg)
                    end
                end
            end
            local text = ''
            if pause_changed then
                if console.watch_list_paused then
                    console.watch_list_paused = nil
                    text = text .. console.header_bb .. '<unpaused>[-]'
                else
                    console.watch_list_paused = true
                    text = text .. console.header_bb .. '<paused>[-]'
                end
            end
            if path == nil then
                if throttle ~= nil then
                    text = text .. '\n' .. console.error_bb .. '<you must provide a variable or object>[-]'
                elseif by_guid then
                    text = text .. '\n' .. console.error_bb .. '<you must provide a GUID>[-]'
                elseif clearing then
                    console.watch_list = nil
                    console.watch_list_paused = nil
                    text = text .. '\nWatch list cleared!'
                elseif not pause_changed then
                    if console.watch_list then
                        local watched = {}
                        for label, watch in pairs(console.watch_list) do
                            if watch.player == player.color then
                                table.insert(watched, label)
                            end
                        end
                        table.sort(watched)
                        text = text .. '\n'..console.header_bb..'Watching:[-]'
                        for _, label in ipairs(watched) do
                            local watch = console.watch_list[label]
                            local is_guid = (label:len() == 6 and label:sub(1,1) ~= console.seperator)
                            local node, id, parent, found
                            local prefix
                            text = text .. '\n'
                            if is_guid then
                                prefix =  console.format_guid(label)
                                node = getObjectFromGUID(label)
                                found = tostring(node) ~= 'null'
                            else
                                prefix = label
                                node, id, parent, found = console.node_from_path(label)
                            end
                            if node ~= nil and found then
                                if type(node) == 'userdata' then
                                    prefix = console.object_bb .. prefix .. '[-]'
                                    local position = node.getPosition()
                                    local rotation = node.getRotation()
                                    local p = function (x) return math.floor(x * 100) * 0.01 end
                                    local r = function (x) return math.floor(x + 0.5) end
                                    text = text .. prefix .. console.value_bb .. '  '..r(rotation.x)..' '..r(rotation.y)..' '..r(rotation.z) .. '[-]'..
                                            console.boolean_bb..'     '..p(position.x)..'   '..p(position.y)..'   '..p(position.z)
                                elseif type(node) == 'function' then
                                    local result = node(unpack(console.watch_list[label].parameters))
                                    if watch.property and (type(result) == 'table' or type(result) == 'userdata') then
                                        result = result[watch.property]
                                        if type(result) == 'function' then
                                            result = result()
                                        end
                                    end
                                    result = tostring(result)
                                    if watch.propery and watch.property:lower():find('guid') then
                                        result = console.format_guid(result)
                                    end
                                    if result:len() > console.crop_string_at then result = result:sub(1, console.crop_string_at) .. '...' end
                                    text = text .. watch.label .. console.value_bb .. result .. '[-]'
                                else
                                    if type(node) == 'boolean' then
                                        if node then
                                            node = 'true'
                                        else
                                            node = 'false'
                                        end
                                    elseif type(node) == 'string' then
                                        if node:len() > console.crop_string_at then node = node:sub(1, console.crop_string_at):gsub('\n', ' ') .. '...' end
                                    end
                                    text = text .. prefix .. ': ' .. console.value_bb .. node .. '[-]'
                                end
                            end
                        end
                    else
                        text = text .. "\nWatch list is empty."
                    end
                end
            else
                if not by_guid then
                    path = console.fill_path(path)
                end
                if clearing then
                    local node, id, parent, found
                    if not by_guid then
                        node, id, parent, found, path = console.node_from_path(path)
                    end
                    if console.watch_list[path] then
                        console.watch_list[path] = nil
                        if next(console.watch_list) == nil then
                            console.watch_list = nil
                        end
                        text = text .. '\n' .. console.header_bb.. 'No longer watching:[-] ' .. path
                    else
                        text = text .. '\n' .. console.error_bb .. '<not found>[-]'
                    end
                else
                    local node, id, parent, found
                    if by_guid then
                        node = getObjectFromGUID(path)
                        found = tostring(node) ~= 'null'
                    else
                        node, id, parent, found, path = console.node_from_path(path)
                    end
                    if node ~= nil and found then
                        if console.watch_list == nil then console.watch_list = {} end
                        if throttle == nil then throttle = 0 end
                        console.watch_list[path] = {player=player.color, throttle=throttle, last_check=0, property=property}
                        if type(node) == 'userdata' then
                            console.watch_list[path].position = node.getPosition()
                            console.watch_list[path].rotation = node.getRotation()
                            console.watch_list[path].is_guid  = by_guid
                        elseif type(node) == 'function' then
                            console.watch_list[path].parameters = parameters
                            console.watch_list[path].value = node
                            console.watch_list[path].label = console.function_bb .. path .. '[-]'
                            if property then
                                console.watch_list[path].label = console.watch_list[path].label .. console.seperator .. property
                            end
                            for _, label in ipairs(labels) do
                                console.watch_list[path].label = console.watch_list[path].label .. ' ' .. console.hidden_bb .. label .. '[-]'
                            end
                            console.watch_list[path].label = console.watch_list[path].label .. ': '
                        else
                            console.watch_list[path].value = node
                        end
                        if by_guid then
                            path = console.format_guid(path)
                        end
                        text = text .. '\n' .. console.header_bb .. 'Watching:[-] ' .. path
                    else
                        text = text .. '\n' .. console.error_bb .. '<not found>[-]'
                    end
                end
            end
            if text:len() > 1 and text:sub(1, 1) == '\n' then
                text = text:sub(2)
            end
            return text
        end
    )

    console.add_player_command('shout', '<text>',
        'Broadcast <text> to all players. Colour a section with {RRGGBB}section{-}.',
        function (player, ...)
            local text = player.steam_name .. ': '
            local space = ''
            for _, word in ipairs({...}) do
                text = text .. space .. tostring(word)
                space = ' '
            end
            text = text:gsub('{','[')
            text = text:gsub('}',']')
            broadcastToAll(text, stringColorToRGB(player.color))
            return nil, false
        end
    )

    -- change the command help color so client added commands appear different to console++
    console.set_command_listing_bb('[A0F0C0]')
end

end)
__bundle_register("Console/console", function(require, _LOADED, __bundle_register, __bundle_modules)
if not console then
    console = {}

    -- Change these values as you wish
    console.command_char = '>'
    console.option       = '-'
    console.prompt_color  = {r = 0.8,  g = 1.0,  b = 0.8 }
    console.command_color = {r = 0.8,  g = 0.6,  b = 0.8 }
    console.output_color  = {r = 0.88, g = 0.88, b = 0.88}
    console.invalid_color = {r = 1.0,  g = 0.2,  b = 0.2 }
    console.header_bb       = '[EECCAA]'
    console.error_bb        = '[FF9999]'
    console.inbuilt_help_bb = '[E0E0E0]'
    console.client_help_bb  = '[C0C0FF]'

    -- Exposed methods:

    function console.add_validation_function(validation_function)
        -- Adds a validation function all chat will be checked against:
        -- function(string message) which returns (boolean valid, string response)
        -- If all validation functions return <valid> as true the message will be displayed.
        -- If one returns <valid> as false then its <response> will be displayed to that player instead.
        table.insert(console.validation_functions, validation_function)
    end

    function console.add_player_command(command, parameter_text, help_text, command_function, default_parameters)
        -- Adds a command anyone can use, see below for details
        console.add_command(command, false, parameter_text, help_text, command_function, default_parameters)
    end

    function console.add_admin_command(command, parameter_text, help_text, command_function, default_parameters)
        -- Adds a command only admins can use, see below for details
        console.add_command(command, true, parameter_text, help_text, command_function, default_parameters)
    end

    function console.add_command(command, requires_admin, parameter_text, help_text, command_function, default_parameters)
        -- Adds a command to the console.
        -- command_function must take <player> as its first argument, and then any
        --   subsequent arguments you wish which will be provided by the player.
        -- You may alias an already-present command by calling this with command_function set to
        --   the command string instead of a function.  default_parameters can be set for the alias.
        -- See basic built-in commands at the bottom of this file for examples.
        local commands = console.commands
        local command_function = command_function
        local help_text = help_text
        local parameter_text = parameter_text
        if type(command_function) == 'string' then --alias
            if help_text == nil then
                help_text = commands[command_function].help_text
            end
            if parameter_text == nil then
                parameter_text = commands[command_function].parameter_text
            end
            command_function = commands[command_function].command_function
        end
        console.commands[command] = {
            command_function   = command_function,
            requires_admin     = requires_admin,
            parameter_text     = parameter_text,
            help_text          = help_text,
            help_bb            = console.command_help_bb,
            default_parameters = default_parameters,
        }
    end

    function console.set_command_listing_bb(bb)
        -- Tags commands added after with a bb color for when they are displayed (i.e. with 'help')
        console.command_help_bb = bb
    end

    function console.disable()
        -- Disables console for command purposes, but leaves validation functions running
        console.active = false
    end

    function console.enable()
        -- Enables console commands (console commands are on by default)
        console.active = true
    end

    -- End of exposed methods.  You shouldn't need to interact with anything below (under normal circumstances)


    console.active = true
    console.in_command_mode = {}
    console.commands = {}
    console.validation_functions = {}
    console.set_command_listing_bb(console.inbuilt_help_bb)

    function onChat(message, player)
        if message ~= '' then
            local command = ''
            local command_function = nil
            local parameters = {player}
            local requires_admin = false
            local command_mode = console.in_command_mode[player.steam_id]
            if command_mode and console.active then
                command, command_function, parameters, requires_admin = console.get_command(message, player)
            elseif message:sub(1, 1) == console.command_char and console.active then
                if message:len() > 1 then
                    command, command_function, parameters, requires_admin = console.get_command(message:sub(2), player)
                else
                    command, command_function, parameters, requires_admin = console.get_command(console.command_char, player)
                end
            else
                for i, f in ipairs(console.validation_functions) do
                    local valid, response = f(message)
                    if response == nil then response = '' end
                    if not valid then
                        printToColor(response, player.color, console.invalid_color)
                        return false
                    end
                end
                return true
            end
            if console.active then
                if command_function and (player.admin or not requires_admin) then
                    if command_mode then
                        message = console.command_char .. console.command_char .. message
                    end
                    local response, mute = command_function(unpack(parameters))
                    if response ~= nil or mute ~= nil then
                        if not mute then
                            printToColor('\n'..message, player.color, console.command_color)
                        end
                        if response then
                            printToColor(response, player.color, console.output_color)
                        end
                    end
                    if console.in_command_mode[player.steam_id] then console.display_prompt(player) end
                    return false
                else
                    printToColor('\n'..message, player.color, console.command_color)
                    printToColor(console.error_bb .. "<command '" .. command .. "' not found>[-]", player.color, console.output_color)
                    return false
                end
            end
        end
    end

    function console.get_command(message, player)
        local command_name = ''
        local command_function = nil
        local requires_admin = false
        local parameters = {player}
        for i, part in ipairs(console.split(message)) do
            if i == 1 then
                command_name = part
                local command = console.commands[command_name]
                if command then
                    command_function = command.command_function
                    requires_admin = command.requires_admin
                    if command.default_parameters then
                        for _, parameter in ipairs(command.default_parameters) do
                            table.insert(parameters, parameter)
                        end
                    end
                end
            else
                table.insert(parameters, part)
            end
        end
        return command_name, command_function, parameters, requires_admin
    end

    function console.display_prompt(player)
        printToColor(console.command_char..console.command_char, player.color, console.prompt_color)
    end

    function console.split(text, split_on)
        local split_on = split_on or ' '
        if type(split_on) == 'string' then
            local s = {}
            for c = 1, split_on:len() do
                s[split_on:sub(c,c)] = true
            end
            split_on = s
        end
        local parts = {}
        if text ~= '' then
            local make_table = function(s)
                local entries = console.split(s, ' ,')
                local t = {}
                for _, entry in ipairs(entries) do
                    if type(entry) == 'string' and entry:find('=') then
                        e = console.split(entry, '=')
                        t[e[1]] = e[2]
                    else
                        table.insert(t, entry)
                    end
                end
                return t
            end
            local current_split_on = split_on
            local adding = false
            local part = ""
            local totype = tonumber
            for c = 1, text:len() do
                local char = text:sub(c, c)
                if adding then
                    if current_split_on[char] then -- ended current part
                        if totype(part) ~= nil then
                            table.insert(parts, totype(part))
                        else
                            table.insert(parts, part)
                        end
                        adding = false
                        current_split_on = split_on
                        totype = tonumber
                    else
                        part = part .. char
                    end
                else
                    if not current_split_on[char] then -- found start of part
                        if char == "'" then
                            current_split_on = {["'"] = true}
                            totype = tostring
                            part = ''
                        elseif char == '"' then
                            current_split_on = {['"'] = true}
                            totype = tostring
                            part = ''
                        elseif char == '{' then
                            current_split_on = {['}'] = true}
                            totype = make_table
                            part = ''
                        else
                            part = char
                        end
                        adding = true
                    end
                end
            end
            if adding then
                if totype(part) ~= nil then
                    table.insert(parts, totype(part))
                else
                    table.insert(parts, part)
                end
            end
        end
        return parts
    end


    -- Add basic built-in console commands

    console.add_player_command('help', '[' .. console.option .. 'all|<command>]',
        'Display available commands or help on all commands or help on a specific command.',
        function (player, command)
            if command ~= nil then
                command = tostring(command)
            end
            local make_help = function (command)
                return console.header_bb .. command .. ' ' .. console.commands[command].parameter_text ..
                        '[-]\n' .. console.commands[command].help_text
            end
            local info_mode = false
            if command == console.option..'all' then
                info_mode = true
            end
            if command and console.commands[command] then
                return make_help(command)
            elseif command and not info_mode then
                return console.error_bb .. "<command '" .. command .. "' not found>[-]"
            else
                local msg = console.header_bb .. 'Available commands:[-]'
                local command_list = {}
                for c, _ in pairs(console.commands) do
                    if player.admin or not console.commands[c].requires_admin then
                        if info_mode then
                            table.insert(command_list, make_help(c))
                        else
                            table.insert(command_list, c)
                        end
                    end
                end
                table.sort(command_list)
                local sep
                if info_mode then
                    sep = '\n\n'
                else
                    sep = '\n'
                end
                for _, c in ipairs(command_list) do
                    local cmd = console.commands[c]
                    if cmd then
                        msg = msg .. sep .. cmd.help_bb .. c .. '[-]'
                    else
                        msg = msg .. sep .. c
                    end
                    if not info_mode then sep = ', ' end
                end
                return msg
            end
        end
    )
    console.add_player_command('?', nil, nil, 'help')
    console.add_player_command('info', '', 'Display help on all available commands.', 'help', {console.option..'all'})

    console.add_player_command('exit', '',
        "Leave <command mode> ('" .. console.command_char .. "' does the same).",
        function (player)
            console.in_command_mode[player.steam_id] = nil
            return console.header_bb .. '<command mode: off>[-]'
        end
    )

    console.add_player_command('cmd', '',
        "Enter <command mode> ('" .. console.command_char .. "' does the same).",
        function (player)
            console.in_command_mode[player.steam_id] = true
            return console.header_bb .. '<command mode: on>[-]'
        end
    )

    console.add_player_command(console.command_char, '',
        'Toggle <command mode>',
        function (player)
            console.in_command_mode[player.steam_id] = not console.in_command_mode[player.steam_id]
            if console.in_command_mode[player.steam_id] then
                return console.header_bb .. '<command mode: on>[-]', true
            else
                return console.header_bb .. '<command mode: off>[-]', true
            end
        end
    )

    console.add_player_command('=', '<expression>',
        'Evaluate an expression',
        function (player, ...)
            local expression = ''
            for _, arg in ipairs({...}) do
                expression = expression .. ' ' .. tostring(arg)
            end
            if not player.admin then
                expression = expression:gasub('[a-zA-Z~]', '')
            end
            console.returned_value = dynamic.eval(expression)
            return console.returned_value
        end
    )

    console.add_player_command('echo', '<text>',
        'Display text on screen',
        function (player, ...)
            local text = ''
            for _, arg in ipairs({...}) do
                text = text .. ' ' .. tostring(arg)
            end
            printToColor(text, player.color, console.output_color)
            return false
        end
    )

    console.add_player_command('cls', '',
        'Clear console text',
        function (player)
            return '\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n' ..
                   '\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'
        end
    )

    console.add_player_command('alias', '<alias> <command> [<parameter>...]',
        'Create a command alias.',
        function (player, ...)
            local alias
            local command
            local parameters = {}
            for i, arg in ipairs({...}) do
                if i == 1 then
                    alias = tostring(arg)
                elseif i == 2 then
                    command = tostring(arg)
                else
                    table.insert(parameters, arg)
                end
            end
            if not alias then
                return console.error_bb .. '<must provide an alias>[-]'
            --elseif console.commands[alias] ~= nil then
            --    return console.error_bb .. "<command '" .. alias .. "' already exists!>[-]"
            elseif command == nil then
                return console.error_bb .. "<must provide a command>[-]"
            elseif console.commands[command] == nil then
                return console.error_bb .. "<command '" .. command .. "' does not exist>[-]"
            else
                local text = console.header_bb .. alias .. '[-] = ' .. command
                local help_text = console.commands[command].help_text
                if not help_text:find('\nAliased to: ') then
                    help_text = help_text .. '\nAliased to: ' .. command
                end
                local combined_parameters = {}
                if console.commands[command].default_parameters then
                    for _, parameter in ipairs(console.commands[command].default_parameters) do
                        table.insert(combined_parameters, parameter)
                    end
                end
                for _, parameter in ipairs(parameters) do
                    table.insert(combined_parameters, parameter)
                    text = text .. ' ' .. parameter
                    help_text = help_text .. ' ' .. parameter
                end
                console.add_command(alias, console.commands[command].requires_admin, console.commands[command].parameter_text, help_text, command, combined_parameters)
                return text
            end
        end
    )

    -- change the command help color so client added commands appear different to in-built
    console.set_command_listing_bb(console.client_help_bb)
end

end)
return __bundle_require("Global.-1.lua")