-- #region IMPORTS ~
local DIR = require("kingsdilemma.core.director")
local P = require("kingsdilemma.core.players")
local O = require("kingsdilemma.lib.objects")
local C = require("kingsdilemma.lib.constants")
local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
-- local HouseScreen = require("kingsdilemma.objs.p3screen")
local L = require("kingsdilemma.core.lighting")
-- local V = require("kingsdilemma.core.voting")
-- local OU = require("kingsdilemma.objects.objUtilities")
local MSG = require("kingsdilemma.core.messaging")
-- #endregion

MessageQueue, QueueStatus = {}, {}

local TESTFUNCDEFS = {
	ControlHUD = DIR.InitControlPanel
}
local TESTFUNCS = {}
function InitTestFuncButtons()
	local testFuncNames = U.getKeys(TESTFUNCDEFS)
	for i = 1, 5 do
		local funcName = testFuncNames[i]
		if funcName == nil then
			UI.setAttribute("debug_testFunc" .. i, "active", "false")
		else
			UI.setAttributes("debug_testFunc" .. i, {
				active = "true",
				text = "  T: " .. funcName,
				colors = "#666666|#AAAAAA|#FFFFFF|rgba(0.5, 0.5, 0.5, 0.5)",
				textAlignment = "MiddleLeft"
			})
		end
	end
	TESTFUNCS = U.getValues(TESTFUNCDEFS)
end

function UpdatePhaseDisplay()
	local mode, phase = S.getStateVal("gameState", "gameMode"), S.getStateVal("gameState", "gamePhase")
	UI.setValue("currentGameModeDisplay", mode)
	if mode ~= phase then
		UI.setValue("currentGamePhaseDisplay", phase)
		MSG.Show("currentGamePhaseContainer")
	else
		MSG.Hide("currentGamePhaseContainer")
	end
	local nextMode, nextPhase = S.getNextPhase()
	UI.setValue("nextGameModeDisplay", nextMode)
	if nextMode ~= nextPhase then
		UI.setValue("nextGamePhaseDisplay", nextPhase)
		MSG.Show("nextGamePhaseContainer")
	else
		MSG.Hide("nextGamePhaseContainer")
	end
end

-- #region Primary UI Event Functions
local captureRow = -1
local function toggleXmlElement(elemID, button)
	-- log("Toggling " .. elemID)
	if elemID == "stateDisplayPanel" then
		S.refreshStateDebug()
		toggleXmlElement("stateDisplayPanel_1", button)
		toggleXmlElement("stateDisplayPanel_2", button)
		toggleXmlElement("stateDisplayPanel_3", button)
		toggleXmlElement("stateDisplayPanel_4", button)
		return
	end

	if string.lower(UI.getAttribute(elemID, "active")) == "false" then
		UI.setAttribute(elemID, "active", "true")
		if elemID == "debugControls" then
			MSG.Hide("splashScreen")
			if button ~= "-2" then
				Lighting.ambient_intensity = 1.5
				Lighting.ambient_type = 1
			end
		end
		UI.setAttribute("toggleElem_" .. elemID, "text", "▼")
	else
		UI.setAttribute(elemID, "active", "false")
		if elemID == "debugControls" then
			Lighting.ambient_intensity = 0
		end
		UI.setAttribute("toggleElem_" .. elemID, "text", "►")
	end
end

local function getPlayerList(excludePlayerRefs)
	if excludePlayerRefs == nil then excludePlayerRefs = {} end
	excludePlayerRefs = U.map(excludePlayerRefs, function(playerRef)
		if U.isIn(playerRef, Player.getColors()) then
			return playerRef
		else
			local player = S.getPlayer(playerRef)
			if player then return player.color end
			return playerRef
		end
	end)
	local players = U.filter(S.getPlayers(), function(player) return not U.isIn(player.color, excludePlayerRefs) end)
	return U.iMap(players, function(pl, i)
		return "#" .. i .. " " .. pl.color .. " (" .. pl.steam_name .. ")"
	end)
end

local function promptSimClick(player, button)
	local players = S.getPlayers()
	if button == "-2" then
		local otherColors = U.map(U.filter(players, function(pl)
			return pl.color ~= player.color
		end), function(pl) return pl.color end)
		log("Simulating clicks on " .. U.join(otherColors, ", "))
		local houses = U.shuffle(U.clone(C.Houses))
		for _, col in pairs(otherColors) do
			local clickElemID = "houseHUD_Button_" .. U.shift(houses)
			log("Simulating " .. col .. " Player clicking '" .. clickElemID .. "'")
			House_HUD_Click(Player[col], "-1", clickElemID)
		end
	else
		player.showOptionsDialog("Which player is clicking?", getPlayerList(), 1, function(_, i)
			local targetPlayer = players[i]
			player.showOptionsDialog("Which territory?", C.Houses, 1, function(houseName)
				if houseName == nil then return end
				local clickElemID = "houseHUD_Button_" .. houseName
				log("Simulating " .. targetPlayer.color .. " Player clicking '" .. clickElemID .. "'")
				House_HUD_Click(targetPlayer, "-1", clickElemID)
			end)
		end)
	end
end
local function promptGivePower()
	local players = S.getPlayers()
	U.getHost().showOptionsDialog("Give Power to Which Player?", getPlayerList(), 1, function(_, i)
		local targetPlayer = players[i]
		U.getHost().showInputDialog(
			"How much Power?",
			"",
			function(amount)
				if amount == "" then return end
				amount = amount * 1
				if amount <= 0 then return end
				MSG.Splash("Giving " .. amount .. " Power to House " .. S.getPlayerHouseName(targetPlayer))
				P.SpawnPower(targetPlayer, amount)
			end
		)
	end
	)
end
local function promptGiveCoin()
	local players = S.getPlayers()
	U.getHost().showOptionsDialog("Give Coin to Which Player?", getPlayerList(), 1, function(_, i)
		local targetPlayer = players[i]
		U.getHost().showInputDialog(
			"How much Coin?",
			"",
			function(amount)
				if amount == "" then return end
				amount = amount * 1
				if amount <= 0 then return end
				MSG.Splash("Giving " .. amount .. " Coin to House " .. S.getPlayerHouseName(targetPlayer))
				P.SpawnCoins(targetPlayer, amount)
			end
		)
	end
	)
end
local function promptAssignHouseName(player)
	local players = S.getPlayers()
	player.showOptionsDialog("Name which player's house?", getPlayerList(), 1, function(_, i)
		local targetPlayer = players[i]
		player.showInputDialog(
			"What is their House Name?",
			S.getPlayerVal(targetPlayer, "house"),
			function(houseName)
				S.setPlayerVal(houseName, targetPlayer, "houseName")
				P.GetPlayerScreen(targetPlayer).call("UpdateXMLTable")
				P.GetPlayerScreen(targetPlayer).call("Activate")
			end)
	end)
end

function HUD_Click(player, button, id)
	if U.Type(player) == "table" then
		button = player.button
		id = player.id
		player = player.player
	end
	-- log({player = player, button = button, id = id})
	if string.match(id, "^splashQuery_Option") then
		local _, optionRef, color = table.unpack(U.split(id, "_"))
		local stringIndex = string.gsub(optionRef, "Option", "")
		MSG.QueryResponse(tonumber(stringIndex))
	elseif string.match(id, "^toggleElem_") then
		toggleXmlElement(string.gsub(id, "^toggleElem_", ""), button)
	elseif id == "initPreflight" then
		DIR.InitPreflight()
	elseif id == "initSession" then
		DIR.InitSession(button == "-2")
	elseif id == "advanceGamePhase" or id == "forceAdvanceGamePhase" then
		DIR.ADVANCE(nil, true)
	elseif id == "prompt_simClick" then
		promptSimClick(player, button)
	elseif id == "prompt_assignHouseName" then
		promptAssignHouseName(player)
	elseif id == "clearPlayers" then
		P.ClearSeats()
	elseif id == "transferToTestPlayers" then
		local players = Player.getPlayers()
		local storedData = U.filter(U.getValues(S.getStateVal("playerStorage")),
			function(sData) return not string.match(sData.id, "^Player") and sData.curColor ~= nil end)
		U.RunSequence({
			function()
				U.forEach(getObjectsWithTag("HouseCard"), function(obj) obj.setRotation(obj.getRotation():setAt("z", 180)) end)
				return U.sequence(U.map(players, function(player) return function() player.changeColor("Grey") end end), 0.5)
			end,
			function()
				local hostPlayer = U.pluck(players, function(player) return player.steam_name == "Eunomiac" end)
				if hostPlayer == nil then
					hostPlayer = U.pluck(players, function(player) return player.steam_name == "Player 0" end)
				end
				if hostPlayer == nil then
					hostPlayer = U.pluck(players, function(player) return player.steam_name == "Player 1" end)
				end
				if hostPlayer == nil then
					error("No player named 'Eunomiac', 'Player 0', or 'Player 1' found to be Host.")
				end
				hostPlayer.changeColor(S.getStateVal("playerStorage", C.AdminID, "curColor"))
				U.pluck(storedData,
					function(sData) return sData.curColor == S.getStateVal("playerStorage", C.AdminID, "curColor") end)
				if hostPlayer.steam_name ~= "Eunomiac" then
					local sData = S.getStateVal("playerStorage", C.AdminID)
					sData.id = hostPlayer.steam_name
					S.setStateVal(sData, "playerStorage", hostPlayer.steam_name)
				end
				return 0.5
			end,
			function()
				return U.sequence(U.iMap(players, function(player)
					return function()
						local sData = U.shift(storedData)
						sData.id = player.steam_name
						player.changeColor(sData.curColor)
						S.setStateVal(sData, "playerStorage", player.steam_name)
					end
				end), 0.5)
			end
		})
	elseif id == "resetTable" then
		DIR.RESET()
	elseif id == "concealHouseCards" then
		U.forEach(getObjectsWithTag("HouseCard"),
			function(obj)
				obj.setRotation(obj.getRotation():setAt("z", button == "-2" and 0 or 80))
				obj.setPosition(obj.getPosition():setAt("y", button == "-2" and 7.52 or 3.7))
			end)
		U.forEach(getObjectsWithAllTags({"SecretAgenda", "Private"}),
			function(card)
				card.setPosition(card.getPosition():setAt("y", button == "-2" and 7 or -1))
			end)
	elseif id == "hideHouseCards" then
		U.forEach(getObjectsWithTag("HouseCard"),
			function(obj) obj.setRotation(obj.getRotation():setAt("z", button == "-2" and 0 or 180)) end)
	elseif id == "adminFetch" then
		if button == "-2" then
			DIR.PromptForEnvelope(U.getHost(), true)
		else
			DIR.PromptForSticker(U.getHost(), true)
		end
	elseif id == "adminGivePowerCoin" then
		if button == "-2" then
			promptGiveCoin()
		else
			promptGivePower()
		end
	elseif id == "setNextKing" then
		DIR.PromptForKingName(P.GetWinners())
	elseif id == "captureNext" then
		if button == "-2" then
			captureRow = 0
		else
			captureRow = captureRow + 1
		end
		if captureRow > 6 then
			U.forEach(getObjectsWithTag("Capture"), function(obj) obj.destruct() end)
			player.setCameraMode("ThirdPerson")
			P.SetCamera("BehindScreen", player)
		else
			local cameraData = U.clone(C.CameraAngles.ScreenCapture)
			cameraData.cameraMode = nil
			cameraData.position = Vector(C.CameraAngles.ScreenCapture.position):add(Vector(0, 0,
				C.CaptureCoords.cameraZoneZShift):scale(1, 1, captureRow + (captureRow == 0 and 0 or 0.25)))
			player.lookAt(cameraData)
			player.setCameraMode("TopDown")
		end
	elseif id == "setChronicleType" then
		DIR.SetChronicleType(true)
	elseif string.match(id, "^debug_testFunc") then
		id = string.gsub(id, "^debug_testFunc", "") * 1
		TESTFUNCS[id](button, player)
	elseif id == "debug_logState" then
		log(JSON.encode_pretty(S.getGameState()))
	elseif id == "logGameToStorage" then
		local tokenData = DIR.GetTokenPositionsFromBoard()
		local scoreData = DIR.GetFinalStandings()
		-- log({tokenData = tokenData, scoreData = scoreData})
		S.RecordFinishedGame(scoreData, tokenData)
	elseif id == "debug_logScores" then
		log(JSON.encode_pretty(DIR.GetFinalStandings()))
	elseif id == "debug_resetState" then
		S.resetGameState()
		Global.call("UpdatePhaseDisplay")
	elseif id == "debug_primeLights" then
		L.ResetLights()
		L.HideArrows()
	elseif id == "debug_setCamera" then
		if button == "-2" then
			P.SetCamera("BehindScreen", Turns.turn_color, "Brown")
		else
			local player = U.getHost()
			local playerOptions = U.getKeys(C.CameraAngles)
			player.showOptionsDialog("Which Camera Mode?", playerOptions, 1, function(_, i)
				local cameraAngle = playerOptions[i]
				if C.CameraAngles[cameraAngle].isPlayerAngle then
					player.showOptionsDialog("Of which player?", Player.getAvailableColors(), 1, function(_, i)
						local camRef = Player.getAvailableColors()[i]
						P.SetCamera(cameraAngle, camRef, player)
					end)
				else
					P.SetCamera(cameraAngle, player)
				end
			end)
		end
	elseif id == "debug_setLight" then
		player.showInputDialog("Which light?",
			"lightName, lightMode, playerColor",
			function(response)
				local rComps = U.split(response, ",")
				local name, mode, pColor = rComps[1], rComps[2], rComps[3]
				L.SetLightMode(name, mode, pColor)
			end)
	elseif id == "debug_resetPlayers" then
		S.resetGameState(true)
		Global.call("UpdatePhaseDisplay")
	elseif id == "debug_setArrows" then
		if button == "-1" then
			L.ShowArrows()
		else
			L.HideArrows()
		end
	elseif string.match(id, "^houseHover_") then
		local houseName = string.match(id, "^houseHover_(.-)_.-$")
		DIR.HouseHUDClick(player, houseName)
	end
end

function HUD_HoverOn(player, returnString, id)
	if string.match(id, "^houseHover_") then
		local houseName = string.match(id, "^houseHover_(.-)_.-$")
		DIR.HouseHUDHoverOn(player, houseName)
	elseif string.match(id, "^splashQuery_") then
		local _, optionRef, color = table.unpack(U.split(id, "_"))
		UI.setAttribute(id, "color", "#FFD700FF")
		UI.setAttribute("splashQueryText_" .. optionRef .. "_" .. color, "color", "#FFFFFFFF")
	end
end

function HUD_HoverOff(player, returnString, id)
	-- log({player = player, returnString = returnString, id = id})
	if string.match(id, "^houseHover_") then
		local houseName = string.match(id, "^houseHover_(.-)_.-$")
		DIR.HouseHUDHoverOff(player, houseName)
	elseif string.match(id, "^splashQuery_") then
		local _, optionRef, color = table.unpack(U.split(id, "_"))
		UI.setAttribute(id, "color", "#FFD70011")
		UI.setAttribute("splashQueryText_" .. optionRef .. "_" .. color, "color", "#FFFFFF44")
	end
end

-- #endregion

--#region Emergency Control HUD
function HUDControl_Click(player, button, id)
	local _, mode, elemID = table.unpack(U.split(id, "-"))
	if mode == "Toggle" then
		if button == "-2" then
			UI.hide(elemID)
			UI.setAttribute(elemID, "active", "false")
		else
			UI.show(elemID)
			UI.setAttribute(elemID, "active", "true")
		end
	elseif mode == "Click" then
		local hudRef, actionRef, pColor = table.unpack(U.split(elemID, "_"))
		if hudRef == "turnHUD" then
			DIR.TurnHUDClick(actionRef, pColor)
		elseif hudRef == "splashQuery" then
			HUD_Click(pColor, "1", elemID)
		end
	end
	toggleXmlElement("HUDControl")
end
--#endregion
-- #region House HUD~
function House_HUD_Click(player, _, id)
	local _, _, houseName = table.unpack(U.split(id, "_"))
	DIR.HouseHUDClick(player, houseName)
end

function House_HUD_HoverOn(player, _, id)
	local _, _, buttonRef = table.unpack(U.split(id, "_"))
	DIR.HouseHUDHoverOn(player, buttonRef)
end

function House_HUD_HoverOff(player, _, id)
	local _, _, buttonRef = table.unpack(U.split(id, "_"))
	DIR.HouseHUDHoverOff(player, buttonRef)
end

-- #endregion

-- #region Turn HUD~
function Turn_HUD_Click(_, _, id)
	local _, action, color = table.unpack(U.split(id, "_"))
	DIR.TurnHUDClick(action, color)
end

function Turn_HUD_HoverOn(_, _, id)
	local _, action, color = table.unpack(U.split(id, "_"))
	UI.setAttribute("turnHUD_" .. action .. "_Text_" .. color, "color", "rgba(1,1,1,1)")
	if action == "voteAye" then
		UI.setAttribute(id, "color", "rgba(0,1,1,1)")
	elseif action == "voteNay" then
		UI.setAttribute(id, "color", "rgba(1,0,0,1)")
	elseif action == "stay" then
		UI.setAttribute(id, "color", "rgba(0.6, 0.47, 0, 1)")
	else
		UI.setAttribute(id, "color", "rgba(0.6, 0.47, 0, 1)")
	end
end

function Turn_HUD_HoverOff(_, _, id)
	local _, action, color = table.unpack(U.split(id, "_"))
	UI.setAttribute("turnHUD_" .. action .. "_Text_" .. color, "color", "rgba(1,1,1,0.5)")
	if id == "voteAye" then
		UI.setAttribute(id, "color", "rgba(0,1,1,0.5)")
	elseif id == "voteNay" then
		UI.setAttribute(id, "color", "rgba(1,0,0,0.5)")
	elseif id == "stay" then
		UI.setAttribute(id, "color", "rgba(0.6, 0.47, 0,0.5)")
	else
		UI.setAttribute(id, "color", "rgba(0.6, 0.47, 0,0.5)")
	end
end

-- #endregion

-- #region Consequence HUD~
function Consequence_HUD_Click(_, button, id)
	local _, outcome, conType, resource, color = table.unpack(U.split(id, "_"))
	MSG.Hide(id)
	if conType ~= "O" then
		MSG.Hide(string.gsub(string.gsub(id, "consequence", "conDisplay"), "_" .. color, ""))
	end
	if button == "-2" then
		conType = "O"
	else
		conType = ({ O = "P", P = "N", N = "O" })[conType]
	end
	S.setStateVal(conType, "roundState", "consequences", outcome, resource)
	MSG.Show("consequence_" .. outcome .. "_" .. conType .. "_" .. resource .. "_" .. color)
	if conType ~= "O" then
		MSG.Show("conDisplay_" .. outcome .. "_" .. conType .. "_" .. resource)
	end
end

function Consequence_HUD_HoverOn(_, _, id)
	local _, outcome, conType, _ = table.unpack(U.split(id, "_"))
	if conType == "O" then
		UI.setAttribute(id, "color", "#7F7F7FFF")
	elseif outcome == "P" then
		UI.setAttribute(id, "color", "#1E87FFFF")
	elseif outcome == "N" then
		UI.setAttribute(id, "color", "#DA1917FF")
	end
end

function Consequence_HUD_HoverOff(_, _, id)
	local _, outcome, conType, _ = table.unpack(U.split(id, "_"))
	if conType == "O" then
		UI.setAttribute(id, "color", "#7F7F7F7F")
	elseif outcome == "P" then
		UI.setAttribute(id, "color", "#1E87FF7F")
	elseif outcome == "N" then
		UI.setAttribute(id, "color", "#DA19177F")
	end
end

-- #endregion

-- #region Input HUD~
function InputHUD_Sticker(player, value)
	DIR.ConfirmFetchSticker(player, value)
end

function InputHUD_Envelope(player, value)
	DIR.ConfirmFetchEnvelope(player, value)
end

local curKingName
function InputHUD_KingUpdate(player, value)
	curKingName = value
end

function InputHUD_ToggleKingTitle(player)
	if S.getStateVal("gameState", "kingTitle") == "Queen" then
		S.setStateVal("King", "gameState", "kingTitle")
	else
		S.setStateVal("Queen", "gameState", "kingTitle")
	end
	UI.setValue("kingQuery_kingTitle_" .. player.color, S.getStateVal("gameState", "kingTitle"))
end

function InputHUD_KingConfirm(player, _, id)
	-- log({CLICKED = curKingName})
	if not curKingName or #U.trim(U.ToString(curKingName)) < 3 then return end
	local house = S.getPlayerHouse(player)
	local houseName = S.getPlayerHouseName(player)
	local parsedValue = U.join(U.map(U.filter(
			U.split(U.trim(curKingName), " "),
			function(word)
				return
						not string.match(string.lower(word), "^king$")
						and not string.match(string.lower(word), "^queen$")
						and not string.match(string.lower(word), "^house$")
						and not string.match(string.lower(word), "^" .. U.lCase(house) .. "$")
						and not string.match(string.lower(word), "^" .. U.lCase(houseName) .. "$")
			end
		),
		function(word, i)
			if string.match(string.lower(word), "^of$")
					or string.match(string.lower(word), "^the$")
					or string.match(string.lower(word), "^and$") then
				if i == 1 then return U.tCase(word) end
				return U.lCase(word)
			end
			if string.match(string.upper(word), "^[IVXL]+$") then return U.uCase(word) end
			return U.tCase(word)
		end), " ")
	if not (string.match(parsedValue, " [IVXL]+$") or string.match(parsedValue, " [IVXL]+ ")) then
		parsedValue = parsedValue .. " I"
	end

	local splashValue = string.gsub(parsedValue, " [IVXL]+$", "")
	local splashTitle
	if string.match(C.HousePrefixes[house], "Mark") then
		if S.getStateVal("gameState", "kingTitle") == "Queen" then
			splashTitle = "Marchioness"
		else
			splashTitle = "Marquise"
		end
	else
		if S.getStateVal("gameState", "kingTitle") == "Queen" then
			splashTitle = "Duchess"
		else
			splashTitle = "Duke"
		end
	end

	MSG.Hide("kingQuery_" .. player.color)

	local splashTime = 2
	MSG.Splash(
		splashTitle .. " " .. splashValue .. " " .. houseName .. " Will Inherit the Throne!",
		"AllMid",
		splashTime,
		{ color = "#FFDD00" }
	)
	Wait.time(function()
		S.setStateVal(parsedValue .. " of House " .. S.getPlayerHouseName(player), "gameState", "kingName")
	end, splashTime)
end

-- #endregion

-- #region Reference HUD~
local lockedPopupImage = {}
local function hideActiveSubmenus(color, activeMenu)
	U.forEach({ "Help", "View", "Map", "Lore" }, function(param)
		if param == activeMenu then return end
		local targetMenuID = "refHUD_SubmenuContents_" .. param .. "_" .. color
		if string.lower(UI.getAttribute(targetMenuID, "active") or "true") == "true" then
			UI.hide(targetMenuID)
		end
	end)
end

function Ref_HUD_Click(player, _, id)
	local _, mode, param, color = table.unpack(U.split(id, "_"))
	-- log({mode = mode, param = param, color = color, pColor = player.color})
	if mode == "Popup" then
		hideActiveSubmenus(player.color)
		local popupID = "refHUD_PopupImage_" .. param .. "_" .. player.color
		if lockedPopupImage[player.color] == popupID then
			lockedPopupImage[player.color] = nil
			UI.hide(popupID)
			return
		elseif lockedPopupImage[player.color] ~= nil then
			UI.hide(lockedPopupImage[player.color])
		end
		UI.setAttribute(popupID, "active", "false")
		UI.show(popupID)
		lockedPopupImage[player.color] = popupID
	elseif mode == "Camera" then
		if param == "Screen" then
			P.SetCamera("BehindScreen", player)
		elseif param == "Board" then
			P.SetCamera("MainBoard", player)
		elseif param == "Resources" then
			P.SetCamera("Resources", player)
		elseif param == "Stickers" then
			P.SetCamera("Stickers", player)
		elseif param == "Dilemma" then
			P.SetCamera("DilemmaDraw", player)
		elseif param == "SignSticker" then
			P.SetCamera("StickerSign", player)
		elseif param == "SignStory" then
			P.SetCamera("StorySign", player)
		end
	end
end

function Ref_HUD_HoverOn(player, _, id)
	local _, mode, param, color = table.unpack(U.split(id, "_"))

	if mode == "Submenu" then
		hideActiveSubmenus(player.color, param)
		UI.setAttribute(id .. "_" .. player.color, "active", "false")
		UI.show(id .. "_" .. player.color)
		UI.setAttribute("refHUD_SubmenuContents_" .. param .. "_" .. player.color, "active", "false")
		UI.show("refHUD_SubmenuContents_" .. param .. "_" .. player.color)
	elseif mode == "Popup" then
		if lockedPopupImage[player.color] ~= nil then return end
		local popupID = "refHUD_PopupImage_" .. param .. "_" .. player.color
		UI.setAttribute(popupID, "active", "false")
		UI.show(popupID)
	end
end

function Ref_HUD_HoverOff(player, _, id)
	local _, mode, param, color = table.unpack(U.split(id, "_"))
	if mode == "Submenu" then
		UI.hide(id .. "_" .. player.color)
	elseif mode == "SubmenuContents" then
		UI.hide(id)
		UI.hide(string.gsub(id, "Contents", ""))
	elseif mode == "Popup" then
		if lockedPopupImage[player.color] ~= nil then return end
		local popupID = "refHUD_PopupImage_" .. param .. "_" .. player.color
		UI.hide(popupID)
	end
end

-- #endregion

-- #region Map Light HUD~
function MapHUD_Update(_, value, id)
	local _, _, index = table.unpack(U.split(id, "_"))
	local x, z, rc = string.match(value, "(%d+)x, (%d+)y,? ?(%w?%w?)")
	if x == nil or z == nil then
		S.setStateVal({}, "gameState", "mapLights", "mapInputs", index)
		return
	end
	if rc == nil then rc = "" end
	x = x * 1; z = z * 1

	S.setStateVal({ Vector(x, 0, z), rc }, "gameState", "mapLights", "mapInputs", index)

	if x < 0 or x > 2000 or z < 0 or z > 1000 then
		UI.setAttribute("mapHUD_ConfirmBG", "active", "false")
		UI.setAttribute("mapHUD_ConfirmText", "color", "#FF0000")
		UI.setValue("mapHUD_ConfirmText", "X")
	else
		UI.setAttribute("mapHUD_ConfirmBG", "active", "true")
		UI.setAttribute("mapHUD_ConfirmText", "color", "#000000")
		UI.setValue("mapHUD_ConfirmText", "OK")
	end

	if index == "A" then
		if x > 1000 then
			UI.setAttribute("mapHUD_ConfirmBG", "color", "#FF0000")
		else
			UI.setAttribute("mapHUD_ConfirmBG", "color", "#FFF2CC")
		end
	end
end

function MapHUD_Confirm()
	local coordsA, rcA = table.unpack(S.getStateVal("gameState", "mapLights", "mapInputs", "A") or {})
	local coordsB, rcB = table.unpack(S.getStateVal("gameState", "mapLights", "mapInputs", "B") or {})

	-- don't need to separate lights between maps, just have one be for first coord and second for second
	-- only one coord AND it's on AnkistMap?  show same location on WorldMap, scaling light properly
	-- only one coord AND it's on WorldMap?  Dim or turn off Ankist map light entirely

	if coordsA == nil then
		if coordsB == nil then return end
		coordsA = Vector(coordsB)
		rcA = rcB
		coordsB = nil
		rcB = nil
	end

	if coordsB == nil then
		coordsB = Vector(coordsA)
		rcB = nil
	end

	local isDerivingWorld = false
	if coordsA.x == coordsB.x and coordsA.z == coordsB.z then
		local rA = (string.match(rcA or "", "(%d)") or "1") * 1
		local cA = string.match(rcA or "", "(%a)") or "x"
		local rB = string.match(rcB or "", "(%d)") or ""
		local cB = string.match(rcB or "", "(%a)") or ""

		if cB == "" then cB = cA end
		if rB == "" then
			isDerivingWorld = true
			rB = rA
		end

		rcB = cB .. rB
	end

	-- S.setStateVal({mapInputs = {}, lightData = {}}, "gameState", "mapLights")

	-- lua aMap = getObjectFromGUID("ec2fcc"); wMap = getObjectFromGUID("378389")
	local function ankistToWorld(ankistLightData)
		local ankistBounds = {
			x = { min = -0.966, max = 0.994 },
			z = { min = -0.953, max = 0.964 }
		}

		local ankistWorldBounds = {
			x = { min = -0.28, max = 0.535 },
			z = { min = -0.58, max = 0.191 }
		}

		local ankistDeltas = {
			x = ankistBounds.x.max - ankistBounds.x.min,
			z = ankistBounds.z.max - ankistBounds.z.min
		}

		local ankistWorldDeltas = {
			x = ankistWorldBounds.x.max - ankistWorldBounds.x.min,
			z = ankistWorldBounds.z.max - ankistWorldBounds.z.min
		}

		local lightRatios = {
			x = (ankistLightData.localPos.x - ankistBounds.x.min) / ankistDeltas.x,
			z = (ankistLightData.localPos.z - ankistBounds.z.min) / ankistDeltas.z
		}

		local ankistWorldCoords = {
			x = ankistWorldBounds.x.min + (lightRatios.x * ankistWorldDeltas.x),
			z = ankistWorldBounds.z.min + (lightRatios.z * ankistWorldDeltas.z)
		}

		local ankistWorldLightData = U.clone(ankistLightData)
		ankistWorldLightData.localPos = Vector(
			ankistWorldCoords.x,
			ankistLightData.localPos.y,
			ankistWorldCoords.z
		)

		ankistWorldLightData.worldPos = O.Maps.MapWorld().positionToWorld(ankistWorldLightData.localPos):setAt("z", 75)
		ankistWorldLightData.mapRef = "MapWorld"
		-- ankistWorldLightData.map = O.Maps.MapWorld()

		if ankistWorldLightData.rangeRef > 0 then
			ankistWorldLightData.rangeRef = ankistWorldLightData.rangeRef - 1
		end

		return ankistWorldLightData
	end

	local function parseInputData(coords, rc, isDerivingWorld)
		if coords == nil then return {} end

		local mapRef
		if coords.x > 1000 then
			coords:setAt("x", coords.x - 1000)
			mapRef = "MapWorld"
		else
			mapRef = isDerivingWorld and "MapWorld" or "MapAnkist"
		end

		-- convert to local coordinates
		coords:scale(Vector(-0.002, 1, 0.002)):add(Vector(1, 0, -1))

		-- get range number and color reference
		local r = (string.match(rc or "", "(%d)") or "1") * 1
		local c = string.match(rc or "", "(%a)") or "x"

		-- get world coordinates
		local map = O.Maps[mapRef]()
		local worldPos = map.positionToWorld(coords):setAt("z", 75)

		return {
			localPos = coords,
			worldPos = worldPos,
			mapRef = mapRef,
			-- map = map,
			colorRef = c,
			rangeRef = r,
			isWorldDerived = mapRef == "MapWorld" and isDerivingWorld
		}
	end

	local lightDataA, lightDataB = parseInputData(coordsA, rcA), parseInputData(coordsB, rcB, isDerivingWorld)
	local mapAnkistMode, mapWorldMode = "off", "off"

	if U.isIn("MapAnkist", { lightDataA.mapRef, lightDataB.mapRef }) then mapAnkistMode = "dim" end
	if U.isIn("MapWorld", { lightDataA.mapRef, lightDataB.mapRef }) then mapWorldMode = "dim" end

	if isDerivingWorld or (lightDataA.mapRef == "MapAnkist" and lightDataB.mapRef == nil) then
		lightDataB = ankistToWorld(lightDataA)
		mapWorldMode = "dim"
	end

	S.setStateVal(lightDataA, "gameState", "mapLights", "lightData", "A")
	S.setStateVal(lightDataB, "gameState", "mapLights", "lightData", "B")

	L.SetLightMode("lightMapAnkist", mapAnkistMode)
	L.SetLightMode("lightMapWorld", mapWorldMode)
	L.SetLightMode({ "lightMapFocusA", "lightMapFocusB" }, "on")
end

-- #endregion
