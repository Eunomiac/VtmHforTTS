local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
local C = require("kingsdilemma.lib.constants")

local L = {}

local DefaultTransitionTime = 0.5

local LIGHTMODES = {
	lightLectern = {
		default = "ambient",
		ambient = {
			enabled = true,
			color = C.LightColors.Ambient,
			range = 200,
			angle = 70,
			intensity = 2,
			rotation = Vector(300, 0, 0)
		},
		spotlightChronicleCard = {
			enabled = true,
			color = Color.Yellow:lerp(Color.Grey, 0.4),
			range = 200,
			angle = 35,
			intensity = 2,
			rotation = Vector(312, 0, 0)
		},
		spotlightEnvelope = {
			enabled = true,
			color = C.LightColors.Ambient,
			range = 200,
			angle = 30,
			intensity = 2,
			rotation = Vector(290, 0, 8)
		},
		spotlightStickers = {
			enabled = true,
			color = C.LightColors.Ambient,
			range = 200,
			angle = 30,
			intensity = 2,
			rotation = Vector(290, 0, 352)
		},
		spotlightMystery = {
			enabled = true,
			color = C.LightColors.Ambient,
			range = 200,
			angle = 33,
			intensity = 2,
			rotation = Vector(275, 0, 0)
		},
		spotlightPlinth = {
			enabled = true,
			color = C.LightColors.Ambient,
			range = 200,
			angle = 30,
			intensity = 2,
			rotation = Vector(290, 0, 0)
		},
		spotlightTransit = {
			enabled = true,
			color = C.LightColors.Ambient,
			range = 200,
			angle = 50,
			intensity = 1,
			rotation = Vector(304, 0, 0)
		},
		firstStoryCard = {
			enabled = true,
			color = C.LightColors.Ambient,
			range = 200,
			angle = 25,
			intensity = 1.5,
			rotation = Vector({371.21, 0.00, 0.00 })
		}
	},
	lightMainTop = {
		default = "ambient",
		ambient = {
			enabled = true,
			color = C.LightColors.Ambient,
			range = 83,
			angle = 60,
			intensity = 1.5
		}
	},
	lightMainBottom = {
		default = "ambient",
		ambient = {
			enabled = true,
			color = C.LightColors.Ambient,
			range = 83,
			angle = 60,
			intensity = 1.5
		}
	},
	lightLeader = {
		off = {
			enabled = false
		},
		on = {
			enabled = true,
			color = Color(1, 1, 1),
			range = 66,
			angle = 30,
			intensity = 10
		}
	},
	lightModerator = {
		off = {
			enabled = false
		},
		on = {
			enabled = true,
			color = Color(1, 1, 1),
			range = 66,
			angle = 30,
			intensity = 10
		}
	},
	lightVote = {
		ambient = {
			color = Color(0.5, 0.5, 0.5),
			range = 55,
			angle = 57,
			intensity = 4
		},
		aye = {
			color = Color(0, 1, 1),
			range = 55,
			angle = 63,
			intensity = 4
		},
		nay = {
			color = Color(1, 0, 0),
			range = 55,
			angle = 63,
			intensity = 4
		}
	}
}



local function getComp(light) return light.getChildren()[1].getChildren()[2].getComponents()[2] end

local function getLight(lightName, playerRef)
	local player
	local tags = { lightName }
	if playerRef ~= nil then
		player = S.getPlayer(playerRef)
		table.insert(tags, player.color)
	end
	local lights = getObjectsWithAllTags(tags)
	if #lights > 1 then
		return U.alertGM("[Error: getLight()] Multiple '" .. "'s found!")
	end
	if #lights == 0 then
		---@diagnostic disable-next-line: need-check-nil
		return U.alertGM("[Error: getLight()] No '" ..
		"' light found" .. (player == nil and "!" or (" for " .. player.color .. " Player.")))
	end
	return lights[1]
end

local function loadLights()
	U.forEach(LIGHTMODES, function(modes, name)
		if modes.default ~= nil then
			L.SetLightMode(name, modes.default, nil, 3)
		end
	end)
end

local function getAllLights()
	return U.filter(getObjects(), function(obj)
		return obj.getChildren ~= nil
				and obj.getChildren()[1] ~= nil
				and string.match(obj.getChildren()[1].name, "^spotlight")
				and getComp(obj).name == "Light"
	end)
end


local function showArrow(light)
	if light == nil then return U.forEach(getAllLights(), showArrow) end
	light.AssetBundle.playLoopingEffect(0)
	local playerColor = U.findColorTag(light)
	if playerColor ~= nil then
		return light.highlightOn(Color[playerColor])
	else
		return light.highlightOn(Color.White)
	end
end

local function hideArrow(light)
	if light == nil then return U.forEach(getAllLights(), hideArrow) end
	light.AssetBundle.playLoopingEffect(1)
	light.highlightOff()
end



local function setEnabled(light, enabled, transitionTime)
	local lComp = getComp(light)
	if lComp.get("enabled") ~= enabled then
		if transitionTime == nil then transitionTime = DefaultTransitionTime end
		if enabled == true then
			local finalIntensity = lComp.get("intensity")
			lComp.set("intensity", 0)
			lComp.set("enabled", true)
			return U.Lerp(
				function(intensity) lComp.set("intensity", intensity) end,
				0,
				finalIntensity,
				transitionTime
			)
		else
			local startingIntensity = lComp.get("intensity")
			return U.RunSequence({
				function()
					return U.Lerp(
						function(intensity) lComp.set("intensity", intensity) end,
						startingIntensity,
						0,
						transitionTime
					)
				end,
				function()
					lComp.set("enabled", false)
					return 0.5
				end,
				function()
					lComp.set("intensity", startingIntensity)
					return 0
				end
			})
		end
	end
end
local function setRange(light, range) getComp(light).set("range", range) end
local function setIntensity(light, intensity) getComp(light).set("intensity", intensity) end
local function setColor(light, color) getComp(light).set("color", Color(color)) end
local function setAngle(light, angle) getComp(light).set("spotAngle", angle) end

local function getEnabled(light) return getComp(light).get("enabled") end
local function getRange(light) return getComp(light).get("range") end
local function getIntensity(light) return getComp(light).get("intensity") end
local function getColor(light) return getComp(light).get("color") end
local function getAngle(light) return getComp(light).get("spotAngle") end

local function setLightMode(lightName, mode, playerNum, transitionTime)
	if transitionTime == nil then transitionTime = 2 end
	if playerNum == "ALL" then return U.forEach(S.getPlayers(), function(_, pNum) setLightMode(lightName, mode, pNum) end) end
	local light = getLight(lightName, playerNum)

	if LIGHTMODES[lightName] == nil then
		return U.alertGM("[Error: setLightMode] No modes configured for light '" .. lightName .. "'")
	end
	local lData = U.clone(LIGHTMODES[lightName][mode])
	if lData == nil then
		return U.alertGM("[Error: setLightMode] No such light mode '" .. mode .. "' for light '" .. lightName .. "'")
	end

	local afterVals = {}

	if lData.enabled ~= nil then
		if lData.enabled == getEnabled(light) then lData.enabled = nil
		elseif lData.enabled == true then
			setIntensity(light, 0)
			setAngle(light, 0)
			setEnabled(light, true)
		else
			afterVals.intensity = lData.intensity
			afterVals.angle = lData.angle
			lData.intensity = 0
			lData.angle = 0
		end
	end

	return U.RunSequence({
		function()
			local lerpFuncs = {}

			if lData.range ~= nil then
				table.insert(lerpFuncs, U.Lerp(function(range) setRange(light, range) end, getRange(light), lData.range, transitionTime))
			end
			if lData.intensity ~= nil then
				table.insert(lerpFuncs, U.Lerp(function(intensity) setIntensity(light, intensity) end, getIntensity(light), lData.intensity, transitionTime))
			end
			if lData.angle ~= nil then
				table.insert(lerpFuncs, U.Lerp(function(angle) setAngle(light, angle) end, getAngle(light), lData.angle, transitionTime))
			end
			if lData.color ~= nil then
				table.insert(lerpFuncs, U.Lerp(function(color) setColor(light, color) end, getColor(light), lData.color, transitionTime))
			end
			if lData.rotation ~= nil then
				table.insert(lerpFuncs, U.Lerp(function(rotation) light.setRotationSmooth(rotation) end, light.getRotation(), lData.rotation, transitionTime))
			end
			if lData.position ~= nil then
				table.insert(lerpFuncs, U.Lerp(function(position) light.setPositionSmooth(position) end, light.getPosition(), lData.position, transitionTime))
			end

			return lerpFuncs
		end,
		function()
			if lData.enabled == false then
				setEnabled(light, false)
				setIntensity(light, afterVals.intensity)
				setAngle(light, afterVals.angle)
			end
			return 0
		end
	})
end

L.LoadLights = loadLights
L.ShowArrows = showArrow
L.HideArrows = hideArrow
L.SetLightMode = setLightMode

L.LerpEnable = setEnabled

return L
