-- #region IMPORTS ~
local U = require("lib.utilities")
local C = require("kingsdilemma.lib.constants")
local OU = require("kingsdilemma.objects.objUtilities")

local S = {}
-- #endregion

local INITGAMESTATE = {
	isMidGame = false,
	gameCount = 1,
	seatCount = 5,
	gameMode = C.Modes.NONE,
	gamePhase = C.Phases.NONE,
	playerData = {},
	playerStorage = {},
	curLeader = nil,
	curModerator = nil
}

-- #region Initializing, Refreshing, Resetting Game State ~
function S.GetSeatCount()
	local seatedPlayers = S.getPlayers()
	U.Assert("S.GetSeatCount", seatedPlayers, "table")
	U.Assert("S.GetSeatCount", #seatedPlayers, function(v) return type(v) == "number" and v <= 5 end)
	local seatCount = S.getStateVal("seatCount")
	if #seatedPlayers > seatCount then
		S.setStateVal(#seatedPlayers, "seatCount")
		seatCount = #seatedPlayers
	end
	return seatCount
end

function S.UpdateSeatedPlayers()
	local angles = C.SeatAngles[S.GetSeatCount()]
	local playerData = {}
	U.iForEach(S.getPlayers(), function(player, i)
		playerData[player.color] = {
			id = S.getStorageID(player),
			color = player.color,
			num = i,
			angle = angles[i]
		}
	end)
	S.setStateVal(playerData, "playerData")
end

function S.InitializeGameState(save_data)
	if type(save_data) == "string" then
		save_data = JSON.decode(save_data)
	end
	if save_data then
		save_data = U.merge(INITGAMESTATE, save_data)
		S.setGameState(save_data)
	else
		S.resetGameState()
	end
	S.UpdateSeatedPlayers()
end

function S.resetGameState(isWipingPlayerData)
	local newState = U.clone(INITGAMESTATE, true)
	local state = Global.getTable("gameState")

	if not isWipingPlayerData and state.playerStorage ~= nil then
		newState.playerStorage = state.playerStorage
	end

	Global.setTable("gameState", newState)
	S.refreshStateDebug()
end

function S.refreshStateDebug(stateData)
	local function parseCode(val, excludeKeys)
		local encodeString
		if val == nil then return "nil" end
		if excludeKeys == nil then
			encodeString = JSON.encode_pretty(val)
		else
			encodeString = JSON.encode_pretty(U.filter(val, function(_, key) return not U.isIn(key, excludeKeys) end))
		end
		return string.gsub(encodeString, "% % ", "..")
	end

	if (stateData == nil) then stateData = Global.getTable("gameState") end
	UI.setValue("stateDisplay", parseCode(stateData))
end

-- #endregion

-- #region Basic Getters & Setters ~
function S.getGameState()
	S.refreshStateDebug()
	return Global.getTable("gameState")
end

function S.setGameState(data)
	Global.setTable("gameState", data)
	S.refreshStateDebug(data)
	return
end

function S.getStateVal(key, subKey)
	local state = Global.getTable("gameState")
	S.refreshStateDebug(state)
	if not state[key] then return state[key] end
	if subKey then return state[key][subKey] end
	return state[key]
end

function S.setStateVal(value, key, subKey)
	U.Assert("S.setStateVal", key, "string")
	local state = Global.getTable("gameState")
	if (subKey) then
		if (state[key] == nil) then state[key] = {} end
		state[key][subKey] = value
	else
		state[key] = value
	end
	Global.setTable("gameState", state)
	S.refreshStateDebug(state)
end

function S.setStateVals(stateData)
	local state = Global.getTable("gameState")
	for key, val in pairs(stateData) do
		state[key] = val
	end
	Global.setTable("gameState", state)
	S.refreshStateDebug(state)
end
-- #endregion

-- #region PlayerData Getters & Setters ~
function S.getStorageID(playerRef)
	local player = S.getPlayer(playerRef)
	if player == nil then return nil end
	if string.match(player.steam_name or " ", "^Player ") then
		return player.steam_name
	end
	return tostring(player.steam_id)
end

function S.getPlayerData(playerRef)
	local player = S.getPlayer(playerRef)
	if player == nil then return S.getStateVal("playerStorage") end
	return S.getStateVal("playerStorage", S.getStorageID(player))
end

function S.setPlayerData(playerRef, pData)
	local player = S.getPlayer(playerRef)
	S.setStateVal(pData, "playerStorage", S.getStorageID(player))
end

function S.getPlayerVal(playerRef, key, subKey)
	local player = S.getPlayer(playerRef)
	if player == nil then return end
	local pData = S.getStateVal("playerData", player.color)
	if pData == nil then
		S.UpdateSeatedPlayers()
		pData = S.getStateVal("playerData", player.color)
		if pData == nil then return end
	end
	if pData[key] ~= nil then return pData[key] end
	local pID = pData.id
	if pID == nil then return nil end
	local sData = S.getStateVal("playerStorage", pID)
	if not sData then return nil end
	if not sData[key] then return sData[key] end
	if subKey then return sData[key][subKey] end
	return sData[key]
end

function S.setPlayerVal(value, playerRef, key, subKey)
	local player = S.getPlayer(playerRef)
	if player == nil then return end
	local pState = S.getStateVal("playerStorage", S.getStorageID(player))
	if pState == nil then pState = {}; pState.id = S.getStorageID(player) end
	if (subKey) then
		if (pState[key] == nil) then pState[key] = {} end
		pState[key][subKey] = value
	else
		pState[key] = value
	end
	S.setPlayerData(player, pState)
end
-- #endregion

-- #region Player Instance Getters ~
function S.getPlayer(playerRef)
	if playerRef == nil then return end
	if type(playerRef) == "userdata" then
		if U.isPlayer(playerRef) then return playerRef end
		if U.isGameObject(playerRef) then return S.getPlayerOf(playerRef) end
	elseif type(playerRef) == "string" then
		if playerRef == "Host" or playerRef == "Admin" then
			return U.find(S.getPlayers(), function(player)
				return tostring(player.steam_id) == C.AdminID
			end)
		end
		if U.isPlayer(Player[playerRef]) then return Player[playerRef] end
		return U.find(S.getPlayers(), function(player)
			return tostring(player.steam_id) == playerRef
					or tostring(player.steam_name) == playerRef
		end)
	elseif type(playerRef) == "number" then
		return S.getPlayers()[playerRef]
	end
end

function S.getPlayers()
	local seatColors = U.filter(C.SeatColors, function(col) return U.isIn(col, Player.getAvailableColors()) end)
	return U.filter(U.iMap(seatColors, function(color) return Player[color] end), U.isPlayer)
end

function S.getPlayerColor(playerRef) return S.getPlayer(playerRef).color end

function S.getPlayerNum(playerRef)
	if playerRef == 0 or playerRef == nil then return 0 end
	return S.getPlayerVal(playerRef, "num")
end

function S.getPlayerAngle(playerRef)
	if playerRef == 0 or playerRef == nil then return 0 end
	return S.getPlayerVal(playerRef, "angle")
end

function S.getPlayerOf(obj)
	if obj == nil then return nil end
	local playerColor = U.findColorTag(obj)
	if playerColor ~= nil then
		return Player[playerColor]
	elseif obj.hasTag("sourceObj") then
		return nil
	else
		local playerAngle = OU.GetNearestPlayerAngle(obj)
		if playerAngle == 0 then return 0 end
		local playerData = U.find(S.getStateVal("playerData"), function(pData) return pData.angle == playerAngle end)
		if playerData == nil then return U.alertGM("Error finding player of object '" .. tostring(obj) .. "'") end
		return S.getPlayer(playerData.num)
	end
end
-- #endregion

-- #region Game Phase Tracking
function S.isInMode(modes)
	if type(modes) == "string" then modes = { modes } end
	return U.isIn(S.getStateVal("gameMode"), modes)
end

function S.isInPhase(phases)
	if type(phases) == "string" then phases = { phases } end
	return U.isIn(S.getStateVal("gamePhase"), phases)
end

function S.getNextPhase() --+
	local curMode, curPhase = S.getStateVal("gameMode"), S.getStateVal("gamePhase")
	local modePhases = C.Phases[curMode]
	local nextMode, nextPhase

	local function getNextMode(curMode)
		local modes = U.getValues(C.Modes)
		local index = U.findIndex(modes, function(mode) return mode == curMode end)
		if index == #modes then
			return modes[1]
		else
			return modes[index + 1]
		end
	end
	local function getNextPhase(curMode, curPhase)
		local modePhases = C.Phases[curMode]
		if type(modePhases) == "table" then
			local phases = U.getValues(modePhases)
			local index = U.findIndex(phases, function(phase) return phase == curPhase end)
			if index == nil then
				return phases[1]
			end
			if index < #phases then
				return phases[index + 1]
			end
		end
		return false
	end
	local function getFirstPhaseOfMode(mode)
		local modePhases = C.Phases[mode]
		if type(modePhases) == "string" then return modePhases end
		return U.getValues(modePhases)[1]
	end

	if type(modePhases) == "string" then
		nextMode = getNextMode(curMode)
		nextPhase = getFirstPhaseOfMode(nextMode)
	else
		nextMode = curMode
		nextPhase = getNextPhase(curMode, curPhase)
		if nextPhase == false then
			nextMode = getNextMode(curMode)
			nextPhase = getFirstPhaseOfMode(nextMode)
		end
	end
	return nextMode, nextPhase
end
-- #endregion

return S
