local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
local C = require("kingsdilemma.lib.constants")
local P = require("kingsdilemma.core.players")
local O = require("kingsdilemma.lib.objects")
local OU = require("kingsdilemma.objects.objUtilities")
local V = require("kingsdilemma.core.voting")
local L = require("kingsdilemma.core.lighting")
local MSG = require("kingsdilemma.core.messaging")
local HouseScreen = require("kingsdilemma.objs.p3screen")

local DIR = {}
local HOUSE_SELECTION, newPlayerColors = {}, {}

local ISDEBUGGING = false
local isFirstCall = true

function DIR.ShowAutoAdvance() MSG.Show("autoAdvanceGamePhase"); MSG.Hide("advanceGamePhase") end
function DIR.ShowManualAdvance() MSG.Hide("autoAdvanceGamePhase"); MSG.Show("advanceGamePhase") end

function DIR.ToggleAdvanceControls()
	local mode, phase = S.getCurrentPhase()
	-- modes/phases that definitely require manual-advancing:
	if U.isIn(phase, {C.Phases.NONE, C.Phases.CHRONSETUP, C.Phases.PLAY.DrawDilemma, C.Phases.PLAY.DisplayOutcome, C.Phases.PLAY.ApplyChanges, C.Phases.END.Score}) then
		return DIR.ShowManualAdvance()
	end
	return DIR.ShowAutoAdvance()
end

-- #region Token Object Getters~
local function getBoardTokens()
	local tokens = {
		Stability = getObjectsWithTag("StabilityMarker")[1],
		resource = {}
	}
	local rTokens = getObjectsWithTag("ResourceMarker")
	table.sort(rTokens, function(a, b) return a.getPosition().x < b.getPosition().x end)
	tokens.resource.Influence = rTokens[1]
	tokens.resource.Wealth = rTokens[2]
	tokens.resource.Morale = rTokens[3]
	tokens.resource.Welfare = rTokens[4]
	tokens.resource.Knowledge = rTokens[5]
	return tokens
end

function DIR.GetStabilityPositionFromBoard()
	return OU.FindNearestSnapPoint(getObjectsWithTag("StabilityMarker")[1], O.UninteractableObjs.Board())
end

function DIR.GetTokenPositionsFromBoard()
	local board = O.UninteractableObjs.Board()
	local boardTokens = getBoardTokens()
	return {
		Stability = OU.FindNearestSnapPoint(boardTokens.Stability, board),
		Influence = OU.FindNearestSnapPoint(boardTokens.resource.Influence, board),
		Wealth = OU.FindNearestSnapPoint(boardTokens.resource.Wealth, board),
		Morale = OU.FindNearestSnapPoint(boardTokens.resource.Morale, board),
		Welfare = OU.FindNearestSnapPoint(boardTokens.resource.Welfare, board),
		Knowledge = OU.FindNearestSnapPoint(boardTokens.resource.Knowledge, board)
	}
end

local function getTokenMomentums()
	local boardTokens = getBoardTokens()
	local function getTokenMomentum(resource)
		local startTurnData = S.getStateVal("roundState", "boardTokens")
		if startTurnData == nil or startTurnData.momentum == nil or startTurnData.momentum[resource] == nil then
			local token = boardTokens.resource[resource]
			-- U.Assert("getTokenMomentum", token, "Object")
			return U.isFlipped(token) and -1 or 1
		else
			return startTurnData.momentum[resource]
		end
	end
	return {
		Influence = getTokenMomentum("Influence"),
		Wealth = getTokenMomentum("Wealth"),
		Morale = getTokenMomentum("Morale"),
		Welfare = getTokenMomentum("Welfare"),
		Knowledge = getTokenMomentum("Knowledge")
	}
end

local function getStickerData(stickerObj)
	if not stickerObj or not stickerObj.hasTag("ChronicleSticker") then return U.error("Not a Chronicle Sticker!") end
	local decalData = stickerObj.getDecals()
	local signDecal = U.find(decalData,
		function(dData) return string.match(dData.name, " Pos$") or string.match(dData.name, " Neg$") end)
	local house, status = table.unpack(U.split(signDecal.name, " "))
	local snapSlot = OU.FindNearestSnapPoint(stickerObj, O.UninteractableObjs.Board())
	local resource = C.Resources[math.ceil(snapSlot / 3)]
	local column = snapSlot % 3
	return {
		name = stickerObj.getName(),
		obj = stickerObj,
		age = #U.filter(decalData, function(dData) return dData.name == "z Black Box" end) + (column / 10),
		house = house,
		status = status,
		resource = resource,
		snapSlot = snapSlot
	}

	-- x = 1.695, y = 0.125, z = -0.247, 0.062, 0.356
end

function DIR.GetStickerData()
	local stickerData = U.map(getObjectsWithTag("ChronicleSticker"), function(obj) return getStickerData(obj) end)
	table.sort(stickerData, function(a, b)
		local aRow, bRow = math.ceil(a.snapSlot / 3), math.ceil(b.snapSlot / 3)
		local aAge, bAge = a.age, b.age
		local aPos, bPos = 3 - ((a.snapSlot - 1) % 3), 3 - ((b.snapSlot - 1) % 3)
		local aScore, bScore = aRow + aAge/10 + aPos/100, bRow + bAge/10 + bPos/100
		return aScore < bScore
	end)
	return stickerData
end

-- #endregion

-- #region INITIALIZATION FUNCTIONS
local queryResponse
local memo_displayCard, memo_agendaDeck, memo_dilemmaDeck
local function agendaDeck()
	if memo_agendaDeck == nil then memo_agendaDeck = getObjectsWithTag("SecretAgenda")[1] end
	return memo_agendaDeck
end
local function displayCard()
	if memo_displayCard == nil then memo_displayCard = getObjectsWithTag("OnDisplay")[1] end
	return memo_displayCard
end
local function dilemmaDeck()
	if memo_dilemmaDeck == nil then
		local coverCard = O.Pieces.CoverCard()
		U.Assert("dilemmaDeck()", coverCard, "Object")
		memo_dilemmaDeck = U.findBelowObject(coverCard, function(obj) return obj.type == "Deck" end)[1]
	end
	return memo_dilemmaDeck
end


INITFUNCS = {
	NONE = function()
		return {
			function()
				P.ClearSeats()
				S.resetGameState()
				MSG.Hide("refHUDControls")
				return 1
			end,
			function()
				DIR.InitPreflight()
				return 1
			end
		}
	end,
	SESSIONINIT = {
		SeatPlayers = function()
			return {
				function()
					S.UpdatedSeatedPlayerData()
					U.forEach(getObjectsWithTag("Capture"), function(obj) obj.destruct() end)
					return 0.5
				end,
				DIR.ADVANCE
			}
		end,
		HouseSelection = function()
			return {
				function()
					if #DIR.GetUnselectedPlayers() == 0 then return 0 end
					return U.RunSequence({
						function() return MSG.Splash("House Selection", nil, 2) end,
						function()
							HOUSE_SELECTION = {}
							DIR.InitHouseSelectionHUD()
							return function() return HOUSE_SELECTION.isComplete == true end
						end
					})
				end,
				function()
					newPlayerColors = {}
					U.forEach(HOUSE_SELECTION, function(houseName, color)
						if not color or not houseName then return end
						if not U.isIn(color, C.SeatColors) then return end
						local player = S.getPlayer(color)
						table.insert(newPlayerColors, color)
						S.setPlayerVal(houseName, player, "house")
						S.setPlayerVal(nil, player, "houseName")
					end)
					MSG.Hide("houseSelectionHUD")
					MSG.Splash("Setting Up Play Spaces", nil, 5)
					return 0.5
				end,
				function()
					return U.map(S.getPlayers(), function(player)
						return HouseScreen.Spawn(
							player,
							S.getPlayerVal(player, "house"),
							U.isIn(player.color, newPlayerColors)
						)
					end)
				end,
				function() return 2 end,
				function()
					L.LoadLights({ "lightBehind" }, "ambient", 1.5)
					return 0.75
				end,
				function()
					P.InitPlayerHouseCards()
					P.ActivatePlayerScreenHUD()
					L.LoadLights({ "lightFront", "lightMapAnkist", "lightMapWorld" }, "ambient")
					return 2
				end,
				DIR.ADVANCE
			}
		end
	},
	CHRONSETUP = function()
		return {
			function()
				U.Assert("INITFUNCS.CHRONSETUP", S.getStateVal("gameState", "gameCount") == 0)
				queryResponse = { Prologue = "D1", ["Main Story"] = "0" }
				return MSG.SplashQuery(
					"How do you want to start your\nChronicle of The King's Dilemma?",
					"Host",
					queryResponse,
					U.getHost()
				)
			end,
			function()
				MSG.Splash(P.GetLeaderName() .. " Is Most Prestigious")
				return L.SetLightMode("lightLeader", "on", nil, 0.5)
			end,
			P.AssignLeader,
			function()
				MSG.Splash(P.GetModeratorName() .. " Is Least Prestigious")
				return L.SetLightMode("lightModerator", "on", nil, 0.5)
			end,
			P.AssignModerator,
			function() return P.SetCamera("Lectern") end,
			function()
				L.LoadLights({ "lightLectern" }, "default")
				return MSG.Splash("Chronicle Setup")
			end,
			function()
				S.setStateVal(queryResponse.response, "gameState", "chronicleType")
				S.setStateVal(({
					["D1"] = "Harald IV",
					["0"] = "Harald V"
				})[queryResponse.response], "gameState", "kingName")
				return DIR.FetchEnvelope(queryResponse.response)
			end
		}
	end,
	GAMESETUP = {
		InitializeState = function()
			return {
				function()
					MSG.Show("refHUDControls")
					L.SetLightMode("lightLectern", "default")
					S.LogGameStartTime()
					S.setStateVal(S.getStateVal("gameState", "gameCount") + 1, "gameState", "gameCount")
					return 0
				end,
				DIR.ADVANCE
			}
		end,
		MainBoard = function()
			return {
				function()
					P.SetCamera("MainBoard")
					L.SetLightMode({ "lightMainTop", "lightMainBottom" }, "ambient")
					L.SetLightMode("lightFeature", "on")
					return MSG.Splash("Board Setup")
				end,
				DIR.SpawnBoardTokens,
				function()
					V.ElevateBalance()
					return L.SetLightMode("lightBalance", "bright", nil, 0.5)
				end,
				function()
					DIR.InitCountZones()
					V.SpawnBalanceTokens(3)
					L.SetLightMode("lightBalance", "on", nil, 3)
					return 1.5
				end,
				function() return P.SetCamera("BehindScreen") end,
				function()
					MSG.Splash("Distributing Power & Coin")
					return {
						DIR.SpawnStartingPlayerPower(),
						DIR.SpawnStartingPlayerCoins()
					}
				end,
				DIR.ADVANCE
			}
		end,
		LeaderModerator = function()
			if S.getStateVal("gameState", "leader") ~= nil then
				return { DIR.ADVANCE }
			else
				return {
					function()
						MSG.Splash(P.GetLeaderName() .. " Is Most Prestigious")
						return L.SetLightMode("lightLeader", "on", nil, 0.5)
					end,
					P.AssignLeader,
					function()
						MSG.Splash(P.GetModeratorName() .. " Is Least Prestigious")
						return L.SetLightMode("lightModerator", "on", nil, 0.5)
					end,
					P.AssignModerator,
					DIR.ADVANCE
				}
			end
		end,
		LegacySetup = function()
			local stickerData
			return {
				function()
					P.SetCamera("Stickers")
					stickerData = DIR.GetStickerData()
					return MSG.Splash("Legacy Effects")
				end,
				function() return MSG.Splash("Chronicle Aging") end,
				function()
					local function ageChronicleSticker(sData)
						local stickerObj = sData.obj
						local curAge = math.floor(sData.age)
						local decalData
						if curAge < 3 then
							curAge = curAge + 1
							decalData = U.clone(C.Decals.BlackBox)
							decalData.position = Vector(C.ObjectSpots.ChronicleSticker[curAge])
						end

						stickerObj.highlightOn(C.RootColors.Amber, 0.5)
						if decalData ~= nil then
							stickerObj.addDecal(decalData)
						end
					end
					return U.sequence(U.iMap(stickerData, function(sData)
						return function() ageChronicleSticker(sData) end
					end))
				end,
				function()
					P.SetCamera("MainBoard")
					return MSG.Splash("Resource Legacy", "AllLow")
				end,
				function()
					local function applyResourceLegacy(sData)
						local stickerObj = sData.obj
						stickerObj.highlightOn(sData.status == "Pos" and Color.Blue or Color.Red, 0.5)
						DIR.BumpToken(sData.resource, sData.status == "Pos" and 1 or -1)
						return 0.75
					end
					return U.RunSequence(U.iMap(stickerData, function(sData)
						return function() return applyResourceLegacy(sData) end
					end))
				end,
				function()
					P.SetCamera("BehindScreen")
					L.SetLightMode("lightFront", "dim")
					return MSG.Splash("Power Legacy")
				end,
				function()
					local function applyPowerLegacy(sData)
						local stickerObj = sData.obj
						local statusColor = sData.status == "Pos" and Color.Blue or Color.Red
						local player = S.getPlayerOfHouse(sData.house)
						return U.RunSequence({
							function()
								stickerObj.highlightOn(statusColor, 1)
								MSG.Show("storyHUD_Sticker")
								UI.setValue("storyHUD_Sticker_Text", stickerObj.getDescription())
								UI.setAttribute("storyHUD_Sticker_Text", "color", U.GetHex(statusColor))
								L.PulseLight("lightFront", S.getPlayerOfHouse(sData.house), statusColor)
								if sData.status == "Pos" then
									P.SpawnPower(player, 1)
								else
									P.TakePower(player, 1)
								end
								return 2
							end,
							function()
								MSG.Hide("storyHUD_Sticker")
								return 0.75
							end
						})
					end
					return U.RunSequence(U.iMap(stickerData, function(sData)
						return function()
							return applyPowerLegacy(sData)
						end
					end))
				end,
				function()
					L.SetLightMode("lightFront", "ambient")
					MSG.Splash("Open Agendas")
					return 1
				end,
				function()
					local function assignOpenAgenda(sData)
						local status = sData.status == "Pos" and "positive" or "negative"
						local statusColor = ({positive = Color.Blue, negative = Color.Red})[status]
						local resource = sData.resource
						local stickerObj = sData.obj
						local player = S.getPlayerOfHouse(sData.house)
						local openAgendas = S.getPlayerVal(player, "openAgendas")
						if openAgendas == nil then openAgendas = {positive = {}, negative = {}} end
						if openAgendas[status] == nil then openAgendas[status] = {} end
						table.insert(openAgendas[status], resource)
						S.setPlayerVal(openAgendas, player, "openAgendas")
						return U.RunSequence({
							function()
								stickerObj.highlightOn(statusColor, 0.5)
								L.PulseLight("lightFront", player, statusColor)
								P.RefreshPlayerScreenHUD(player)
								if sData.status == "Pos" then
									return MSG.Splash("House " .. S.getPlayerHouseName(player) .. " takes the Positive Open Agenda for " .. resource, nil, nil, {color = U.GetHex(Color.Blue)})
								else
									return MSG.Splash("House " .. S.getPlayerHouseName(player) .. " takes the Negative Open Agenda for " .. resource, nil, nil, {color = U.GetHex(Color.Red)})
								end
							end,
							function()
								stickerObj.highlightOff()
								return 0
							end
						})
					end
					local stickersByResource = {}
					U.iForEach(stickerData, function(sData)
						local key = sData.resource .. "_" .. sData.status
						if stickersByResource[key] == nil then
							stickersByResource[key] = {}
						end
						table.insert(stickersByResource[key], sData)
					end)
					U.forEach(U.getKeys(stickersByResource), function(key)
						table.sort(stickersByResource[key], function(a, b) return a.age < b.age end)
					end)

					local seqFuncs = {}

					U.iForEach(U.getKeys(stickersByResource), function(key)
						local posOA = U.find(stickersByResource[key], function(sData) return  sData.status == "Pos" end)
						if posOA then
							table.insert(seqFuncs, function() return assignOpenAgenda(posOA) end)
						end
						local negOA = U.find(stickersByResource[key], function(sData) return  sData.status == "Neg" end)
						if negOA then
							table.insert(seqFuncs, function() return assignOpenAgenda(negOA) end)
						end
					end)

					return U.RunSequence(seqFuncs)
				end,
				DIR.ADVANCE
			}
		end,
		SecretAgendas = function()
			return {
				function()
					local assignedSAs = U.map(S.getPlayers(), function(player)
						return {
							color = player.color,
							secretAgenda = S.getPlayerVal(player, "PreAssignedSecretAgenda")
						}
					end)
					if #U.filter(assignedSAs, function(pData) return pData.secretAgenda ~= nil end) == #S.getPlayers() then
						return DIR.DealPreassignedSecretAgendas(assignedSAs)
					else
						return DIR.InitSecretAgendas()
					end
				end
			}
		end,
		PrepareFirstRound = function()
			return {
				DIR.AddToDilemmaDeck,
				function()
					S.setStateVal(0, "roundState", "roundNum")
					S.setStateVal(getTokenMomentums(), "roundState", "boardTokens", "momentum")
					DIR.GetDilemmaDeck().shuffle()
					return 0.5
				end,
				DIR.ADVANCE
			}
		end
	},
	PLAY = {
		StartRound = function()
			return {
				function()
					S.setStateVal(S.getStateVal("roundState", "roundNum") + 1, "roundState", "roundNum")
					S.setStateVal(DIR.GetTokenPositionsFromBoard(), "roundState", "boardTokens", "positions")
					S.setStateVal(P.GetLeader().color, "roundState", "currentTurn")
					S.setStateVal(false, "roundState", "passModClaimed")
					S.setStateVal(0, "roundState", "ayeTotal")
					S.setStateVal(0, "roundState", "nayTotal")
					U.forEach(S.getPlayers(), function(player)
						S.setPlayerTurnVal(false, player, "vote")
						S.setPlayerTurnVal(0, player, "powerCommitted")
					end)
					return DIR.ADVANCE()
				end
			}
		end,
		DrawDilemma = function()
			return {
				function()
					S.setStateVal({}, "roundState", "consequences")
					return {
						P.SetCamera("DilemmaDraw"),
						MSG.Splash("The Dilemma")
					}
				end,
				function()
					L.SetLightMode("lightLectern", "spotlightDilemmaDeck")
					return DIR.DrawDilemmaCard()
				end,
				function()
					if UI.getAttribute("lightControls", "active") == "false" then
						Global.call("HUD_Click", {player = U.getHost(), id = "toggleElem_lightControls"})
					end
					if displayCard().hasTag("Dilemma") then
						DIR.InitConsequencesQuery()
						DIR.SpawnReferenceDilemmas(displayCard())
					end
					L.SetLightMode("lightLectern", "off", nil, 0.5)
					L.SetLightMode("lightDilemmaMain", "on", nil, 2)
					L.SetLightMode("lightDilemmaRef", "on")

					return {
						U.setPositionSlow(displayCard(), C.Spots.Main.Dilemma.faceDown.position, 2, "speedUp"),
						U.setRotationSlow(displayCard(), C.Spots.Main.Dilemma.faceDown.rotation, 2, "speedUp"),
						U.setScaleSlow(displayCard(), C.Spots.Main.Dilemma.faceDown.scale, 2, "speedUp")
					}
				end,
				function()
					if displayCard().hasTag("TriggerCard") then
						queryResponse = {Yes = "true"}
						U.RunSequence({
							function()
								return MSG.SplashQuery(
									"Reveal Trigger Card Back?",
									P.GetLeaderName(),
									queryResponse,
									P.GetLeader()
								)
							end,
							function()
								if UI.getAttribute("lightControls", "active") == "true" then
									Global.call("HUD_Click", {player = U.getHost(), id = "toggleElem_lightControls"})
								end
								return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.DisplayOutcome)
							end
						})
					else
						MSG.Splash(P.GetLeaderName() .. ", the Dilemma Card is Yours", P.GetLeader())
						return {
							L.SetLightMode("lightDilemmaAye", "on", nil, 1),
							L.SetLightMode("lightDilemmaNay", "on", nil, 1)
						}
					end
				end
			}
		end,
		Vote = function()
			local queryResponse = { Yes = "true", No = "false" }
			return {
				function()
					if UI.getAttribute("lightControls", "active") == "true" then
						Global.call("HUD_Click", {player = U.getHost(), id = "toggleElem_lightControls"})
					end
					U.forEach(S.getPlayers(), function(player)
						-- if string.lower(UI.getAttribute("consequencesQuery_" .. player.color, "active")) == "true" then
						MSG.Hide("consequencesQuery_" .. player.color)
						-- end
						-- Wait.time(function() UI.setAttribute("consequencesQuery_" .. player.color, "active", "false") end, 1)
					end)
					P.SetCamera("BehindScreen")
					return MSG.SplashQuery(
						"Is a vote required this round?",
						P.GetLeaderName(),
						queryResponse,
						P.GetLeader()
					)
				end,
				function()
					if queryResponse.response == "true" then
						return U.RunSequence({
							function()
								MSG.Splash("The Vote")
								V.InitCountZones()
								return V.SetVotingLights()
							end,
							function()
								DIR.DisplayPassHUD(P.GetLeader())
								return V.StartTurn(P.GetLeader())
							end
						})
					else
						return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.EndRound)
					end
				end
			}
		end,
		VoteResolution = function()
			return {
				function()
					MSG.Hide("consequencesSidebar")
					U.forEach(getObjectsWithTag("RefDilemma"), function(obj) obj.destruct() end)
					L.SetLightMode("lightDilemmaRef", "off")
					return {
						L.SetLightMode({ "lightBehind" }, "ambient"),
						L.SetLightMode({ "lightFront" }, "dim"),
						L.SetLightMode({ "lightPlayerSpotlight" }, "off")
					}
				end,
				function()
					local nayTotal = S.getStateVal("roundState", "nayTotal")
					local ayeTotal = S.getStateVal("roundState", "ayeTotal")
					if ayeTotal == nayTotal then
						local query = { Aye = "Aye", Nay = "Nay" }
						return U.RunSequence({
							function()
								return L.SetLightMode({ "lightPlayerSpotlight" },
									"player" .. S.getPlayerNum(P.GetModerator()), nil, 1)
							end,
							function()
								if ayeTotal == 0 then
									MSG.Splash("Leadership falls to the Moderator, " .. P.GetModeratorName() .. ".")
									P.AssignLeader(P.GetModerator())
									return MSG.SplashQuery(
										"Does the proposed resolution succeed?",
										P.GetModeratorName(),
										query,
										P.GetModerator()
									)
								else
									MSG.Splash({
										"Tie.",
										"The Moderator will cast the deciding vote."
									})
									return MSG.SplashQuery(
										"Cast the tie-breaking vote.",
										P.GetModeratorName(),
										query,
										P.GetModerator()
									)
								end
							end,
							function()
								L.SetLightMode({ "lightPlayerSpotlight" }, "off")
								S.setStateVal(query.response, "roundState", "voteResult")
								return 0
							end
						})
					elseif ayeTotal > nayTotal then
						S.setStateVal("Aye", "roundState", "voteResult")
					else
						S.setStateVal("Nay", "roundState", "voteResult")
					end
					return 0
				end,
				function()
					if S.getStateVal("roundState", "voteResult") == "Aye" then
						return MSG.Splash("The Resolution is Approved", "AllMid", nil, { color = U.GetHex(Color.Blue) })
					else
						return MSG.Splash("The Resolution is Rejected", "AllMid", nil, { color = U.GetHex(Color.Red) })
					end
				end,
				function()
					if S.getPlayerVoteStatus(P.GetLeader()) ~= S.getStateVal("roundState", "voteResult") then
						local winningPlayers = U.filter(S.getPlayers(),
							function(player) return S.getPlayerVoteStatus(player) ==
								S.getStateVal("roundState", "voteResult") end)
						if #winningPlayers == 0 then return 0 end
						table.sort(winningPlayers,
							function(playerA, playerB) return S.getPlayerPowerCommitted(playerA) >
								S.getPlayerPowerCommitted(playerB) end)
						if #winningPlayers > 1 and S.getPlayerPowerCommitted(winningPlayers[1]) == S.getPlayerPowerCommitted(winningPlayers[2]) then
							local tiedPlayers = U.filter(winningPlayers,
								function(player) return S.getPlayerPowerCommitted(player) ==
									S.getPlayerPowerCommitted(winningPlayers[1]) end)
							local queryResponse = {}
							U.forEach(tiedPlayers, function(player) queryResponse[P.GetPlayerName(player)] = player end)
							return U.RunSequence({
								function()
									return MSG.SplashQuery(
										"Pass Leadership to which player?",
										P.GetModeratorName(),
										queryResponse,
										P.GetModerator()
									)
								end,
								function()
									if P.GetModeratorName() == P.GetPlayerName(queryResponse.response) then
										MSG.Splash(P.GetModeratorName() .. " retains Leadership.")
									else
										MSG.Splash(P.GetModeratorName() ..
										" assigns Leadership to " .. P.GetPlayerName(queryResponse.response) .. ".")
									end
									return P.AssignLeader(queryResponse.response)
								end
							})
						else
							return U.RunSequence({
								function()
									MSG.Splash(P.GetPlayerName(winningPlayers[1]) .. " claims Leadership.")
									return P.AssignLeader(winningPlayers[1])
								end
							})
						end
					else
						return 0
					end
				end,
				function()
					local passPlayers = U.filter(S.getPlayers(),
						function(player) return U.isIn(S.getPlayerVoteStatus(player), { "Pass", "PassMod" }) end)
					if #passPlayers > 0 then
						MSG.Splash("Granting Coin for Abstaining")
						return U.RunSequence(U.iMap(passPlayers, function(player)
							return function()
								P.SpawnCoins(player, 1)
								L.PulseLight("lightFront", player)
								return 0.5
							end
						end))
					end
					return 0
				end,
				function()
					local passPowerPlayers = U.filter(S.getPlayers(),
						function(player) return S.getPlayerVoteStatus(player) == "Pass" end)
					local balanceZone = getObjectsWithTag("zoneBalance")[1]
					local balancePower = OU.GetTotalValue(balanceZone, "PowerToken")
					if #passPowerPlayers > 0 then
						local powerPerPlayer = math.floor(balancePower / #passPowerPlayers)
						if powerPerPlayer > 0 then
							MSG.Splash("Gathering Power")
							OU.TransferValue(
								balanceZone,
								U.iMap(passPowerPlayers, function(player) return P.GetPlayerZone(player, "Power") end),
								powerPerPlayer,
								"PowerToken"
							)
							return U.RunSequence(U.iMap(passPowerPlayers, function(player)
								return function()
									L.PulseLight("lightFront", player)
									return 0.75
								end
							end))
						end
					end
					return 0
				end,
				function()
					local losingPlayers = U.filter(S.getPlayers(),
						function(player) return U.isIn(S.getPlayerVoteStatus(player), { "Aye", "Nay" }) and
							S.getPlayerVoteStatus(player) ~= S.getStateVal("roundState", "voteResult") end)
					if #losingPlayers > 0 then
						MSG.Splash("Returning Power to Losing Players")
						return U.RunSequence(U.iMap(losingPlayers, function(player)
							return function()
								OU.TransferValue(
									P.GetPlayerZone(player, "Public"),
									P.GetPlayerZone(player, "Power"),
									OU.GetTotalValue(P.GetPlayerZone(player, "Public"), "PowerToken"),
									"PowerToken"
								)
								Wait.time(function() V.LowerRiser(player) end, 2)
								L.PulseLight("lightFront", player)
								return 0.75
							end
						end))
					end
					return 0
				end,
				function()
					local winningPlayers = U.filter(S.getPlayers(),
						function(player) return S.getPlayerVoteStatus(player) ==
							S.getStateVal("roundState", "voteResult") end)
					if #winningPlayers > 0 then
						MSG.Splash("Moving Committed Power to Balance")
						local balanceZone = getObjectsWithTag("zoneBalance")[1]
						return U.RunSequence(U.iMap(winningPlayers, function(player)
							return function()
								OU.TransferValue(
									P.GetPlayerZone(player, "Public"),
									balanceZone,
									OU.GetTotalValue(P.GetPlayerZone(player, "Public"), "PowerToken"),
									"PowerToken"
								)
								Wait.time(function() V.LowerRiser(player) end, 2)
								L.PulseLight("lightFront", player)
								return 0.75
							end
						end))
					end
					return 0
				end,
				function() return L.SetLightMode("lightVote", "off") end,
				DIR.ADVANCE
			}
		end,
		DisplayOutcome = function()
			return {
				function()
					V.InitCountZones()
					if displayCard() == nil then return U.AlertGM("No Card Displayed!") end

					L.SetLightMode("lightDilemmaAye", "off", nil, 0.5)
					L.SetLightMode("lightDilemmaNay", "off", nil, 0.5)

					if S.getStateVal("roundState", "displayedCardType") == "dilemma" then
						U.Assert("Displayed Card is a Dilemma?", displayCard().hasTag("Dilemma"))

						local voteResult = S.getStateVal("roundState", "voteResult")
						if voteResult == nil then
							return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.EnvelopeCheck, false)
						end

						P.SetCamera("DilemmaResult")
						MSG.Splash("Rewards & Consequences")
						L.SetLightMode("lightDilemmaMain", voteResult or "off", nil, 2)

						if voteResult == "Nay" then
							displayCard().alt_view_angle = Vector(0, 180, 180)
						else
							displayCard().alt_view_angle = Vector(0, 0, 0)
						end

						return {
							U.setPositionSlow(displayCard(), C.Spots.Main.Dilemma["faceUp" .. voteResult].position, 0.5),
							U.setRotationSlow(displayCard(), C.Spots.Main.Dilemma["faceUp" .. voteResult].rotation, 0.5),
							displayCard()
						}
					elseif S.getStateVal("roundState", "displayedCardType") == "trigger" then
						U.Assert("Displayed Card is a Trigger Card?", displayCard().hasTag("TriggerCard"))

						P.SetCamera("DilemmaDraw")
						L.SetLightMode("lightDilemmaMain", "on", nil, 2)

						MSG.Splash("Resolve Triggered Event")

						DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.ApplyMomentum, false)


						return {
							U.setPositionSlow(displayCard(), C.Spots.Main.Trigger.faceUp.position, 0.5),
							U.setRotationSlow(displayCard(), C.Spots.Main.Trigger.faceUp.rotation, 0.5),
							displayCard()
						}
					end
				end
			}
		end,
		ApplyChanges = function()
			return {
				function()
					local voteResult = S.getStateVal("roundState", "voteResult")
					U.setPositionSlow(displayCard(), C.Spots.Main.Dilemma["faceUp" .. voteResult .. "Resolve"].position, 2)
					U.setRotationSlow(displayCard(), C.Spots.Main.Dilemma["faceUp" .. voteResult .. "Resolve"].rotation, 2)
					return MSG.Splash("Apply Changes to Resources")
				end
			}
		end,
		ApplyMomentum = function()
			local tokenPositionsFromState, tokenPositionsFromBoard
			local resourceTokens, resourceDeltas, resourceBumps
			local unboundPosAfterMomentum
			local stabilityBumps

			local function getTokenPositionDeltas(startPositions, endPositions)
				return {
					Influence = endPositions.Influence - startPositions.Influence,
					Wealth = endPositions.Wealth - startPositions.Wealth,
					Morale = endPositions.Morale - startPositions.Morale,
					Welfare = endPositions.Welfare - startPositions.Welfare,
					Knowledge = endPositions.Knowledge - startPositions.Knowledge
				}
			end

			return {
				function()
					tokenPositionsFromState = {
						Influence = S.getStateVal("roundState", "boardTokens", "positions", "Influence"),
						Wealth = S.getStateVal("roundState", "boardTokens", "positions", "Wealth"),
						Morale = S.getStateVal("roundState", "boardTokens", "positions", "Morale"),
						Welfare = S.getStateVal("roundState", "boardTokens", "positions", "Welfare"),
						Knowledge = S.getStateVal("roundState", "boardTokens", "positions", "Knowledge"),
					}
					tokenPositionsFromBoard = DIR.GetTokenPositionsFromBoard()
					unboundPosAfterMomentum = U.clone(tokenPositionsFromBoard)
					resourceDeltas = getTokenPositionDeltas(tokenPositionsFromState, tokenPositionsFromBoard)
					MSG.Splash("Applying Momentum")

					local tokenMomentums = getTokenMomentums()

					U.iForEach(C.Resources, function(resource)
						if tokenMomentums[resource] * resourceDeltas[resource] > 0 then
							-- moving in same direction: apply momentum
							unboundPosAfterMomentum[resource] = unboundPosAfterMomentum[resource] +
							tokenMomentums[resource]
						end
					end)

					resourceTokens = getBoardTokens().resource
					resourceBumps = getTokenPositionDeltas(tokenPositionsFromBoard, unboundPosAfterMomentum)
					stabilityBumps = getTokenPositionDeltas(tokenPositionsFromBoard, unboundPosAfterMomentum)

					return U.RunSequence(U.iMap(C.Resources, function(resource)
						if resourceDeltas[resource] == 0 then return function() return 0 end end
						if resourceBumps[resource] == 0 then
							-- Token moved, but opposite direction to momentum: flip momentum
							return function()
								S.setStateVal(resourceDeltas[resource] > 0 and 1 or -1, "roundState", "boardTokens",
									"momentum", resource)
								resourceTokens[resource].flip()
								DIR.UpdateTokenLight(resource, S.getStateVal("roundState", "boardTokens", "momentum", resource))
								return resourceTokens[resource]
							end
						else
							-- Token moved in same direction to momentum: bump by momentum, bump stability, set momentum to 2
							return function()
								return U.RunSequence({
									function()
										local tokenMomentum = resourceDeltas[resource] > 0 and 2 or -2
										S.setStateVal(tokenMomentum, "roundState", "boardTokens", "momentum", resource)
										return {
											DIR.BumpToken("Stability", stabilityBumps[resource]),
											DIR.BumpToken(resource, resourceBumps[resource]),
											DIR.UpdateTokenLight(resource, tokenMomentum),
											DIR.UpdateTokenLight("Stability")
										}
									end,
									-- function()
									-- 	S.setStateVal(resourceDeltas[resource] > 0 and 2 or -2, "roundState", "boardTokens", "momentum", resource)
									-- 	return {
									-- 		DIR.UpdateTokenLight(resource),
									-- 		DIR.UpdateTokenLight("Stability")
									-- 	}
									-- end
								})
							end
						end
					end))
				end,
				DIR.ADVANCE
			}
		end,
		StickerCheck = function()
			return {
				function()
					MSG.Splash("Checking for Chronicle Stickers")
					queryResponse = { Yes = "true", No = "false" }
					return MSG.SplashQuery(
						"Unlock a Chronicle Sticker?",
						P.GetLeaderName(),
						queryResponse,
						P.GetLeader()
					)
				end,
				function()
					if queryResponse.response == "true" then
						return DIR.PromptForSticker(P.GetLeader())
					end
					return DIR.ADVANCE()
				end
			}
		end,
		EnvelopeCheck = function()
			return {
				function()
					MSG.Splash("Checking for Chronicle Envelopes")
					queryResponse = { Yes = "true", No = "false" }
					return MSG.SplashQuery(
						"Unlock a Chronicle Envelope?",
						P.GetLeaderName(),
						queryResponse,
						P.GetLeader()
					)
				end,
				function()
					if queryResponse.response == "true" then
						return DIR.PromptForEnvelope(P.GetLeader())
					end
					return DIR.ADVANCE()
				end
			}
		end,
		EndRound = function()
			return {
				function()

					L.SetLightMode({ "lightMapAnkist", "lightLectern", "lightMapWorld" }, "ambient")
					L.SetLightMode({ "lightMapFocusA", "lightMapFocusB", "lightDilemmaMain" }, "off", nil, 2)

					displayCard().removeTag("OnDisplay")
					displayCard().addTag("Played")

					if S.getStateVal("roundState", "displayedCardType") == "dilemma" then
						U.Assert("Displayed Card is a Dilemma?", displayCard().hasTag("Dilemma"))
						DIR.AddToDilemmaDeck()

						local voteResult = S.getStateVal("roundState", "voteResult")
						local playedDilemmas = getObjectsWithAllTags({ "Dilemma", "Played" })
						local dilemmaTransform = C.Spots.Main.Dilemma["board" .. voteResult][#playedDilemmas]

						return U.RunSequence({
							function()
								displayCard().setLock(false)
								return {
									U.setPositionSlow(displayCard(),
										Vector(dilemmaTransform.position):add(Vector(-3, 0, 0)), 2),
									U.setRotationSlow(displayCard(), dilemmaTransform.rotation, 2),
									U.setScaleSlow(displayCard(), dilemmaTransform.scale, 1),
									displayCard()
								}
							end,
							function()
								displayCard().setLock(true)
								return U.setPositionSlow(displayCard(),
									Vector(dilemmaTransform.position):setAt("y", C.TableHeight), 1)
							end,
							function()
								-- Check Abdication
								local stabilityToken = getObjectsWithTag("StabilityMarker")[1]
								local stabilityZPos = stabilityToken.getPosition().z
								if stabilityZPos > 9 or stabilityZPos < -15 then return DIR.EndGame() end

								-- Check King Death
								local playedDilemmas = getObjectsWithAllTags({ "Dilemma", "Played" })
								if #playedDilemmas == 11 then return DIR.EndGame() end
								if #playedDilemmas > 6 then
									local queryResponse = { Yes = "true", No = "false" }
									return U.RunSequence({
										function()
											return MSG.SplashQuery(
												"Does the dilemma bear a skull icon?",
												P.GetLeaderName(),
												queryResponse,
												P.GetLeader()
											)
										end,
										function()
											if queryResponse.response == "true" then
												return DIR.EndGame()
											end
											return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.StartRound)
										end
									})
								else
									return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.StartRound)
								end
							end
						})
					elseif S.getStateVal("roundState", "displayedCardType") == "trigger" then
						U.Assert("Displayed Card is a Trigger Card?", displayCard().hasTag("TriggerCard"))

						return U.RunSequence({
							function()
								displayCard().setLock(false)
								local coverCard = O.Pieces.CoverCard()
								return {
									U.setPositionSlow(displayCard(), C.Spots.Main.Trigger.aboveDeck.position, 1),
									U.setRotationSlow(displayCard(), C.Spots.Main.Trigger.aboveDeck.rotation, 1),
									U.setScaleSlow(displayCard(), C.Spots.Main.Trigger.aboveDeck.scale, 1),
									displayCard(),
									function() return #U.findAboveObject(coverCard, function(obj) return obj.type == "Card" or obj.type == "Deck" end) == 1 end
								}
							end,
							DIR.AddToDilemmaDeck,
							function()
								return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.StartRound)
							end
						})
					end
				end
			}
		end
	},
	END = {
		Ending = function()
			return {
				function()
					local balanceZone = getObjectsWithTag("zoneBalance")[1]
					U.forEach(balanceZone.getObjects(), function(obj) obj.destruct() end)
					local stabilityPos = DIR.GetStabilityPositionFromBoard()
					local kingName = S.getStateVal("gameState", "kingName")
					if stabilityPos == 19 then
						S.setStateVal("AbdicatedTop", "gameState", "endState")
						return MSG.Splash("A Treasonous Plot Forces King " .. kingName .. " to Abdicate!", "AllMid", 3)
					elseif stabilityPos == 1 then
						S.setStateVal("AbdicatedBottom", "gameState", "endState")
						return MSG.Splash("Popular Unrest Forces the King " .. kingName .. " to Abdicate!", "AllMid", 3)
					else
						S.setStateVal("Death", "gameState", "endState")
						return MSG.Splash("King " .. kingName .. "  Is Dead", "AllMid", 3)
					end
				end,
				function()
					-- Check to ensure ALL non-SourceObj Power and Coin on board is in a private player zone
					local tokensOutOfZone = U.concat(
						U.filter(
							getObjectsWithTag("PowerToken"),
							function(obj)
								return obj.getName() == "Power"
									and not obj.hasTag("SourceObj")
									and not U.find(obj.getZones(), function(zone) return zone.getName() == "PrivatePower" end)
							end
						),
						U.filter(
							getObjectsWithTag("CoinToken"),
							function(obj)
								return obj.getName() == "Coin"
								and not obj.hasTag("SourceObj")
								and not U.find(obj.getZones(), function(zone) return zone.getName() == "PrivatePower" end)
							end
						)
					)
					if #tokensOutOfZone > 0 then
						U.forEach(tokensOutOfZone, function(obj) obj.highlightOn(Color.Red) end)
						DIR.ShowManualAdvance()
						return MSG.Splash("Move Highlighted Power & Coin Into Personal Zones")
					else
						return DIR.ADVANCE()
					end
				end
			}
		end,
		Score = function()
			local scoreData, tokenData
			return {
				function()
					tokenData = DIR.GetTokenPositionsFromBoard()
					scoreData = DIR.GetFinalStandings()
					S.RecordFinishedGame(scoreData, tokenData)
					MSG.Show("scoringSplashScreen")
					return 5
				end,
				function()
					DIR.InitScoringHUD(scoreData)
				end
			}
		end,
		Realm = function()
			return {
				function()
					MSG.Hide("scoringHUD")
					return 4
				end,
				function()
					UI.setAttributes("scoringHUD", {
						scale = "0.4 0.4 0.4",
						color = "Clear",
						offsetXY = "300 450"
					})
					MSG.Show("scoringHUD")
					return 1
				end,
				function()
					MSG.Splash("Record Earned Prestige & Crave on Your House Card", "AllLow", 5)
					local query = { Yes = "true" }
					return MSG.SplashQuery(
						"Proceed to Achievements?",
						"Host",
						query,
						U.getHost()
					)
				end,
				DIR.ADVANCE
			}
		end,
		Achievements = function()
			return {
				function()
					local query = { Yes = "true" }
					MSG.Splash("Tick Boxes for Any Earned Achievements", "AllLow", 5)
					return MSG.SplashQuery(
						"Proceed to Alignment?",
						"Host",
						query,
						U.getHost()
					)
				end,
				DIR.ADVANCE
			}
		end,
		Alignments = function()
			return {
				function()
					local query = { Yes = "true" }
					MSG.Splash("Tick the Box for the Secret Agenda You Played", "AllLow", 5)
					return MSG.SplashQuery(
						"Proceed to Cleanup?",
						"Host",
						query,
						U.getHost()
					)
				end,
				DIR.ADVANCE
			}
		end,
		Cleanup = function()
			return {
				function()
					MSG.Splash("Cleanup")
					local tokenData = DIR.GetTokenPositionsFromBoard()
					local scoreData = DIR.GetFinalStandings()
					S.RecordFinishedGame(scoreData, tokenData)
					local playedDilemmaCards = getObjectsWithAllTags({ "Dilemma", "Played" })
					local numPlayedDilemmas = #playedDilemmaCards
					table.sort(playedDilemmaCards, function(a, b) return a.getPosition().z < b.getPosition().z end)
					local tempStagingPos = Vector(C.Spots.Main.CoverCard.Closed.position):add(Vector(-10, -3, 0))

					return {
						U.sequence(U.iMap(playedDilemmaCards, function(card, i)
							return function()
								DIR.SpawnDilemmaForCapture(card, numPlayedDilemmas + 1 - i)
								tempStagingPos:add(Vector(0, 0.2, 0))
								if Vector(card.alt_view_angle).y > 90 then
									card.setDescription("Vote: NAY")
								else
									card.setDescription("Vote: AYE")
								end
								card.setPosition(tempStagingPos)
								card.setRotation(Vector(0, 180, 180))
								card.setTags({ "DilemmaOld" })
								card.setLock(false)
							end
						end), 0.15),
						function() return #getObjectsWithTag("DilemmaOld") == 1 end
					}
				end,
				function()
					local triggerCards = U.filter(getObjectsWithTag("TriggerCard"), function(obj) return obj.type == "Card" end)
					if #triggerCards > 0 then
						U.forEach(triggerCards, function(card) dilemmaDeck().putObject(card) end)
					end
					local storyCards = U.filter(getObjectsWithTag("StoryCard"), function(obj) return obj.type == "Card" end)
					table.sort(storyCards, function(a, b) return a.getPosition().y < b.getPosition().y end)
					local storyCardSpots = U.iMap(U.slice(U.clone(C.SnapPoints.Global), 1, 6),
						function(tData) return Vector(tData.position) end)
					local storyCardDatas = U.iMap(storyCards, function(sCard)
						return {
							obj = sCard,
							spot = U.findIndex(storyCardSpots, function(pos)
								return Vector.equals(sCard.getPosition(), Vector(pos), 1)
							end)
						}
					end)
					-- log(storyCardDatas)
					local storyArcs = {}
					U.iForEach(storyCardDatas, function(sData)
						if storyArcs[sData.spot] == nil then storyArcs[sData.spot] = 0 end
						storyArcs[sData.spot] = storyArcs[sData.spot] + 1
						DIR.SpawnStoryCardForCapture(sData.obj, sData.spot, storyArcs[sData.spot])
					end)


					local oldDilemmaDeck = getObjectsWithTag("DilemmaOld")[1]
					oldDilemmaDeck.setName("Game " .. S.getStateVal("gameState", "gameCount") .. " Dilemmas")
					O.MainStorage().putObject(oldDilemmaDeck)
					local tokens = getBoardTokens()
					tokens.Stability.destruct()
					U.forEach(tokens.resource, function(token) token.destruct() end)
					U.forEach(U.filter(getObjects(), function(obj)
						return U.hasAnyTag(obj, { "PowerToken", "CoinToken" }) and obj.type == "Generic" and
							not obj.hasTag("SourceObj")
							or U.hasAnyTag(obj, { "ResourceMarker", "StabilityMarker" }) and obj.type == "Tile" and
							not obj.hasTag("SourceObj")
					end), function(token) token.destruct() end)
					U.forEach({ "Stability", table.unpack(C.Resources) },
						function(lightRef) L.SetLightMode("light" .. lightRef, "off", nil, 0.5) end)
					V.LowerBalance()
					U.setPositionSlow(O.Leader.Figure(), C.Spots.Storage.LeaderFigure.position, 1)
					U.setRotationSlow(O.Leader.Figure(), C.Spots.Storage.LeaderFigure.rotation, 1)
					U.setPositionSlow(O.Moderator.Figure(), C.Spots.Storage.ModeratorFigure.position, 1)
					U.setRotationSlow(O.Moderator.Figure(), C.Spots.Storage.ModeratorFigure.rotation, 1)
					U.setPositionSlow(O.Leader.Light(), C.Spots.Storage.LeaderLight.position, 1)
					U.setRotationSlow(O.Leader.Light(), C.Spots.Storage.LeaderLight.rotation, 1)
					U.setPositionSlow(O.Moderator.Light(), C.Spots.Storage.ModeratorLight.position, 1)
					U.setRotationSlow(O.Moderator.Light(), C.Spots.Storage.ModeratorLight.rotation, 1)
					L.SetLightMode({ "lightLeader", "lightModerator" }, "off", nil, 1)
					S.setStateVal(nil, "gameState", "leader")
					S.setStateVal(nil, "gameState", "moderator")
				end,
				function()
					dilemmaDeck().shuffle()
					return DIR.RecallSecretAgendas()
				end,
				DIR.PromptForKingName,
				DIR.ADVANCE
			}
		end,
		SecretAgendas = function()
			return {
				DIR.InitSecretAgendas
			}
		end,
		SignOff = function()
			return {
				DIR.RecallSecretAgendas,
				function()
					return U.sequence(U.iMap(S.getPlayers(), function(player)
						return function()
							return U.RunSequence({
								function()
									return L.SetLightMode({ "lightBehind", "lightFront", "lightVote" }, "off", player, 2)
								end,
								function()
									P.ClearSeat(player.color)
									return 0
								end
							})
						end
					end), 1)
				end,
				function()
					MSG.Hide("scoringHUD")
					MSG.HideAll()
					isFirstCall = true
					L.SetLightMode(
					{ "lightMainTop", "lightMainBottom", "lightLectern", "lightMapAnkist", "lightMapWorld",
						"lightMapFocusA", "lightMapFocusB", "lightFeature" }, "off", nil, 2)
					return MSG.Splash("See You Next Week!", "AllMid")
				end,
				DIR.ADVANCE
			}
		end
	}
}
-- #endregion

-- #region Session Setup & Phase Control~
local storyArcs, storyKeys
function DIR.InitPreflight()
	MSG.Hide("sessionPreflightDisplay")
	MSG.Show("sessionInitDisplay")

	Global.call("UpdatePhaseDisplay")
	U.forEach(getObjectsWithTag("Private"), function(obj)
		local color = U.findColorTag(obj)
		if color then
			obj.setInvisibleTo(S.getOtherColors(color))
		end
	end)
	L.PrimeLights()
	U.forEach(O.UninteractableObjs, function(oFunc)
		oFunc().interactable = false
		oFunc().gizmo_selectable = false
	end)

	-- #region DEBUG
	Global.call("InitTestFuncButtons") -- Assign names to test function buttons
	if ISDEBUGGING then
		console.load()
	end
	-- #endregion

	U.forEach(U.getKeys(O.SpawnSources), function(spawnSourceRef)
		O.SpawnSources[spawnSourceRef]().addTag("SourceObj")
	end)

	UI.setValue("gameNumText",
		"~ During the Reign of " ..
		S.getStateVal("gameState", "kingTitle") .. " " .. S.getStateVal("gameState", "kingName") .. " ~")
	storyArcs = S.getStateVal("storyArcs")
	-- NOTE: Story Arc numbers correspond to display order, not necessarily to board slot.
	storyArcs = {
		storyHUD_Arc1 = [[The crowning of King Harald V was a dramatic one, attracting diplomats from all over the world. Underscoring this however was the King's own doubt in himself, which he only expressed to us, behind closed doors.

		However, to the common people of Ankist, they saw an additional grand display involving their King as he accepted a sword made from red iron as a gift from "merchants" of another kingdom. This blade, known as the Scarlet Tide, became a symbol for our nation's military might, with only the most elite soldiers being allowed to wield equipment forged from the miraculously strong metal.]],
		storyHUD_Arc2 = [[Merchants from distant Konfurtah brought rumors of the hiding place of the fabled Golden Map, prompting us to send an expedition into the Ivory Desert to retrieve it. We discovered it within the ancient temple of Chalice Peak, amidst the dessicated corpses of Sand Priestesses—an opulent version of the Cult of the Mother—along with references to the ancient "Sun Empire", known only from legends dating back to the ages before Ommad, the First King.

		Those legends claimed that the Golden Map leads to an endless fountain of liquid gold, but our expedition struggled to interpret its ancient writings. Ultimately a choice was made, sending our expedition into a deadly swamp filled with the vestiges of a lost civilization.]],
		storyHUD_Arc3 = [[The knights of the army are now roaming the Hedgehog Woods in northern Dualak, looking for the alleged "Witch of the Wilds."

		Rumors about her incredible ability to bend the laws of nature are becoming more common, and the knights are determined to find her before the situation escalates. Yet, those paths are narrow and murky, and those ancient woods hide many dangers ...]]
}
	storyKeys = U.getKeys(storyArcs)
end

local keyIndex = 1
function DIR.InitSession(isNotShuffling)
	local seqFuncs = {}
	if isFirstCall then
		isFirstCall = false
		table.insert(seqFuncs, function()
			MSG.HideAll()
			if S.isInMode(C.Modes.NONE) then
				MSG.Show("storyHUD")
				Wait.time(function() MSG.Hide("splashScreen") end, 2)
			else
				MSG.Hide("splashScreen")
			end
			return 2
		end)
	end
	if S.isInMode(C.Modes.NONE) then
		table.insert(seqFuncs, function()
			if storyKeys[keyIndex] ~= nil then
				if keyIndex > 1 then
					return U.RunSequence({
						function()
							local id = storyKeys[keyIndex - 1]
							-- log("Hiding " .. id)
							MSG.Hide(id)
							return 2
						end,
						function()
							local id = storyKeys[keyIndex]
							-- log("Showing " .. id)
							MSG.Show(id)
							UI.setValue(id .. "_Text", storyArcs[id])
							keyIndex = keyIndex + 1
							return 3
						end
					})
				else
					local id = storyKeys[keyIndex]
					-- log("Showing " .. id)
					MSG.Show(id)
						UI.setValue(id .. "_Text", storyArcs[id])
					keyIndex = keyIndex + 1
					return 3
				end
			else
				return U.RunSequence({
					function()
						MSG.Hide("storyHUD")
						MSG.Hide("sessionInitDisplay")
						MSG.Show("gameStatusDisplay")
						if S.isInMode(C.Modes.NONE) then
							DIR.ShowAutoAdvance()
						end
						return 3
					end,
					function()
						MSG.Splash("Seating Players", nil, 3)
						return P.AssignPlayerColors(isNotShuffling)
					end,
					function()
						P.InitializeSeatHandZones()
						local players = S.getPlayers()
						return {
							function() return #U.filter(players, function(pl) return pl.getHandCount() == 0 end) == 0 end
						}
					end,
					function()
						P.InitPlayerHouseCards()
						DIR.InitCountZones()
						DIR.InitControlPanel()
						return P.SetCamera("BehindScreen")
					end,
					function()
						if S.isInMode(C.Modes.NONE) then
							return DIR.ADVANCE()
						end
						return DIR.JumpToStatePhase()
					end
				})
			end
		end)
	else
		table.insert(seqFuncs, function()
			return U.RunSequence({
					function()
						MSG.Hide("storyHUD")
						MSG.Hide("sessionInitDisplay")
						MSG.Show("gameStatusDisplay")
						MSG.Splash("Seating Players", nil, 3)
						return P.AssignPlayerColors(isNotShuffling)
					end,
					function()
						P.InitializeSeatHandZones()
						local players = S.getPlayers()
						return {
							function() return #U.filter(players, function(pl) return pl.getHandCount() == 0 end) == 0 end
						}
					end,
					function()
						P.InitPlayerHouseCards()
						DIR.InitCountZones()
						DIR.InitControlPanel()
						return P.SetCamera("BehindScreen")
					end,
					function()
						if S.isInMode(C.Modes.NONE) then
							return DIR.ADVANCE()
						end
						return DIR.JumpToStatePhase()
					end
				})
			end)
	end
	return U.RunSequence(seqFuncs)
end

function DIR.InitCountZones()
	U.forEach(S.getPlayers(), function(player)
		-- Player Private Power
		local powerZone = P.GetPlayerZone(player, "Power")
		if powerZone then
			powerZone.call("SetCountTag", "PowerToken")
			powerZone.call("SetColor", Color.Yellow)
			powerZone.call("SetIcon", "powerIcon")
			powerZone.call("SetIconColor", Color(C.RootColors.Amber):setAt("a", 0.6))
			powerZone.call("Activate")
		end

		-- Player Private Coin
		local coinZone = P.GetPlayerZone(player, "Coin")
		if coinZone then
			coinZone.call("SetCountTag", "CoinToken")
			coinZone.call("SetColor", Color.Yellow)
			coinZone.call("SetIcon", "coinIcon")
			coinZone.call("SetIconColor", Color(C.RootColors.Amber):setAt("a", 0.6))
			coinZone.call("Activate")
		end

		V.InitCountZones(player)
	end)

	-- Balance Plinth
	local balanceZone = getObjectsWithTag("zoneBalance")[1]
	if balanceZone then
		balanceZone.call("SetCountTag", "PowerToken")
		balanceZone.call("SetColor", Color.Yellow)
		balanceZone.call("SetIcon", "powerIcon")
		balanceZone.call("SetIconColor", Color(C.RootColors.Amber):setAt("a", 0.6))
		balanceZone.call("Activate")
	end
end

function DIR.InitControlPanel()
	U.forEach(S.getPlayers(), function(player)
		UI.setValue("HUDControl_ToggleRowLabel_" .. player.color, S.getPlayerHouseName(player) .. " — ")
		UI.setValue("HUDControl_ClickRowLabel_" .. player.color, S.getPlayerHouseName(player) .. " — ")
		UI.setValue("HUDControl_QueryRowLabel_" .. player.color, S.getPlayerHouseName(player) .. " — ")
		UI.setAttribute("HUDControl_ToggleRowLabel_" .. player.color, "color", U.GetHex(Color[player.color]:lerp(Color.White, 0.5)))
		UI.setAttribute("HUDControl_ClickRowLabel_" .. player.color, "color", U.GetHex(Color[player.color]:lerp(Color.White, 0.5)))
		UI.setAttribute("HUDControl_QueryRowLabel_" .. player.color, "color", U.GetHex(Color[player.color]:lerp(Color.White, 0.5)))
	end)
end

local advanceThrottle = false
function DIR.ADVANCE(waitFunc, isThrottling)
	if isThrottling == nil then isThrottling = false end
	if isThrottling == true then
		if advanceThrottle == true then return end
		advanceThrottle = true
		Wait.time(function() advanceThrottle = false end, 2)
	else
		isThrottling = false
	end
	MSG.Hide("autoAdvanceGamePhase")
	MSG.Hide("advanceGamePhase")
	local mode, phase = S.getNextPhase()
	local function startPhase()
		S.setStateVal(mode, "gameState", "gameMode")
		S.setStateVal(phase, "gameState", "gamePhase")
		U.waitUntil(DIR.InitializePhase, MSG.HideAll, true)
	end

	if waitFunc then
		U.waitUntil(startPhase, waitFunc, false)
	else
		startPhase()
	end
end

function DIR.InitializePhase()
	Global.call("UpdatePhaseDisplay")
	DIR.ToggleAdvanceControls()
	local mode = S.getStateVal("gameState", "gameMode")
	local phase = S.getStateVal("gameState", "gamePhase")
	local seqFuncs = INITFUNCS[mode]
	if U.Type(seqFuncs) == "table" then
		seqFuncs = seqFuncs[phase]
	end
	if U.Type(seqFuncs) == "function" then
		seqFuncs = seqFuncs()
	end
	U.RunSequence(seqFuncs)
end

function DIR.JumpToStatePhase(mode, phase, isInitializing)
	if isInitializing == nil and (mode ~= nil or phase ~= nil) then
		isInitializing = true
	end
	if mode ~= nil then
		S.setStateVal(mode, "gameState", "gameMode")
		S.setStateVal(mode, "gameState", "gamePhase")
	end
	if phase ~= nil then
		S.setStateVal(phase, "gameState", "gamePhase")
	end
	Global.call("UpdatePhaseDisplay")

	return U.waitUntil(function()
		if isInitializing == true then return DIR.InitializePhase() end
		if isInitializing == false then return 0 end

		if S.isInPhase({ C.Phases.PLAY.DrawDilemma, C.Phases.PLAY.Discussion, C.Phases.PLAY.Vote }) then
			DIR.InitConsequencesQuery()
		end
		if S.isInMode({ C.Modes.CHRONSETUP, C.Modes.GAMESETUP, C.Modes.PLAY, C.Modes.END }) then
			MSG.Show("refHUDControls")
		end

		-- ... further logic to resync game environment to whatever point in the game we're at.
		P.ActivatePlayerScreenHUD()
		return L.InitLights()
	end, MSG.HideAll)
end

-- #endregion

-- #region House Selection ~

function DIR.GetUnselectedPlayers()
	return U.filter(S.getPlayers(), function(player)
		return not HOUSE_SELECTION[player.color] and not S.getPlayerVal(player, "house")
	end)
end

local function isHouseClaimed(houseName) return S.getPlayerOfHouse(houseName) ~= false end
local function getSelectingPlayer(houseName) return U.findIndex(HOUSE_SELECTION,
		function(hName) return houseName == hName end) end

function DIR.InitHouseSelectionHUD()
	if #DIR.GetUnselectedPlayers() == 0 then
		HOUSE_SELECTION.isComplete = true
	else
		U.forEach(C.Houses, function(houseName)
			if isHouseClaimed(houseName) then
				local claimColor = S.getPlayerOfHouse(houseName)
				if U.isIn(claimColor, Player.getAvailableColors()) then
					claimColor = Color[claimColor]
					UI.setAttribute("houseHUD_Dark_" .. houseName, "color",
						U.GetHex(Color(claimColor):lerp(Color(C.RootColors.PureBlack):setAt("a", 1), 0.5)))
					UI.setAttribute("houseHUD_Dark_" .. houseName, "active", "true")
				else
					claimColor = Color.Black
					UI.setAttribute("houseHUD_Dark_" .. houseName, "color",
						U.GetHex(Color(C.RootColors.PureBlack):setAt("a", 0.85)))
					UI.setAttribute("houseHUD_Dark_" .. houseName, "active", "true")
				end
				UI.setAttribute("houseHUD_BannerBW_" .. houseName, "color", U.GetHex(claimColor))
			end
		end)
		MSG.Show("houseSelectionHUD")
	end
end

function DIR.UnselectHouse(houseName)
	HOUSE_SELECTION[U.findIndex(HOUSE_SELECTION, function(hName) return houseName == hName end)] = nil
	UI.setAttribute("houseHUD_BannerBW_" .. houseName, "color", U.GetHex(Color.White))
	UI.setAttribute("houseHUD_Overlay_" .. houseName, "color", U.GetHex(Color.White))
	UI.setAttribute("houseHUD_Dark_" .. houseName, "active", "false")
	UI.setAttribute("houseHUD_Overlay_" .. houseName, "active", "false")
end

function DIR.SelectHouse(player, houseName)
	HOUSE_SELECTION[player.color] = houseName
	UI.setAttribute("houseHUD_BannerBW_" .. houseName, "color", U.GetHex(Color[player.color]))
	UI.setAttribute("houseHUD_Overlay_" .. houseName, "color", U.GetHex(Color[player.color]:setAt("a", 0.5)))
	UI.setAttribute("houseHUD_Dark_" .. houseName, "color", U.GetHex(Color[player.color]:setAt("a", 0.5)))
	UI.setAttribute("houseHUD_Dark_" .. houseName, "active", "true")
	UI.setAttribute("houseHUD_Overlay_" .. houseName, "active", "true")
	if #DIR.GetUnselectedPlayers() == 0 then
		Wait.time(function() HOUSE_SELECTION.isComplete = true end, 1.5)
	end
end

function DIR.HouseHUDClick(player, houseName)
	if isHouseClaimed(houseName) then return end
	if S.getPlayerHouse(player) then return end
	if not U.isIn(houseName, C.Houses) then return end
	local curSelection = getSelectingPlayer(houseName)
	if curSelection ~= nil and curSelection ~= player.color then return end
	local curHouse = HOUSE_SELECTION[player.color]
	if curHouse ~= nil then DIR.UnselectHouse(curHouse) end
	if curHouse ~= houseName then DIR.SelectHouse(player, houseName) end
end

function DIR.HouseHUDHoverOn(player, houseName)
	UI.setAttribute("houseHUD_Bright_" .. houseName .. "_" .. player.color, "active", "false")
	UI.setAttribute("houseHUD_Info_" .. houseName .. "_" .. player.color, "active", "false")
	MSG.Show("houseHUD_Bright_" .. houseName .. "_" .. player.color)
	MSG.Show("houseHUD_Info_" .. houseName .. "_" .. player.color)
end

function DIR.HouseHUDHoverOff(player, houseName)
	UI.setAttribute("houseHUD_Bright_" .. houseName .. "_" .. player.color, "active", "true")
	UI.setAttribute("houseHUD_Info_" .. houseName .. "_" .. player.color, "active", "true")
	MSG.Hide("houseHUD_Bright_" .. houseName .. "_" .. player.color)
	MSG.Hide("houseHUD_Info_" .. houseName .. "_" .. player.color)
end

-- #endregion

-- #region Game Setup~
function DIR.SpawnBoardTokens()
	local seqFuncs = {}

	table.insert(seqFuncs, function()
		Wait.time(function() L.SetLightMode("lightStability", "on") end, 1)
		return OU.SpawnFromSourceObj(O.SpawnSources.stabilityToken(), { "StabilityMarker" },
			C.Spots.Board.StabilityToken.center, Vector(0, 1, 0))
	end)

	U.iForEach(C.Resources, function(resName)
		table.insert(seqFuncs, function()
			return U.RunSequence({
				function()
					return OU.SpawnFromSourceObj(
						O.SpawnSources[string.lower(resName) .. "Token"](),
						{ "ResourceMarker", resName },
						C.Spots.Board.ResourceTokens[resName].center,
						Vector(0, 1, 0)
					)
				end,
				function()
					local tk = getBoardTokens().resource[resName]
					tk.setRotation(Vector(0, 180, U.randBetween(0, 1, true) * 180))
					tk.addForce(Vector(-0.07, 30, 0), 3)
					tk.addTorque(Vector(0, 0, 1.9), 3)
					U.waitUntil(function() DIR.UpdateTokenLight(resName) end, { 1, tk })
					return tk
				end
			})
		end)
	end)

	return U.RunSequence(seqFuncs, 1000, 1)
end

-- #region Secret Agendas~
function DIR.InitSecretAgendas()
	return U.RunSequence({
		function()
			U.Val("SecretAgendas", agendaDeck(), U.isGameObject(agendaDeck()) and agendaDeck().type == "Deck")
			P.SetCamera("Lectern")
			if S.isInMode(C.Modes.END) then
				return MSG.Splash("Preassigning Secret Agendas")
			else
				return MSG.Splash("Secret Agendas")
			end
		end,
		function()
			agendaDeck().setLock(true)
			L.SetLightMode("lightLectern", "spotlightDilemmaDeck", nil, 1)
			return {
				U.setPositionSlow(agendaDeck(), Vector(C.Spots.Staging.SecretAgenda.High.position), 1),
				U.setRotationSlow(agendaDeck(), Vector(C.Spots.Staging.SecretAgenda.High.rotation), 1)
			}
		end,
		function()
			U.setPositionSlow(agendaDeck(), Vector(C.Spots.Staging.SecretAgenda.Low.position), 0.5)
			U.setRotationSlow(agendaDeck(), Vector(C.Spots.Staging.SecretAgenda.Low.rotation), 0.5)
			return 0.25
		end,
		function()
			agendaDeck().shuffle()
			return 0.5
		end,
		function() return DIR.BurnTopAgenda() end,
		function()
			P.SetCamera("BehindScreen")
			L.SetLightMode("lightLectern", "off")
			L.SetLightMode("lightFront", "dim")
			return 1
		end,
		function() return DIR.DealSecretAgendas(P.GetLeastPrestigious(), agendaDeck()) end
	})
end

function DIR.BurnTopAgenda()
	local agendaCard
	return U.RunSequence({
		function()
			local isSpawned = false
			agendaCard = agendaDeck().takeObject({
				position = Vector({ -0.01, 6.95, 24.41 }),
				rotation = Vector({ 0, 0, 180 }),
				callback_function = function(obj)
					obj.setLock(true)
					obj.addTag("Burnt")
					isSpawned = true
				end
			})
			return function() return isSpawned == true end
		end,
		function()
			agendaCard.addTag("Burnt")
			return {
				U.setRotationSlow(agendaCard, Vector(C.Spots.Staging.SecretAgenda.Burnt.rotation), 2),
				U.setPositionSlow(agendaCard, Vector(C.Spots.Staging.SecretAgenda.Burnt.position), 2, "speedUp")
			}
		end
	})
end

function DIR.GetUnassignedSecretAgendas()
	local unassignedAgendas = U.filter(
		getObjectsWithTag("SecretAgenda"),
		function(agenda) return not U.hasAnyTag(agenda, { "Private", "Burnt" }) end
	)
	U.forEach(S.getPlayers(), function(player)
		U.forEach(player.getHandObjects(), function(obj)
			if obj.hasTag("SecretAgenda") then
				table.insert(unassignedAgendas, obj)
			end
		end)
	end)
	return unassignedAgendas
end

function DIR.DealSecretAgendas(playerRef, agendaSource)
	if agendaSource == nil then
		agendaSource = DIR.GetUnassignedSecretAgendas()
	end
	return U.RunSequence({
		function() return P.DealAll(agendaSource, playerRef) end,
		function()
			L.SetLightMode("lightPlayerSpotlight", "player" .. S.getPlayerNum(playerRef))
			return MSG.Splash("Choose Your Secret Agenda", playerRef)
		end
	})
end

function DIR.AssignSecretAgenda(playerRef, agendaCard, isDealingToNext)
	if isDealingToNext == nil then isDealingToNext = true end
	local player = S.getPlayer(playerRef)
	agendaCard.setLock(true)
	S.setPlayerVal(nil, player, "PreAssignedSecretAgenda")
	local agendaPos = P.getRotatedPlayerTransform(C.Spots.Player.SecretAgenda, player, 0)
	agendaCard.setInvisibleTo(S.getOtherColors(player))
	agendaCard.setTags({ "SecretAgenda", player.color, "Private",
		U.findTag(agendaCard, U.map(C.SecretAgendas, function(sa) return "SA_" .. sa end)) })
	U.setPositionSlow(agendaCard, agendaPos.position, 1)
	U.setRotationSlow(agendaCard, agendaPos.rotation, 1)

	if isDealingToNext then
		local nextPlayer = P.GetNextLeastPrestigious(player.color)
		if not nextPlayer then return DIR.EndSecretAgendas() end
		return DIR.DealSecretAgendas(nextPlayer)
	else
		return 1
	end
end

function DIR.GetAssignedAgendas()
	local assignedAgendas = {}
	U.forEach(S.getPlayers(), function(player)
		local agenda = getObjectsWithAllTags({ "SecretAgenda", "Private", player.color })[1]
		if agenda == nil then return end
		local agendaTag = U.findTag(agenda, U.map(C.SecretAgendas, function(sa) return "SA_" .. sa end))
		assignedAgendas[player.color] = string.gsub(agendaTag, "^SA_", "")
	end)
	return assignedAgendas
end

function DIR.DealPreassignedSecretAgendas(agendaData)
	local aDeck = getObjectsWithTag("SecretAgenda")[1]
	U.Val("SecretAgendas", aDeck, U.isGameObject(aDeck) and aDeck.type == "Deck")
	local seqFuncs = {}

	local takenAgendaGUIDs = {}

	U.forEach(agendaData, function(aData)
		local agendaObj = U.find(aDeck.getObjects(), function(cData)
			return U.isIn("SA_" .. aData.secretAgenda, cData.tags)
		end)
		if agendaObj then
			table.insert(takenAgendaGUIDs, agendaObj.guid)
			table.insert(seqFuncs, function()
				L.PulseLight("lightFront", aData.color)
				aDeck.takeObject({
					position = Vector({ -0.01, 6.95, 24.41 }),
					rotation = Vector({ 0, 0, 180 }),
					guid = agendaObj.guid,
					callback_function = function(obj)
						DIR.AssignSecretAgenda(aData.color, obj, false)
					end
				})
				if aDeck.remainder then aDeck.remainder.setLock(true) end
			end)
		end
	end)

	local burntAgendaGUIDs = U.filter(aDeck.getObjects(),
		function(aData) return not U.isIn(aData.guid, takenAgendaGUIDs) end)

	local lastAgendaGUID = U.pop(burntAgendaGUIDs).guid

	if #burntAgendaGUIDs > 0 then
		U.forEach(burntAgendaGUIDs, function(guid)
			table.insert(seqFuncs, function()
				aDeck.takeObject({
					position = C.Spots.Staging.SecretAgenda.Burnt.position,
					rotation = C.Spots.Staging.SecretAgenda.Burnt.rotation,
					guid = guid,
					callback_function = function(obj)
						obj.addTag("Burnt")
						obj.setLock(true)
					end
				})
				if aDeck.remainder then aDeck.remainder.setLock(true) end
			end)
		end)
	end
	if lastAgendaGUID ~= nil then
		table.insert(seqFuncs, function()
			local card = getObjectFromGUID(lastAgendaGUID)
			if card == nil then return U.error("Last Agenda GUID ('" .. lastAgendaGUID .. "') Not On Table!") end
			card.setLock(true)
			card.addTag("Burnt")
			card.setPositionSmooth(C.Spots.Staging.SecretAgenda.Burnt.position)
			card.setRotationSmooth(C.Spots.Staging.SecretAgenda.Burnt.rotation)
		end)
	end


	return U.RunSequence({
		function()
			P.SetCamera("BehindScreen")
			return MSG.Splash("Secret Agendas (Preassigned)")
		end,
		function()
			aDeck.setLock(true)
			L.SetLightMode("lightLectern", "spotlightDilemmaDeck", nil, 1)
			return {
				U.setPositionSlow(aDeck, Vector(C.Spots.Staging.SecretAgenda.High.position), 1),
				U.setRotationSlow(aDeck, Vector(C.Spots.Staging.SecretAgenda.High.rotation), 1)
			}
		end,
		function()
			U.setPositionSlow(aDeck, Vector(C.Spots.Staging.SecretAgenda.Low.position), 0.5)
			U.setRotationSlow(aDeck, Vector(C.Spots.Staging.SecretAgenda.Low.rotation), 0.5)
			return 0.25
		end,
		function()
			L.SetLightMode("lightLectern", "off")
			L.SetLightMode("lightFront", "dim")
			return 1
		end,
		function()
			return U.sequence(seqFuncs, 1)
		end
	})
end

function DIR.EndSecretAgendas()
	L.SetLightMode("lightLectern", "ambient")
	L.SetLightMode("lightFront", "ambient")
	L.SetLightMode("lightPlayerSpotlight", "off")

	local heldAgendas = {}

	U.forEach(S.getPlayers(), function(player)
		heldAgendas = U.concat(heldAgendas,
			U.filter(player.getHandObjects(), function(obj) return obj.hasTag("SecretAgenda") end))
	end)

	U.forEach(heldAgendas, function(obj)
		obj.use_hands = false
		obj.setLock(true)
		obj.addTag("Burnt")
		obj.setPositionSmooth(C.Spots.Staging.SecretAgenda.Burnt.position)
		obj.setRotationSmooth(C.Spots.Staging.SecretAgenda.Burnt.rotation)
		Wait.time(function() obj.use_hands = true end, 0.5)
	end)

	if S.isInMode(C.Modes.END) then
		U.forEach(DIR.GetAssignedAgendas(), function(agenda, pColor)
			S.setPlayerVal(agenda, pColor, "PreAssignedSecretAgenda")
		end)
	end
	Wait.time(DIR.ADVANCE, 4)
end

function DIR.RecallSecretAgendas()
	L.SetLightMode("lightLectern", "ambient")
	L.SetLightMode("lightFront", "ambient")
	L.SetLightMode("lightPlayerSpotlight", "off")
	local secretAgendas = getObjectsWithTag("SecretAgenda")
	-- U.forEach(S.getPlayers(), function(player)
	-- 	secretAgendas = U.concat(secretAgendas, U.filter(player.getHandObjects(), function(obj) return obj.hasTag("SecretAgenda") end))
	-- end)
	U.Assert("Six secret agendas found?", #secretAgendas == 6)
	local stagingPos = Vector(C.Spots.Storage.SecretAgenda.position)
	return {
		U.sequence(U.map(secretAgendas, function(sA)
			return function()
				sA.use_hands = false
				local sATag = U.findTag(sA,
					{ "SA_Opportunist", "SA_Opulent", "SA_Rebel", "SA_Extremist", "SA_Moderate", "SA_Greedy" })
				sA.setTags({ "SecretAgenda", sATag })
				stagingPos:add(Vector(0, 0.2, 0))
				sA.setPositionSmooth(stagingPos)
				sA.setRotationSmooth(C.Spots.Storage.SecretAgenda.rotation)
				sA.setInvisibleTo()
				sA.setLock(false)
				Wait.time(function() sA.use_hands = true end, 1)
			end
		end)),
		function() return #getObjectsWithTag("SecretAgenda") == 1 end
	}
end

-- #endregion
function DIR.SpawnStartingPlayerPower()
	return U.RunSequence(U.map(S.getPlayers(), function(player)
		local numPower = 8 + (S.getPlayerVal(player, "startingPowerBonus") or 0)
		return function()
			L.PulseLight("lightFront", player)
			return { 1, P.SpawnPower(player, numPower) }
		end
	end))
end

function DIR.SpawnStartingPlayerCoins()
	return U.RunSequence(U.map(S.getPlayers(), function(player)
		local numCoins = 10 + (S.getPlayerVal(player, "startingCoinsBonus") or 0)
		return function() return { 1, P.SpawnCoins(player, numCoins) } end
	end))
end

-- #endregion

-- #region Game Round~

-- #region Player Prompting: Stickers, Envelopes, King Name~
local isSimpleFetchingSticker = false
function DIR.PromptForSticker(player, isSimpleFetch)
	isSimpleFetchingSticker = isSimpleFetch == true
	DIR.ShowManualAdvance()
	UI.setAttribute("stickerQuery_" .. player.color, "active", "false")
	MSG.Show("stickerQuery_" .. player.color)
	UI.setAttribute("stickerQuery_" .. player.color, "text", " ")
end

function DIR.ConfirmFetchSticker(player, stickerKey)
	U.forEach(S.getPlayers(), function(ply) MSG.Hide("stickerQuery_" .. ply.color) end)
	local query = { Yes = "true", No = "false" }
	return U.RunSequence({
		function()
			return MSG.SplashQuery(
				"Confirm Sticker Key '" .. stickerKey .. "'",
				P.GetPlayerName(player),
				query,
				player
			)
		end,
		function()
			if query.response == "true" then
				if isSimpleFetchingSticker then
					isSimpleFetchingSticker = false
					return DIR.FetchStickerSimple(stickerKey)
				else
					return DIR.FetchSticker(stickerKey)
				end
			else
				return DIR.PromptForSticker(player, isSimpleFetchingSticker)
			end
		end
	})
end

local isSimpleFetchingEnvelope = false
function DIR.PromptForEnvelope(player, isSimpleFetch)
	isSimpleFetchingEnvelope = isSimpleFetch == true
	DIR.ShowManualAdvance()
	UI.setAttribute("envelopeQuery_" .. player.color, "active", "false")
	MSG.Show("envelopeQuery_" .. player.color)
	UI.setAttribute("envelopeQuery_" .. player.color, "text", " ")
end

function DIR.ConfirmFetchEnvelope(player, envKey)
	U.forEach(S.getPlayers(), function(ply) MSG.Hide("envelopeQuery_" .. ply.color) end)
	local query = { Yes = "true", No = "false" }
	return U.RunSequence({
		function()
			return MSG.SplashQuery(
				"Confirm Envelope Key '" .. envKey .. "'",
				P.GetPlayerName(player),
				query,
				player
			)
		end,
		function()
			-- MSG.HideAll("splashQuery_")
			if query.response == "true" then
				if isSimpleFetchingEnvelope then
					isSimpleFetchingEnvelope = false
					return DIR.FetchEnvelopeSimple(envKey)
				else
					return DIR.FetchEnvelope(envKey)
				end
			else
				return DIR.PromptForEnvelope(player, isSimpleFetchingEnvelope)
			end
		end
	})
end
-- lua S.setStateVal("King", "gameState", "kingTitle"); MSG.Hide("kingQuery_Orange"); S.setStateVal("Drake I of House Hedwyn", "gameState", "kingName")
function DIR.PromptForKingName()
	local player = S.getPlayer(U.sample(S.getStateVal("gameState", "winners")))
	S.setStateVal(nil, "gameState", "kingName")
	UI.setAttribute("kingQuery_" .. player.color, "active", "false")
	MSG.Show("kingQuery_" .. player.color)
	UI.setValue("kingQuery_kingTitle_" .. player.color, S.getStateVal("gameState", "kingTitle"))
	UI.setValue("kingQuery_kingHouse_" .. player.color, "of House " .. S.getPlayerHouseName(player))
	UI.setAttributes("kingQuery_input_" .. player.color, {
		text = " ",
		interactable = "true"
	})
	UI.setAttribute("kingQuery_inputImage_" .. player.color, "color", "#FFDD0011")
	return {
		function() return S.getStateVal("gameState", "kingName") ~= nil end,
		MSG.Splash("Naming Next Monarch")
	}
end

-- #endregion


-- #region Fetching: Stickers, Envelopes~
function DIR.FetchStickerSimple(stickerKey)

	local stickerContainer = O.SecretContainers.Stickers()
	local stickerGUID = OU.FindContainedObjGUID(stickerContainer, function(objData)
		return string.lower(objData.name) == string.lower(stickerKey)
	end)

	if not stickerGUID then
		U.Alert("Sticker '" .. stickerKey .. "' Not Found! Check Case & Spelling", Color(1, 0, 0))
		return
	end

	stickerContainer.takeObject({
		position = Vector(C.Spots.Staging.Sticker.Display.position):add(Vector(0, 5, 0)),
		rotation = Vector(C.Spots.Staging.Sticker.Display.rotation),
		guid = stickerGUID,
		callback_function = function(obj)
			obj.addTag("ChronicleSticker")
			obj.setLock(false)
		end
	})
end

function DIR.FetchSticker(stickerKey)
	local stickerContainer = O.SecretContainers.Stickers()
	local stickerGUID = OU.FindContainedObjGUID(stickerContainer, function(objData)
		return string.lower(objData.name) == string.lower(stickerKey)
	end)

	if not stickerGUID then
		U.Alert("Sticker '" .. stickerKey .. "' Not Found! Check Case & Spelling", Color(1, 0, 0))
		return
	end

	local sticker
	local displayedDilemma = getObjectsWithAllTags({ "Dilemma", "OnDisplay" })[1]

	return U.RunSequence({
		function()
			P.SetCamera("Lectern")
			if displayedDilemma ~= nil then
				local yRot = displayedDilemma.getRotation().y
				local outcome = yRot > 170 and "Nay" or "Aye"
				return {
					U.setPositionSlow(displayedDilemma, C.Spots.Main.Dilemma["faceUp" .. outcome .. "Shrink"].position,
						0.5),
					U.setScaleSlow(displayedDilemma, C.Spots.Main.Dilemma["faceUp" .. outcome .. "Shrink"].scale, 0.5),
					L.SetLightMode("lightLectern", "spotlightSticker", nil, 0.25)
				}
			else
				return L.SetLightMode("lightLectern", "spotlightSticker", nil, 0.25)
			end
		end,
		function()
			U.setPositionSlow(stickerContainer, C.Spots.Staging.Lectern.Stickers.position)
			U.setRotationSlow(stickerContainer, C.Spots.Staging.Lectern.Stickers.rotation)
			return { stickerContainer, L.SetLightMode("lightLectern", "spotlightPlinth", nil, 0.1) }
		end,
		function()
			stickerContainer.takeObject({
				position = C.Spots.Staging.Lectern.Display.position,
				rotation = C.Spots.Staging.Lectern.Display.rotation,
				guid = stickerGUID,
				callback_function = function(obj)
					sticker = obj
					sticker.addTag("ChronicleSticker")
					sticker.setLock(true)
				end
			})
			return function() return sticker ~= nil end
		end,
		function()
			U.setPositionSlow(stickerContainer, C.Spots.Storage.Stickers.position)
			U.setRotationSlow(stickerContainer, C.Spots.Storage.Stickers.rotation)
			return 0.3
		end,
		function() return L.SetLightMode("lightLectern", "spotlightTransit", nil, 0.3) end,
		function()
			sticker.setPositionSmooth(Vector(C.Spots.Staging.Sticker.Display.position):add(Vector(0, 5, 0)))
			sticker.setRotationSmooth(Vector(C.Spots.Staging.Sticker.Display.rotation))
			return {
				sticker,
				L.SetLightMode("lightLectern", "spotlightDilemmaDeck")
			}
		end,
		function()
			sticker.setLock(false)
			return {
				sticker,
				1.5
			}
		end,
		function()
			P.SetCamera("Stickers")
			return function()
				return not Vector.equals(sticker.getPosition(),
					Vector(C.Spots.Staging.Sticker.Display.position), 1)
			end
		end,
		function() return L.SetLightMode({ "lightLectern" }, "ambient", nil, 0.5) end
	})
end

function DIR.FetchEnvelopeSimple(envKey)

	U.Assert("DIR.FetchEnvelope", envKey, "string")
	local envContainer = O.SecretContainers.Envelopes()
	U.Assert("DIR.FetchEnvelope", envContainer, "Object")

	local envGUID = OU.FindContainedObjGUID(envContainer, function(objData)
		return string.lower(objData.name) == string.lower(envKey)
	end)

	if not envGUID then return U.Alert("Envelope '" .. envKey .. "' Not Found! Check Case & Spelling", Color(1, 0, 0)) end

	local envDeck, storyCard

	return U.RunSequence({
		function()
			envContainer.takeObject({
				position = C.Spots.Staging.Lectern.Display.position,
				rotation = C.Spots.Staging.Lectern.Display.rotation,
				guid = envGUID,
				callback_function = function(obj)
					envDeck = obj
					envDeck.setLock(true)
				end
			})
			return function() return envDeck ~= nil end
		end,
		function()
			envDeck.takeObject({
				position = C.Spots.Staging.Lectern.TopCard.position,
				rotation = C.Spots.Staging.Lectern.TopCard.rotation,
				callback_function = function(obj)
					storyCard = obj
					storyCard.setTags({ "StoryCard" })
					storyCard.setLock(true)
					storyCard.use_hands = false
					storyCard.use_snap_points = true
					storyCard.sticky = false
				end
			})
			return function() return storyCard ~= nil end
		end,
		function()
			storyCard.setPositionSmooth(Vector(C.Spots.Staging.StoryCard.Display.position):add(Vector(0, 5, 0)))
			storyCard.setRotationSmooth(Vector(C.Spots.Staging.StoryCard.Display.rotation))
			storyCard.setLock(false)
			return {storyCard, 1.5}
		end,
		function()
			local coverCard = O.Pieces.CoverCard()
			coverCard.setLock(true)
			coverCard.setPositionSmooth(coverCard.getPosition():add(Vector(0, 1, 0)))
			envDeck.setPositionSmooth(C.Spots.Main.Dilemma.aboveDeck.position)
			envDeck.setRotationSmooth(C.Spots.Main.Dilemma.aboveDeck.rotation)
			envDeck.setLock(false)
		end
	})

end
function DIR.FetchEnvelope(envKey)
	U.Assert("DIR.FetchEnvelope", envKey, "string")
	local envContainer = O.SecretContainers.Envelopes()
	U.Assert("DIR.FetchEnvelope", envContainer, "Object")

	local envGUID = OU.FindContainedObjGUID(envContainer, function(objData)
		return string.lower(objData.name) == string.lower(envKey)
	end)

	if not envGUID then return U.Alert("Envelope '" .. envKey .. "' Not Found! Check Case & Spelling", Color(1, 0, 0)) end

	local envDeck, storyCard

	return U.RunSequence({
		function()
			P.SetCamera("Lectern")
			if displayCard() ~= nil then
				if displayCard().hasTag("Dilemma") then
					local yRot = displayCard().getRotation().y
					local outcome = yRot > 170 and "Nay" or "Aye"
					return {
						U.setPositionSlow(displayCard(), C.Spots.Main.Dilemma["faceUp" .. outcome .. "Shrink"].position,
							0.5),
						U.setScaleSlow(displayCard(), C.Spots.Main.Dilemma["faceUp" .. outcome .. "Shrink"].scale, 0.5),
						L.SetLightMode("lightLectern", "spotlightEnvelope", nil, 0.25)
					}
				elseif displayCard().hasTag("TriggerCard") then
					return {
						U.setPositionSlow(displayCard(), C.Spots.Main.Trigger.faceUpShrink.position, 0.5),
						U.setScaleSlow(displayCard(), C.Spots.Main.Trigger.faceUpShrink.scale, 0.5),
						L.SetLightMode("lightLectern", "spotlightEnvelope", nil, 0.25)
					}
				end
			else
				return L.SetLightMode("lightLectern", "spotlightEnvelope", nil, 0.25)
			end
		end,
		function()
			U.setPositionSlow(envContainer, C.Spots.Staging.Lectern.Envelopes.position)
			U.setRotationSlow(envContainer, C.Spots.Staging.Lectern.Envelopes.rotation)
			return { envContainer, L.SetLightMode("lightLectern", "spotlightPlinth", nil, 0.1) }
		end,
		function()
			envContainer.takeObject({
				position = C.Spots.Staging.Lectern.Display.position,
				rotation = C.Spots.Staging.Lectern.Display.rotation,
				guid = envGUID,
				callback_function = function(obj)
					envDeck = obj
					envDeck.setLock(true)
				end
			})
			return function() return envDeck ~= nil end
		end,
		function()
			U.setPositionSlow(envContainer, C.Spots.Storage.Envelopes.position)
			U.setRotationSlow(envContainer, C.Spots.Storage.Envelopes.rotation)
			return 0.3
		end,
		function()
			envDeck.takeObject({
				position = C.Spots.Staging.Lectern.TopCard.position,
				rotation = C.Spots.Staging.Lectern.TopCard.rotation,
				-- smooth = false,
				callback_function = function(obj)
					storyCard = obj
					storyCard.setTags({ "StoryCard" })
					storyCard.setLock(true)
					storyCard.use_hands = false
					storyCard.use_snap_points = true
					storyCard.sticky = false
				end
			})
			return function() return storyCard ~= nil end
		end,
		function()
			return L.SetLightMode("lightLectern", "spotlightTransit", nil, 0.3)
		end,
		function()
			storyCard.setPositionSmooth(Vector(C.Spots.Staging.StoryCard.Display.position):add(Vector(0, 5, 0)))
			storyCard.setRotationSmooth(Vector(C.Spots.Staging.StoryCard.Display.rotation))
			return {
				storyCard,
				L.SetLightMode("lightLectern", "storyCard")
			}
		end,
		function()
			storyCard.setLock(false)
			return {
				storyCard,
				1.5
			}
		end,
		function()
			MSG.Splash(P.GetLeaderName() .. ", the Story Card is Yours", P.GetLeader())
			return P.SetCamera("Stickers")
		end,
		function()
			L.SetLightMode({ "lightMainTop", "lightMainBottom" }, "ambient", nil, 2)
			return function()
				return not Vector.equals(storyCard.getPosition(),
					Vector(C.Spots.Staging.StoryCard.Display.position), 1)
			end
		end,
		function()
			local coverCard = O.Pieces.CoverCard()
			coverCard.setLock(true)
			coverCard.setPositionSmooth(coverCard.getPosition():add(Vector(0, 1, 0)))
			U.setPositionSlow(envDeck, C.Spots.Main.Dilemma.aboveDeck.position)
			U.setRotationSlow(envDeck, C.Spots.Main.Dilemma.aboveDeck.rotation)
			envDeck.setLock(false)
			-- DIR.PromptLeaderToHandleEnvelope(envDeck)
			return L.SetLightMode({ "lightLectern" }, "ambient", nil, 0.5)
		end
	})
end

-- #endregion

-- #region Dilemma Cards & Consequences Query~
function DIR.GetDilemmaDeck()
	local coverCard = O.Pieces.CoverCard()
	return U.findBelowObject(coverCard, function(obj) return obj.type == "Card" or obj.type == "Deck" end)[1]
end

function DIR.DrawDilemmaCard()
	local dilemmaSource = DIR.GetDilemmaDeck()
	local drawnCard
	if dilemmaSource.type == "Deck" then
		dilemmaSource.takeObject({
			position = C.Spots.Staging.DilemmaDraw.position,
			rotation = C.Spots.Staging.DilemmaDraw.rotation,
			top = false,
			callback_function = function(obj)
				obj.use_hands = false
				obj.use_snap_points = true
				obj.addTag("OnDisplay")
				obj.setLock(true)
				if obj.hasTag("TriggerCard") then
					S.setStateVal("trigger", "roundState", "displayedCardType")
				else
					S.setStateVal("dilemma", "roundState", "displayedCardType")
				end
				drawnCard = obj
			end
		})
		return function() return drawnCard ~= nil end
	elseif dilemmaSource.type == "Card" then
		drawnCard = dilemmaSource
		drawnCard.use_hands = false
		drawnCard.use_snap_points = true
		drawnCard.setLock(true)
		drawnCard.addTag("OnDisplay")
		if drawnCard.hasTag("TriggerCard") then
			S.setStateVal("trigger", "roundState", "displayedCardType")
		else
			S.setStateVal("dilemma", "roundState", "displayedCardType")
		end
		return {
			U.setPositionSlow(drawnCard, C.Spots.Staging.DilemmaDraw.position),
			U.setRotationSlow(drawnCard, C.Spots.Staging.DilemmaDraw.rotation)
		}
	end
end

function DIR.SpawnReferenceDilemmas(dilemmaCard)
	U.forEach(S.getPlayers(), function(player)
		local angle = S.getPlayerAngle(player)
		local targetTransform = OU.RotateByAngle(C.Spots.Player.DilemmaSpot, angle)
		local tags = { "RefDilemma" }
		OU.SpawnFromSourceObj(dilemmaCard, tags, targetTransform, nil, nil, true)
	end)
end

function DIR.AddToDilemmaDeck(dilemmas, isSecondTry)
	if isSecondTry == nil then isSecondTry = false end
	local coverCard = O.Pieces.CoverCard()
	U.Assert("DIR.AddToDilemmaDeck", coverCard, "Object")

	local seqFuncs = {}

	if dilemmas == nil then
		dilemmas = U.findAboveObject(coverCard, function(obj) return obj.type == "Deck" or obj.type == "Card" end, { box = true })
		if #dilemmas > 1 and not isSecondTry then
			return U.RunSequence({
				function() return 2 end,
				function() return DIR.AddToDilemmaDeck(nil, true) end
			})
		end
		U.Val("DIR.AddToDilemmaDeck", dilemmas, #dilemmas <= 1,
			"Multiple sources of dilemmas found above Cover Card. Consolidate them into a deck.")
		dilemmas = dilemmas[1]
		if dilemmas == nil then return 0 end
		table.insert(seqFuncs, function()
			return {
				U.setPositionSlow(dilemmas, dilemmas.getPosition():add(Vector(0, 4, 4))),
				U.setRotationSlow(dilemmas, coverCard.getRotation())
			}
		end)
	end

	U.Assert("DIR.AddToDilemmaDeck: Object Test", dilemmas, "Object")
	U.Assert("DIR.AddToDilemmaDeck: Deck or Card Test", U.isIn(dilemmas.type, { "Card", "Deck" }))

	coverCard.setLock(true)
	dilemmas.setLock(true)

	table.insert(seqFuncs, function()
		return {
			U.setPositionSlow(coverCard, coverCard.getPosition():add(Vector(0, 2, -3))),
			U.setRotationSlow(coverCard, coverCard.getRotation():add(Vector(0, 0, 70)))
		}
	end)

	local dilemmaCardDestPos = coverCard.getPosition():add(Vector(0, 4, 0))
	local dilemmaCardDestRot = coverCard.getRotation()

	local function addNextDilemma()
		dilemmaCardDestPos:add(Vector(0, 0.4, 0))
		if dilemmas.type == "Deck" then
			dilemmas.takeObject({
				position = dilemmaCardDestPos,
				rotation = dilemmaCardDestRot,
				callback_function = function(obj)
					obj.use_hands = false
					if U.hasDecal(obj, "Trigger") then
						obj.setTags({"TriggerCard"})
					else
						obj.setTags({ "Dilemma" })
					end
					obj.setLock(false)
				end
			})
			if dilemmas.remainder ~= nil then
				dilemmas.remainder.setLock(true)
				dilemmas = dilemmas.remainder
			end
			return 0.3
		elseif dilemmas.type == "Card" then
			U.RunSequence({
				function()
					dilemmas.use_hands = false
					if U.hasDecal(dilemmas, "Trigger") then
						dilemmas.setTags({ "TriggerCard" })
					else
						dilemmas.setTags({ "Dilemma" })
					end
					dilemmas.setPositionSmooth(dilemmaCardDestPos)
					dilemmas.setRotationSmooth(dilemmaCardDestRot)
					return dilemmas
				end,
				function()
					dilemmas.setLock(false)
				end
			})
			return 0.3
		end
	end

	if dilemmas.type == "Deck" then
		for i = 1, #dilemmas.getObjects() do
			table.insert(seqFuncs, addNextDilemma)
		end
	else
		table.insert(seqFuncs, addNextDilemma)
	end

	table.insert(seqFuncs, function()
		return {
			U.setPositionSlow(coverCard, C.Spots.Main.CoverCard.Closed.position),
			U.setRotationSlow(coverCard, C.Spots.Main.CoverCard.Closed.rotation)
		}
	end)
	table.insert(seqFuncs, function()
		coverCard.setLock(false)
		return { coverCard, 0.1 }
	end)
	table.insert(seqFuncs, function()
		DIR.GetDilemmaDeck().shuffle()
	end)

	return U.RunSequence(seqFuncs)
end

function DIR.InitConsequencesQuery(playerRef)
	local player = playerRef == nil and P.GetModerator() or S.getPlayer(playerRef)
	U.forEach({ "Sticker", table.unpack(C.Resources) }, function(resource)
		U.forEach({ "P", "N" }, function(outcome)
			local stateVal = S.getStateVal("roundState", "consequences", outcome, resource) or "O"
			U.forEach({ "O", "P", "N" }, function(conType)
				if conType == "O" then
					UI.setAttribute(
					"consequence_" .. outcome .. "_" .. conType .. "_" .. resource .. "_" .. player.color, "active",
						tostring(conType == stateVal))
				else
					UI.setAttribute(
					"consequence_" .. outcome .. "_" .. conType .. "_" .. resource .. "_" .. player.color, "active",
						tostring(conType == stateVal))
					UI.setAttribute("conDisplay_" .. outcome .. "_" .. conType .. "_" .. resource, "active",
						tostring(conType == stateVal))
				end
			end)
		end)
	end)
	if S.isInPhase(C.Phases.PLAY.DrawDilemma) then
		MSG.Show("consequencesQuery_" .. player.color)
	end
	MSG.Show("consequencesSidebar")
	return 0.5
end

-- #endregion

-- #region Vote Turn Control~
function DIR.DisplayPassHUD(playerRef)
	local player = S.getPlayer(playerRef)
	return U.RunSequence({
		function()
			UI.setAttribute("turnHUD_" .. player.color, "active", "false")
			V.UpdateHUD(player, true)
			return 0.5
		end,
		function()
			MSG.Show("turnHUD_" .. player.color)
			return 0.5
		end
	})
end

function DIR.TurnHUDClick(action, color)
	U.RunSequence({
		function()
			MSG.Hide("turnHUD_" .. color)
			return V.EndTurn(action == "passMod")
		end,
		function()
			local nextPlayer = DIR.GetNextVotingPlayer()
			if nextPlayer == nil then return DIR.ADVANCE() end

			return U.RunSequence({
				function()
					DIR.DisplayPassHUD(nextPlayer)
					return V.StartTurn(nextPlayer)
				end
			})
		end
	})
end

function DIR.GetNextVotingPlayer()
	local curPlayerColor = S.getStateVal("roundState", "currentTurn")
	local activePlayers = U.filter(Player.getAvailableColors(), function(pColor)
		return pColor == curPlayerColor or
		U.isIn(S.getStateVal("turnState", pColor, "vote"), { false, "Aye", "Nay" })
	end)
	local playerIndex = U.findIndex(activePlayers, function(pColor) return pColor == curPlayerColor end)
	local nextPlayerColor
	if playerIndex == #activePlayers then
		nextPlayerColor = activePlayers[1]
	else
		nextPlayerColor = activePlayers[playerIndex + 1]
	end

	if P.GetLeader().color == nextPlayerColor or not U.isIn(S.getPlayerVoteStatus(nextPlayerColor), { false,
			"Aye", "Nay" }) then
		return nil
	end

	return S.getPlayer(nextPlayerColor)
end


-- #endregion

-- #region Momentum & Stability~
function DIR.UpdateTokenLight(resource, momentum)
	if resource == nil then return U.iMap(U.concat({ "Stability" }, C.Resources), function(tokenRef) return DIR.UpdateTokenLight(tokenRef) end) end
	if resource == "Stability" then
		return L.SetLightMode("lightStability", "on", nil, 0.5)
	end
	if momentum == nil then momentum = getTokenMomentums()[resource] end
	local dir = momentum < 0 and "Down" or "Up"
	momentum = math.abs(momentum)
	return L.SetLightMode("light" .. resource, "momentum" .. dir .. momentum, nil, 0.5)
end

function DIR.GetStabilityBump()
	local stabilityPos = S.getStateVal("roundState", "boardTokens", "positions", "Stability")
	local curPositions = DIR.GetTokenPositionsFromBoard()
	U.forEach(C.Resources, function(resource)
		local prevPos = S.getStateVal("roundState", "boardTokens", "positions", resource)
		local curPos = curPositions[resource]
		local deltaPos = curPos - prevPos
		stabilityPos = math.max(math.min(stabilityPos + deltaPos, 19), 1)
	end)
	local boardStabilityPos = curPositions.Stability
	return stabilityPos - boardStabilityPos
end

function DIR.BumpToken(tokenName, count)
	local boardTokens = getBoardTokens()

	local function bumpToken(token, unitForceVector, count, lightName)
		local forceVector = Vector(unitForceVector):scale(count > 0 and Vector(1, 1, 1) or Vector(1, 1, -1))
		local absCount = math.abs(count)
		if absCount <= 3 then
			if lightName then
				Wait.time(function() DIR.UpdateTokenLight(lightName) end, 0.6)
			end
			return token.addForce(Vector(forceVector):scale(Vector(1, 1, math.abs(count))), 3)
		else
			local seqFuncs = {}
			while absCount >= 3 do
				absCount = absCount - 3
				table.insert(seqFuncs, function() bumpToken(token, forceVector, 3, lightName) end)
			end
			while absCount >= 2 do
				absCount = absCount - 2
				table.insert(seqFuncs, function() bumpToken(token, forceVector, 2, lightName) end)
			end
			while absCount >= 1 do
				absCount = absCount - 1
				table.insert(seqFuncs, function() bumpToken(token, forceVector, 1, lightName) end)
			end
			return U.sequence(seqFuncs, 0.5)
		end
	end

	local tokenPos = DIR.GetTokenPositionsFromBoard()
	local min, max = 1, tokenName == "Stability" and 19 or 17
	if tokenName == "Stability" and (tokenPos.Stability == 19 or tokenPos.Stability == 1) then
		return 0
	end
	count = math.max(math.min(count, max - tokenPos[tokenName]), min - tokenPos[tokenName])

	return bumpToken(
		tokenName == "Stability" and boardTokens.Stability or boardTokens.resource[tokenName],
		Vector(0, 15, 3.5),
		count,
		tokenName
	)
end

-- #endregion

-- #endregion

-- #region End of Game~
function DIR.EndGame() return DIR.JumpToStatePhase(C.Modes.END, C.Phases.END.Score) end

function DIR.GetSecretAgenda(playerRef)
	local player = S.getPlayer(playerRef)
	local secretAgendaCard = getObjectsWithAllTags({ player.color, "SecretAgenda" })
	U.Val("DIR.GetSecretAgenda", secretAgendaCard, #secretAgendaCard == 1,
		"Unable to find " .. player.color .. "'s Secret Agenda!")
	secretAgendaCard = secretAgendaCard[1]
	local secretAgendaTag = U.find(secretAgendaCard.getTags(), function(tag) return string.match(tag, "^SA_") end)
	U.Val("DIR.GetSecretAgenda", secretAgendaTag, U.Type(secretAgendaTag) == "string",
		"Unable to find " .. player.color .. "'s Secret Agenda type!")
	return string.gsub(secretAgendaTag, "^SA_", "")
end

function DIR.GetCoinStandings()
	local coinTotals = U.map(S.getPlayers(), function(player)
		return {
			color = player.color,
			total = OU.GetTotalValue(P.GetPlayerZone(player, "Coin"), "CoinToken"),
			placement = nil
		}
	end)
	table.sort(coinTotals, function(a, b) return a.total > b.total end)
	local placement, lastTotal = 1, coinTotals[1].total
	U.iForEach(coinTotals, function(cData)
		if cData.total < lastTotal then
			placement = placement + 1
		end
		cData.placement = placement
		lastTotal = cData.total
	end)

	local results = {}

	U.forEach(S.getPlayers(), function(player)
		results[player.color] = U.find(coinTotals, function(cData) return cData.color == player.color end)
	end)

	return results
end

function DIR.GetSecretAgendaScore(playerRef, tokenPositions, coinStandings)
	local player = S.getPlayer(playerRef)
	local secretAgendaData = C.SecretAgendaData[DIR.GetSecretAgenda(playerRef)]
	local scoreReport = {}
	if U.isIn("resPoints", secretAgendaData) then
		-- resFunc is a filter function that will return number of qualifying tokens
		local numTokens = #U.filter(U.getValues(tokenPositions), secretAgendaData.resFunc)
		scoreReport.resources = secretAgendaData.resPoints[numTokens + 1]
	else
		-- resFunc takes all data and returns final score
		scoreReport.resources = secretAgendaData.resFunc(nil, tokenPositions)
	end

	scoreReport.coinTotal = coinStandings.total
	scoreReport.coinPlacement = coinStandings.placement
	if coinStandings.placement <= 3 then
		scoreReport.coin = secretAgendaData.coinPoints[coinStandings.placement]
	else
		scoreReport.coin = 0
	end

	return scoreReport
end

function DIR.GetSecretAgendaScores()
	local results = {}
	local tokenPositions = DIR.GetTokenPositionsFromBoard()
	tokenPositions.Stability = nil
	local coinStandings = DIR.GetCoinStandings()
	U.forEach(S.getPlayers(), function(player)
		results[player.color] = DIR.GetSecretAgendaScore(player, tokenPositions, coinStandings[player.color])
	end)
	return results
end

function DIR.GetOpenAgendaScore(playerRef, tokenPositions)
	local posOpenAgendas = S.getPlayerVal(playerRef, "openAgendas", "positive") or {}
	local negOpenAgendas = S.getPlayerVal(playerRef, "openAgendas", "negative") or {}
	local scoreReport = { positive = {}, negative = {} }
	local resPositions = U.getValues(tokenPositions)
	table.sort(resPositions, function(a, b) return a.slot > b.slot end)
	-- log({tokenPositions = tokenPositions})
	local topResources, secondResources = {}, {}
	table.insert(topResources, U.shift(resPositions))
	while (#resPositions > 0 and resPositions[1].slot == topResources[1].slot) do
		table.insert(topResources, U.shift(resPositions))
	end
	if #resPositions > 0 then
		table.insert(secondResources, U.shift(resPositions))
		while (#resPositions > 0 and resPositions[1].slot == secondResources[1].slot) do
			table.insert(secondResources, U.shift(resPositions))
		end
	end

	resPositions = U.getValues(tokenPositions)

	table.sort(resPositions, function(a, b) return a.slot < b.slot end)
	local botResources, secBotResources = {}, {}
	table.insert(botResources, U.shift(resPositions))
	while (#resPositions > 0 and resPositions[1].slot == botResources[1].slot) do
		table.insert(botResources, U.shift(resPositions))
	end
	if #resPositions > 0 then
		table.insert(secBotResources, U.shift(resPositions))
		while (#resPositions > 0 and resPositions[1].slot == secBotResources[1].slot) do
			table.insert(secBotResources, U.shift(resPositions))
		end
	end

	-- log({topResources = topResources, secondResources = secondResources, botResources = botResources, secBotResources = secBotResources})

	scoreReport.openAgendaTotal = 0
	U.iForEach(posOpenAgendas, function(res)
		if U.find(topResources, function(rData) return rData.resource == res end) then
			scoreReport.openAgendaTotal = scoreReport.openAgendaTotal + 3
			scoreReport.positive[res] = 3
		elseif U.find(secondResources, function(rData) return rData.resource == res end) then
			scoreReport.openAgendaTotal = scoreReport.openAgendaTotal + 1
			scoreReport.positive[res] = 1
		end
	end)

	U.iForEach(negOpenAgendas, function(res)
		if U.find(botResources, function(rData) return rData.resource == res end) then
			scoreReport.openAgendaTotal = scoreReport.openAgendaTotal - 3
			scoreReport.negative[res] = -3
		elseif U.find(secBotResources, function(rData) return rData.resource == res end) then
			scoreReport.openAgendaTotal = scoreReport.openAgendaTotal - 1
			scoreReport.negative[res] = -1
		end
	end)

	return scoreReport
end

function DIR.GetOpenAgendaScores()
	local results = {}
	local resourcePositions = DIR.GetTokenPositionsFromBoard()
	resourcePositions.Stability = nil
	local tokenPositions = U.map(resourcePositions, function(slot, res)
		return { resource = res, slot = slot }
	end)
	U.forEach(S.getPlayers(), function(player)
		results[player.color] = DIR.GetOpenAgendaScore(player, tokenPositions)
	end)
	return results
end

function DIR.GetPowerBonus()
	local powerTotals = U.map(S.getPlayers(), function(player)
		return {
			color = player.color,
			total = OU.GetTotalValue(P.GetPlayerZone(player, "Power"), "PowerToken"),
			placement = nil
		}
	end)
	table.sort(powerTotals, function(a, b) return a.total > b.total end)
	local placement, lastTotal = 1, powerTotals[1].total
	U.iForEach(powerTotals, function(pData)
		if pData.total < lastTotal then
			placement = placement + 1
		end
		pData.placement = placement
		lastTotal = pData.total
	end)

	local results = {}

	U.forEach(S.getPlayers(), function(player)
		results[player.color] = U.find(powerTotals, function(pData) return pData.color == player.color end)
		if results[player.color].placement == 1 then
			results[player.color].points = 2
		elseif results[player.color].placement == 2 then
			results[player.color].points = 1
		else
			results[player.color].points = 0
		end
	end)

	return results
end

function DIR.GetFinalScores()
	local results = {
		SecretAgenda = DIR.GetSecretAgendaScores(),
		OpenAgenda = DIR.GetOpenAgendaScores(),
		PowerBonus = DIR.GetPowerBonus()
	}
	local byPlayer = {}
	U.forEach(S.getPlayers(), function(player)
		byPlayer[player.color] = {
			name = S.getPlayerHouseName(player),
			color = player.color,
			secretAgenda = DIR.GetSecretAgenda(player),
			resources = results.SecretAgenda[player.color].resources,
			openAgendas = results.OpenAgenda[player.color],
			openAgendasTotal = results.OpenAgenda[player.color].openAgendaTotal,
			coin = results.SecretAgenda[player.color].coin,
			coinTotal = results.SecretAgenda[player.color].coinTotal,
			coinPlacement = results.SecretAgenda[player.color].coinPlacement,
			power = results.PowerBonus[player.color].points,
			powerTotal = results.PowerBonus[player.color].total,
			powerPlacement = results.PowerBonus[player.color].placement
		}
		byPlayer[player.color].total = byPlayer[player.color].resources
			+ byPlayer[player.color].coin
			+ byPlayer[player.color].power
			+ U.sumVals(U.getValues(byPlayer[player.color].openAgendas.positive))
			+ U.sumVals(U.getValues(byPlayer[player.color].openAgendas.negative))
	end)
	return byPlayer
end

function DIR.GetFinalStandings()
	local scoring = C.FinalScoring[S.getStateVal("gameState", "endState")]
	local scores = U.getValues(DIR.GetFinalScores())
	table.sort(scores, function(a, b) return a.total > b.total end)
	local winnerScore = scores[1].total
	local winners = U.map(U.filter(scores, function(sData) return sData.total == winnerScore end),
		function(sData) return sData.color end)
	S.setStateVal(winners, "gameState", "winners")
	for i = 1, #scores do
		scores[i].row = i
	end
	local lastPlace = scores[#scores].total
	for i = #scores, 1, -1 do
		if scores[i].total == lastPlace then
			scores[i].placement = "LAST"
			scores[i].prestige = scoring[5].prestige
			scores[i].crave = scoring[5].crave
		else
			break
		end
	end

	if scores[1].placement ~= "LAST" then
		local placement = 1
		scores[1].placement = placement
		scores[1].prestige = scoring[placement].prestige
		scores[1].crave = scoring[placement].crave
		for i = 2, #scores do
			if scores[i].placement == "LAST" then
				break
			elseif scores[i].total == scores[i - 1].total then
				scores[i].placement = placement
			else
				placement = placement + 1
				scores[i].placement = placement
			end
			scores[i].prestige = scoring[placement].prestige
			scores[i].crave = scoring[placement].crave
		end
	end

	if S.getStateVal("gameState", "endState") ~= "Death" then
		for i = 1, #scores do
			if scores[i].secretAgenda == "Rebel" then
				scores[i].crave = scores[i].crave + 1
			end
		end
	end
	return scores
end

function DIR.InitScoringHUD(scores)
	if scores == nil then scores = DIR.GetFinalStandings() end

	local function signNum(num)
		if num == 0 then return "-" end
		if num > 0 then return "+" .. tostring(num) end
		return tostring(num)
	end
	-- initialize all scoring elements with data from scoresData

	local lastPlacement
	local imageRefs = {}
	U.iForEach(scores, function(sData, index)
		local prefix = "scoringHUD_" .. index .. "_"
		if lastPlacement ~= sData.placement then
			lastPlacement = sData.placement
			UI.setValue(prefix .. "Placement", ({
				[1] = "1st", [2] = "2nd", [3] = "3rd", [4] = "4th", LAST = "LAST"
			})[sData.placement])
		else
			UI.setValue(prefix .. "Placement", "")
		end
		UI.setAttribute("scoringHUD_" .. index, "offsetXY", "0 -" .. tostring(50 + (index - 1) * (100 + 5)))
		U.forEach({ "Name", "SecretAgenda", "OpenAgendas", "Coin", "Power", "Total" }, function(ref)
			UI.setAttribute(prefix .. ref, "color", U.GetHex(Color[sData.color]))
		end)
		UI.setValue(prefix .. "Name", sData.name)
		UI.setValue(prefix .. "SecretAgenda", signNum(sData.resources))
		UI.setValue(prefix .. "OpenAgendas", signNum(sData.openAgendasTotal))
		UI.setValue(prefix .. "Coin", signNum(sData.coin))
		UI.setValue(prefix .. "Power", signNum(sData.power))
		UI.setValue(prefix .. "Total", tostring(sData.total))

		local imageRef = ""
		if sData.prestige > 0 then
			imageRef = imageRef .. tostring(sData.prestige) .. "p"
		end
		if sData.crave > 0 then
			imageRef = imageRef .. tostring(sData.crave) .. "c"
		end
		table.insert(imageRefs, imageRef)
	end)

	local validPlacements = U.filter({ "LAST", 4, 3 },
		function(p) return U.find(scores, function(sData) return sData.placement == p end) end)

	local seqFuncs = {
		function()
			MSG.Hide("scoringSplashScreen")
			MSG.Show("scoringHUD")
			return 3
		end
	}

	U.iForEach(validPlacements, function(placement)
		table.insert(seqFuncs, function()
			U.forEach(
				U.filter(scores, function(sData) return sData.placement == placement end),
				function(sData) MSG.Show("scoringHUD_" .. sData.row) end
			)
			return 4
		end)
	end)

	table.insert(seqFuncs, function()
		U.forEach(
			U.filter(scores, function(sData) return sData.placement == 1 end),
			function(sData) MSG.Show("scoringHUD_" .. sData.row) end
		)
		return 1
	end)

	table.insert(seqFuncs, function()
		U.forEach(
			U.filter(scores, function(sData) return sData.placement == 2 end),
			function(sData) MSG.Show("scoringHUD_" .. sData.row) end
		)
		return 3
	end)

	table.insert(seqFuncs, function()
		return U.sequence(U.iMap({ 1, 2, 3, 4, 5 }, function(row)
			return function()
				local id = "scoringHUD_" .. row .. "_Reward_" .. imageRefs[row]
				MSG.Show(id)
				-- log("Showing '" .. id .. '". = 1_Reward_)
				-- log("Setting 'scoringHUD_" .. row .. "_Reward' to '" .. imageRefs[row] .. "'")
				-- Wait.time(function() UI.setAttribute("scoringHUD_" .. row .. "_Reward", "image", imageRefs[row]) end, 1)
			end
		end), 0.5)
	end)

	return U.RunSequence(seqFuncs)
end

function DIR.GetWinners() return U.iMap(
	U.filter(DIR.GetFinalStandings(), function(sData) return sData.placement == 1 end),
		function(sData) return S.getPlayer(sData.color) end) end

-- #endregion


function DIR.SpawnStoryCardForCapture(card, rowNum, colNum)
	local frontPos = Vector(C.CaptureCoords.cameraPos):add(Vector(0, 0, C.CaptureCoords.cameraZoneZShift):scale(1, 1,
		rowNum))
	frontPos:setAt("y", C.TableHeight)
	frontPos:add(Vector(
		C.CaptureCoords.Dilemma.startXDelta + (colNum - 1) * C.CaptureCoords.columnXShift,
		0,
		C.CaptureCoords.rowZShift
	))

	local backPos = Vector(frontPos)
	backPos:add(Vector(
		0,
		0,
		-1 * C.CaptureCoords.rowZShift
	))
	-- construct front and back transforms
	local transformFront = {
		position = frontPos,
		rotation = Vector(C.CaptureCoords.Story.frontRotation),
		scale = C.CaptureCoords.Story.scale
	}
	local transformBack = {
		position = backPos,
		rotation = Vector(C.CaptureCoords.Story.backRotation),
		scale = C.CaptureCoords.Story.scale
	}

	-- spawn front and back sides, tagging so they can be deleted easily
	OU.SpawnFromSourceObj(card, { "Capture" }, transformFront, nil, nil, true)
	OU.SpawnFromSourceObj(card, { "Capture" }, transformBack, nil, nil, true)
end

function DIR.SpawnDilemmaForCapture(dilemmaCard, index)
	local row = math.ceil(index / C.CaptureCoords.Dilemma.numColumns)
	local col = index % C.CaptureCoords.Dilemma.numColumns
	if col == 0 then col = C.CaptureCoords.Dilemma.numColumns end

	-- get position of FRONT side, rotated according to vote outcome; 4.43 -5.32 to -10.60
	local frontPos = Vector(C.CaptureCoords.cameraPos)
	frontPos:setAt("y", C.TableHeight)
	frontPos:add(Vector(
		C.CaptureCoords.Dilemma.startXDelta + (col - 1) * C.CaptureCoords.columnXShift,
		0,
		C.CaptureCoords.Dilemma.startZDelta +
		(row - 1) * (C.CaptureCoords.Dilemma.fullZShift + C.CaptureCoords.Dilemma.halfZShift)
	))

	-- get position of BACK side, from front side pos
	local backPos = Vector(frontPos)
	backPos:add(Vector(
		0,
		C.CaptureCoords.stackYShift,
		C.CaptureCoords.Dilemma.halfZShift
	))

	-- construct front and back transforms
	local transformFront = {
		position = frontPos,
		rotation = Vector(dilemmaCard.alt_view_angle).y > 90 and C.CaptureCoords.Dilemma.frontRotationNay or
		C.CaptureCoords.Dilemma.frontRotationAye,
		scale = C.CaptureCoords.Dilemma.scale
	}
	local transformBack = {
		position = backPos,
		rotation = Vector(C.CaptureCoords.Dilemma.backRotation),
		scale = C.CaptureCoords.Dilemma.scale
	}

	-- spawn front and back sides, tagging so they can be deleted easily
	OU.SpawnFromSourceObj(dilemmaCard, { "Capture" }, transformFront, nil, nil, true)
	OU.SpawnFromSourceObj(dilemmaCard, { "Capture" }, transformBack, nil, nil, true)
end

function DIR.RESET()
	-- S.setStateVal("NONE", "gameState", "gameMode")
	-- S.setStateVal("NONE", "gameState", "gamePhase")
	-- HOUSE_SELECTION, newPlayerColors = {}, {}

	U.RunSequence({
		-- stow played Dilemma cards, maintaining order, setting Description to record vote result.
		function()
			local playedDilemmaCards = getObjectsWithAllTags({ "Dilemma", "Played" })
			table.sort(playedDilemmaCards, function(a, b) return a.getPosition().z < b.getPosition().z end)
			local tempStagingPos = Vector(C.Spots.Main.CoverCard.Closed.position):add(Vector(-10, -3, 0))
			return {
				U.sequence(U.iMap(playedDilemmaCards, function(card, i)
					return function()
						tempStagingPos:add(Vector(0, 0.2, 0))
						if Vector(card.alt_view_angle).y > 90 then
							card.setDescription("Vote: NAY")
						else
							card.setDescription("Vote: AYE")
						end
						card.setPosition(tempStagingPos)
						card.setRotation(Vector(0, 180, 180))
						card.setTags({ "DilemmaOld" })
						card.setLock(false)
					end
				end), 0.15),
				table.unpack(playedDilemmaCards)
			}
		end,

		function() return U.AlertGM("All set!") end
	})
end

return DIR
