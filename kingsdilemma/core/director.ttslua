local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
local C = require("kingsdilemma.lib.constants")
local P = require("kingsdilemma.core.players")
local O = require("kingsdilemma.lib.objects")
local OU = require("kingsdilemma.objects.objUtilities")
local V = require("kingsdilemma.core.voting")
local L = require("kingsdilemma.core.lighting")
local MSG = require("kingsdilemma.core.messaging")
local HouseScreen = require("kingsdilemma.objs.p3screen")

local DIR = {}

function DIR.ADVANCE(waitFunc)
	local mode, phase = S.getNextPhase()
	local function startPhase()
		S.setStateVal(mode, "gameMode")
		S.setStateVal(phase, "gamePhase")
		DIR.InitializePhase()
	end

	if waitFunc then
		U.waitUntil(startPhase, waitFunc, true)
	else
		startPhase()
	end
end

function DIR.RESET()
	S.setStateVal("NONE", "gameMode")
	S.setStateVal("NONE", "gamePhase")
	DIR.InitializePhase()
end

local startType
INITFUNCS = {
	NONE = function() return {
		function()
			OU.SetGlobalSnapPoints()
			S.setStateVal(false, "isMidGame")
			S.setStateVal({}, "playerData")
			P.ClearSeats()
			MSG.Enqueue("Resetting Table", "ALL")
			return MSG.RunQueue("ALL")
		end
	} end,
	SESSIONINIT = {
		SeatPlayers = function() return {
			function()
				P.InitializeSeats()
				local players = S.getPlayers()
				MSG.Enqueue("Initializing Player Seats", "ALL")
				return {
					MSG.RunQueue("ALL", true),
					function() return #U.filter(players, function(pl) return pl.getHandCount() == 0 end) == 0 end
				}
			end,
			function()
				S.UpdateSeatedPlayers()
				DIR.ADVANCE()
			end
		} end,
		HouseSelection = function() return {
			function()
				MSG.Enqueue("Assigning Houses", "ALL")
				return MSG.RunQueue("ALL")
			end,
			DIR.InitHouseSelection
		} end
	},
	CAMPAIGNSETUP = function() return {
		function()
			MSG.Enqueue("Beginning Chronicle Setup", "ALL")
			return MSG.RunQueue("ALL")
		end,
		function()
			U.Assert("DIR.ADVANCE", S.getStateVal("gameCount") == 1)
			local host = S.getPlayer("Host")
			host.showOptionsDialog(
				"How do you want to start your Chronicle of A King's Dilemma?",
				{"Prologue", "Main"},
				"Prologue",
				function(response) startType = response end
			)
			return function()
				if startType ~= nil then
					log("StartType NOT NIL: CONTINUING! -- '" .. tostring(startType) .. "'")
					return true
				end
				log("StartType = NIL, waiting ...")
				return false
			end
		end,
		DIR.StartChronicle
	}
	end,
	GAMESETUP = {
		MainBoard = function() return {
			-- MAIN BOARD SETUP
				-- Randomly shuffle sides of Resource Tokens
				-- Stability token spawned at center
				-- 3x Power to middle of balance
				-- 8x Power and 10x Coins to each player
		} end,
		LeaderModerator = function() return {
			-- LEADER & MODERATOR
				-- Assign Leader token to player with HIGHEST prestige
				-- Assign Moderator token to player with LOWEST prestige
		} end,
		LegacySetup = function() return {
			-- LEGACY EFFECTS
				-- Apply 'em
				-- Open Agendas too!
		} end,
		SecretAgendas = function() return {
			-- SECRET AGENDAS
				-- Shuffle Secret Agendas, Randomly Remove One
				-- sort a table of playerData by prestige, with lowest first
					-- FOR EACH:
					-- get CurrentPlayer = prestigeTable.shift()
					-- "Deal" all SecretAgenda cards in DECKS or in HAND ZONES (but NOT in PLAY) to CurrentPlayer
					-- They choose by dropping from hand onto mat
						-- onObjectDrop() listener for CurrentPlayer dropping SecretAgenda
						-- loop back, dealing all cards to next player
						-- when all players have a SecretAgenda, END START SESSION!
		} end
	},
	PLAY = {
		Draw = function() return {


		} end,
		Balance = function() return {


		} end,
		Vote = function() return {


		} end,
		Result = function() return {
			-- set alt_view_angle to ...
				-- AYE vote = Vector(0,0,0)
				-- NAY vote = Vector(0,180,180)


		} end,
		Resolution = function() return {


		} end
	},
	END = {
		Score = function() return {


		} end,
		Realm = function() return {


		} end,
		Achievements = function() return {


		} end,
		Alignments = function() return {


		} end,
		Cleanup = function() return {


		} end
	}
}

function DIR.InitializePhase()
	Global.call("UpdatePhaseDisplay")
	local mode = S.getStateVal("gameMode")
	local phase = S.getStateVal("gamePhase")
	local seqFuncs = INITFUNCS[mode]
	if type(seqFuncs) == "table" then
		seqFuncs = seqFuncs[phase]
	end
	if type(seqFuncs) == "function" then
		seqFuncs = seqFuncs()
	end
	U.RunSequence(seqFuncs)
end

function DIR.JumpToStatePhase()
	local mode = S.getStateVal("gameMode")
	local phase = S.getStateVal("gamePhase")

	-- ... further logic to resync game environment to whatever point in the game we're at.
end

function DIR.InitSession()
	S.UpdateSeatedPlayers()
	Global.call("UpdatePhaseDisplay")
	Wait.time(function() L.LoadLights() end, 3)
	if not S.isInMode(C.Modes.NONE) then
		-- We're in the middle of a running game: jump to that phase.
		return DIR.JumpToStatePhase()
	end
end

-- #region House Selection ~
local HOUSE_SELECTION = {
	Current = {},
	UnselectedPlayers = {}
}

local function getHouseStatus(houseName, player)
	local playerOfHouseData = U.find(S.getStateVal("playerStorage"), function(pData) return pData.house == houseName end)
	if playerOfHouseData then
		local playerID = playerOfHouseData.id
		local seatedPlayerOfHouse = U.find(S.getStateVal("playerData"), function(pData) return pData.id == playerID end)
		if seatedPlayerOfHouse then
			if seatedPlayerOfHouse.color == player.color then
				return "Claimed", "BySelf", Color[player.color]
			else
				return "Claimed", "ByOther", Color[seatedPlayerOfHouse.color]
			end
		end
		return "Claimed", "ByAbsent"
	elseif HOUSE_SELECTION[houseName] then
		if HOUSE_SELECTION[houseName] == player.color then
			return "Selected", "BySelf", Color[player.color]
		else
			return "Selected", "ByOther", Color[HOUSE_SELECTION[houseName]]
		end
	else
		return "Available"
	end
end

function DIR.InitHouseSelection()
	U.forEach(S.getPlayers(), function(player)
		if not S.getPlayerVal(player, "house") then
			table.insert(HOUSE_SELECTION.UnselectedPlayers, player)
		end
	end)
	if #HOUSE_SELECTION.UnselectedPlayers == 0 then
		DIR.AssignSelectedHouses()
	else
		DIR.RefreshHouseHUD()
	end
end

local function getPlayerSelectedHouse(player)
	return U.find(HOUSE_SELECTION.Current, function(color) return color == player.color end)
end
local function getHex(color) return "#" .. color:toHex(true) end
function DIR.RefreshHouseHUD(houseName, player)
	if houseName == nil then return U.forEach(C.Houses, function(house) DIR.RefreshHouseHUD(house, player) end) end
	if player == nil then return U.forEach(S.getPlayers(), function(pl) DIR.RefreshHouseHUD(houseName, pl) end) end

	UI.show("houseSelection_" .. player.color)

	local flagColors = {
		Available = function() return Color.Grey end,
		ClaimedByOther = function(playerColor) return playerColor:lerp(Color.Black, 0.5):setAt("a", 0.1) end,
		ClaimedBySelf = function(playerColor) return playerColor:lerp(Color.White, 0.5):setAt("a", 0.25) end,
		ClaimedByAbsent = function() return Color.Grey:setAt("a", 0.25) end,
		SelectedByOther = function(playerColor) return playerColor:lerp(Color.Black, 0.5) end,
		SelectedBySelf = function(playerColor) return playerColor:lerp(Color.White, 0.5) end,
		Invisible = function() return Color.Black:setAt("a", 0) end
	}

	local houseStatus, statusDetail, statusColor = getHouseStatus(houseName, player)
	log({houseName = houseName, player = player.color, houseStatus = houseStatus, statusDetail = statusDetail, statusColor = statusColor})

	local flagID = "houseFlag_" .. houseName .. "_" .. player.color
	local hoverID = "houseHover_" .. houseName .. "_" .. player.color

	UI.setAttributes(hoverID, {
		raycastTarget = "true",
		onMouseDown = "HUD_Click",
		onMouseEnter = "HUD_HoverOn",
		onMouseExit = "HUD_HoverOff",
		scale = "1 1 1"
	})

	if houseStatus == "Claimed" then
		if statusDetail == "ByOther" then
			UI.setAttributes(flagID, {
				color = getHex(flagColors.ClaimedByOther(statusColor))
			})
			UI.setAttributes(hoverID, {
				color = getHex(flagColors.ClaimedByOther(statusColor):setAt("a", 1):lerp(Color.Black, 0.5)),
				scale = "0.5 0.5 0.5"
			})
		elseif statusDetail == "BySelf" then
			UI.setAttributes(flagID, {
				color = getHex(flagColors.ClaimedBySelf(statusColor))
			})
			UI.setAttributes(hoverID, {
				color = getHex(Color(player.color):lerp(Color.White, 0.5))
			})
		elseif statusDetail == "ByAbsent" then
			UI.setAttributes(flagID, {
				color = getHex(flagColors.ClaimedByAbsent())
			})
			UI.setAttributes(hoverID, {
				color = getHex(flagColors.ClaimedByAbsent():setAt("a", 1):lerp(Color.Black, 0.5)),
				scale = "0.5 0.5 0.5"
			})
		end
	elseif houseStatus == "Selected" then
		if statusDetail == "ByOther" then
			UI.setAttributes(flagID, {
				color = getHex(flagColors.SelectedByOther(statusColor))
			})
			UI.setAttributes(hoverID, {
				color = getHex(flagColors.SelectedByOther(statusColor):setAt("a", 1))
			})
		elseif statusDetail == "BySelf" then
			UI.setAttributes(flagID, {
				color = getHex(flagColors.SelectedBySelf(statusColor))
			})
			UI.setAttributes(hoverID, {
				color = getHex(flagColors.SelectedBySelf(statusColor):setAt("a", 1))
			})
		end
	elseif houseStatus == "Available" then
		UI.setAttributes(flagID, {
			color = getHex(flagColors.Available())
		})
		UI.setAttributes(hoverID, {
			color = getHex(flagColors.Invisible())
		})
	end
end

local function getUnselectedPlayers()
	return U.filter(S.getPlayers(), function(player)
		if S.getPlayerVal(player, "house") ~= nil then return false end
		if U.isIn(player.color, U.getValues(HOUSE_SELECTION.Current)) then return false end
		return true
	end)
end

function DIR.HouseHUDClick(player, houseName)
	local houseStatus = getHouseStatus(houseName, player)
	local curHouse = getPlayerSelectedHouse(player)
	if curHouse == houseName then
		HOUSE_SELECTION.Current[houseName] = false
	elseif houseStatus == "Available" then
		if curHouse ~= nil then
			HOUSE_SELECTION.Current[curHouse] = false
		end
		HOUSE_SELECTION.Current[houseName] = player.color
	end
	if curHouse ~= nil then
		DIR.RefreshHouseHUD(curHouse)
	end
	DIR.RefreshHouseHUD()
	Wait.time(function()
		if #getUnselectedPlayers() == 0 then
			DIR.AssignSelectedHouses()
		end
	end, 3)
end

function DIR.HouseHUDHoverOn(player, houseName)
	local houseStatus = getHouseStatus(houseName, player)
	local curHouse = getPlayerSelectedHouse(player)
	if curHouse == houseName then return end
	if curHouse ~= nil then
		UI.hide("houseInfo_" .. curHouse .. "_" .. player.color)
	end
	if houseStatus == "Available" then
		UI.setAttributes("houseFlag_" .. houseName .. "_" .. player.color, {
			color = getHex(Color.White)
		})
		UI.setAttributes("houseHover_" .. houseName .. "_" .. player.color, {
			color = getHex(Color.White)
		})
	end
	UI.show("houseInfo_" .. houseName .. "_" .. player.color)
end

function DIR.HouseHUDHoverOff(player, houseName)
	local houseStatus, statusDetail, statusColor = getHouseStatus(houseName, player)
	local curHouse = getPlayerSelectedHouse(player)
	if curHouse == houseName then return end
	if curHouse ~= nil then
		UI.show("houseInfo_" .. curHouse .. "_" .. player.color)
	end
	if houseStatus == "Available" then
		UI.setAttributes("houseFlag_" .. houseName .. "_" .. player.color, {
			color = getHex(Color.Grey)
		})
		UI.setAttributes("houseHover_" .. houseName .. "_" .. player.color, {
			color = getHex(Color.Black:setAt("a", 0))
		})
	end
	UI.hide("houseInfo_" .. houseName .. "_" .. player.color)
end

function DIR.AssignSelectedHouses()
	U.forEach(C.SeatColors, function(col) UI.hide("houseSelection_" .. col) end)

	local newPlayerColors = {}
	if HOUSE_SELECTION.Current ~= nil then
		U.forEach(HOUSE_SELECTION.Current, function(color, houseName)
			if not color or not houseName then return end
			local player = S.getPlayer(color)
			table.insert(newPlayerColors, color)
			S.setPlayerVal(houseName, player, "house")
			S.setPlayerVal(nil, player, "houseName")
		end)
	end
	U.forEach(S.getPlayers(), function(player)
		local house = S.getPlayerVal(player, "house")
		HouseScreen.Spawn(player, house, U.isIn(player.color, newPlayerColors))
	end)
end
-- #endregion

local function getContainedGUID(container, targetName)
	if not U.isGameObject(container) or type(targetName) ~= "string" then return end
	local targetObjData = U.find(container.getObjects(), function(objData)
		return string.lower(objData.name) == string.lower(targetName)
	end)
	if targetObjData == nil then
		broadcastToAll("Target '" .. tostring(targetName) .. "' not found. Check letters and cases.", {1,0,0})
		return nil
	end
	return targetObjData.guid
end

local function getUpdatedChronicleCardState(cScriptState)
	local scriptState = JSON.decode(cScriptState)
	local playerKeys = {"1", "8", "15", "22", "29"}
	U.forEach(S.getPlayers(), function(player, i)
		local houseName = S.getPlayerVal(player, "houseName") or ""
		scriptState[playerKeys[i]] = houseName
	end)
	return JSON.encode(scriptState)
end

function DIR.PlaceChronicleCard(kingName)
	local sourceObj = O.SpawnSources.chronicleCard()
	local spawnData = sourceObj.getData()
	spawnData.Nickname = kingName
	spawnData.Description = os.date("%b ") .. os.date("*t").day .. " '" .. os.date("*t").year - 2000
	spawnData.Transform = OU.unfoldTransform(C.Spots.Main.ChronicleCard)
	spawnData.Tags = {"ChronicleCard", "ChronicleCardActive"}
	spawnData.LuaScriptState = getUpdatedChronicleCardState(spawnData.LuaScriptState)
	return spawnObjectData({data = spawnData})
end

function DIR.UpdateChronicleCardNames()
	local cCard = getObjectsWithTag("ChronicleCardActive")[1]
	if cCard == nil then return end
	local cData = cCard.getData()
	cCard.setCustomObject({LuaScriptState = getUpdatedChronicleCardState(cData.LuaScriptState)})
	cCard.reload()
end

function DIR.StartChronicle()
	local startingEnvelope = ({Prologue = "D1", Main = "0"})[startType]
	local envContainer = O.SecretContainers.Envelopes()
	local coverCard = O.Pieces.CoverCard()
	coverCard.setLock(true)
	local coverCardRaisedPos = coverCard.getPosition():add(Vector(0, 5, 0))
	local newCardDestPos = coverCard.getPosition():add(Vector(0, 0.2, 0))
	local envGUID = getContainedGUID(envContainer, startingEnvelope)
	if envGUID == nil then return end

	local envContents, storyCard, dilemmaDeck, remainder

	local function grabNextCard()
		newCardDestPos = newCardDestPos:add(Vector(0, 0.1, 0))
		if remainder ~= nil then
			remainder.setTags({"Dilemma"})
			remainder.setLock(false)
			remainder.setPositionSmooth(newCardDestPos)
			remainder.setRotationSmooth(coverCard.getRotation())
		else
			envContents.takeObject({
				position = newCardDestPos,
				rotation = coverCard.getRotation(),
				callback_function = function(obj)
					obj.setTags({"Dilemma"})
					obj.setLock(false)
				end
			})
			if envContents.remainder ~= nil then
				remainder = envContents.remainder
				return 1
			end
		end
		return 0.3
	end

	U.RunSequence({
		function() return {L.SetLightMode("lightLectern", "spotlightChronicleCard")} end,
		function() return DIR.PlaceChronicleCard("Harald V") end,
		function() return {L.SetLightMode("lightLectern", "spotlightEnvelope", nil, 0.25)} end,
		function()
			U.setPositionSlow(envContainer, C.Spots.Staging.Lectern.Envelopes.position)
			U.setRotationSlow(envContainer, C.Spots.Staging.Lectern.Envelopes.rotation)
			return {envContainer, L.SetLightMode("lightLectern", "spotlightPlinth", nil, 0.1)}
		end,
		function()
			envContainer.takeObject({
				position = C.Spots.Staging.Lectern.Display.position,
				rotation = C.Spots.Staging.Lectern.Display.rotation,
				guid = envGUID,
				callback_function = function(obj)
					envContents = obj
					envContents.setLock(true)
				end
				})
			return function() return envContents ~= nil end
		end,
		function()
			U.setPositionSlow(coverCard, coverCardRaisedPos)
			U.setPositionSlow(envContainer, C.Spots.Storage.Envelopes.position)
			U.setRotationSlow(envContainer, C.Spots.Storage.Envelopes.rotation)
			return {coverCard, envContainer, L.SetLightMode("lightLectern", "spotlightTransit")}
		end,
		function()
			envContents.takeObject({
				position = C.Spots.Staging.Lectern.TopCard.position,
				rotation = C.Spots.Staging.Lectern.TopCard.rotation,
				callback_function = function(obj)
					storyCard = obj
					storyCard.setTags({"StoryCard"})
					storyCard.setLock(true)
				end
			})
			return function() return storyCard ~= nil end
		end,
		grabNextCard,
		grabNextCard,
		grabNextCard,
		function()
			return
				function()
					local dilemmaObjs = getObjectsWithTag("Dilemma")
					if #dilemmaObjs ~= 1 then return false end
					if dilemmaObjs[1].type ~= "Deck" then return false end
					dilemmaDeck = dilemmaObjs[1]
					return dilemmaDeck
				end
		end,
		function()
			dilemmaDeck.shuffle()
			return 1
		end,
		function()
			coverCard.setLock(false)
			-- storyCard.setLock(false)
			storyCard.setPositionSmooth(Vector({0.00, 7, 16.52}))
			storyCard.setRotationSmooth(Vector({0.00, 180.00, 0.00}))
			return {
				coverCard,
				storyCard,
				L.SetLightMode("lightLectern", "firstStoryCard")
			}
		end,
		function()
			storyCard.setLock(false)
			return {
				storyCard,
				3.5
			}
		end,
		function()
			return function() return not Vector.equals(storyCard.getPosition(), Vector({0.00, 1.94, 16.52}), 1) end
		end,
		function()
			return L.SetLightMode("lightLectern", "ambient")
		end
	})
end




return DIR