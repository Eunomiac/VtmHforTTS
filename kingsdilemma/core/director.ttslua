local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
local C = require("kingsdilemma.lib.constants")
local P = require("kingsdilemma.core.players")
local O = require("kingsdilemma.lib.objects")
local OU = require("kingsdilemma.objects.objUtilities")
local V = require("kingsdilemma.core.voting")
local L = require("kingsdilemma.core.lighting")
local MSG = require("kingsdilemma.core.messaging")
local HouseScreen = require("kingsdilemma.objs.p3screen")

local DIR = {}

local function getBoardTokens()
	local tokens = {
		Stability = getObjectsWithTag("StabilityMarker")[1],
		resource = {}
	}
	local rTokens = getObjectsWithTag("ResourceMarker")
	table.sort(rTokens, function(a, b) return a.getPosition().x < b.getPosition().x end)
	tokens.resource.Influence = rTokens[1]
	tokens.resource.Wealth = rTokens[2]
	tokens.resource.Morale = rTokens[3]
	tokens.resource.Welfare = rTokens[4]
	tokens.resource.Knowledge = rTokens[5]
	return tokens
end

local function getTokenPositionsFromBoard()
	local board = O.UninteractableObjs.Board()
	local boardTokens = getBoardTokens()
	return {
		Stability = OU.FindNearestSnapPoint(boardTokens.Stability, board),
		Influence = OU.FindNearestSnapPoint(boardTokens.resource.Influence, board),
		Wealth = OU.FindNearestSnapPoint(boardTokens.resource.Wealth, board),
		Morale = OU.FindNearestSnapPoint(boardTokens.resource.Morale, board),
		Welfare = OU.FindNearestSnapPoint(boardTokens.resource.Welfare, board),
		Knowledge = OU.FindNearestSnapPoint(boardTokens.resource.Knowledge, board)
	}
end

local function getTokenPositionsFromState()
	return {
		Influence = S.getStateVal("roundState", "boardTokens", "positions", "Influence"),
		Wealth = S.getStateVal("roundState", "boardTokens", "positions", "Wealth"),
		Morale = S.getStateVal("roundState", "boardTokens", "positions", "Morale"),
		Welfare = S.getStateVal("roundState", "boardTokens", "positions", "Welfare"),
		Knowledge = S.getStateVal("roundState", "boardTokens", "positions", "Knowledge"),
	}
end


local function getTokenPositionDeltas(startPositions, endPositions)
	local boardPositions = getTokenPositionsFromBoard()
	local statePositions = getTokenPositionsFromState()
	return {
		Influence = endPositions.Influence - startPositions.Influence,
		Wealth = endPositions.Wealth - startPositions.Wealth,
		Morale = endPositions.Morale - startPositions.Morale,
		Welfare = endPositions.Welfare - startPositions.Welfare,
		Knowledge = endPositions.Knowledge - startPositions.Knowledge
	}
end

local function getTokenMomentum(resource)
	local startTurnData = S.getStateVal("roundState", "boardTokens")
	if startTurnData == nil or startTurnData.momentum == nil or startTurnData.momentum[resource] == nil then
		local token = getBoardTokens().resource[resource]
		U.Assert("getTokenMomentum", token, "Object")
		return U.isFlipped(token) and -1 or 1
	else
		return startTurnData.momentum[resource]
	end
end

local function getTokenMomentums()
	return {
		Influence = getTokenMomentum("Influence"),
		Wealth = getTokenMomentum("Wealth"),
		Morale = getTokenMomentum("Morale"),
		Welfare = getTokenMomentum("Welfare"),
		Knowledge = getTokenMomentum("Knowledge"),
	}
end

local function getUnboundTokenPositionsAfterApplyingMomentum()
	local tokenMomentums = getTokenMomentums()
	local curTokenPositions = getTokenPositionsFromBoard()
	local positionDeltas = getTokenPositionDeltas(getTokenPositionsFromState(), curTokenPositions)
	local newTokenPositions = U.clone(curTokenPositions)

	U.iForEach(C.Resources, function(resource)
		if tokenMomentums[resource] * positionDeltas[resource] > 0 then
			-- moving in same direction: apply momentum
			newTokenPositions[resource] = newTokenPositions[resource] + tokenMomentums[resource]
		end
	end)

	return newTokenPositions
end

local function getStabilityTokenBumpsFromMomentum()
	return getTokenPositionDeltas(
		getTokenPositionsFromBoard(),
		getUnboundTokenPositionsAfterApplyingMomentum()
	)
end

local function getResourceTokenBumpsFromMomentum()
	return getTokenPositionDeltas(
		getTokenPositionsFromBoard(),
		getUnboundTokenPositionsAfterApplyingMomentum()
	)
end

local function bumpToken(token, unitForceVector, count, lightName)
	local forceVector = Vector(unitForceVector):scale(count > 0 and Vector(1, 1, 1) or Vector(1, 1, -1))
	local absCount = math.abs(count)
	if absCount <= 3 then
		if lightName then
			Wait.time(function() DIR.UpdateTokenLight(lightName) end, 0.6)
		end
		return token.addForce(Vector(forceVector):scale(Vector(1, 1, math.abs(count))), 3)
	else
		local seqFuncs = {}
		while absCount >= 3 do
			absCount = absCount - 3
			table.insert(seqFuncs, function() bumpToken(token, forceVector, 3, lightName) end)
		end
		while absCount >= 2 do
			absCount = absCount - 2
			table.insert(seqFuncs, function() bumpToken(token, forceVector, 2, lightName) end)
		end
		while absCount >= 1 do
			absCount = absCount - 1
			table.insert(seqFuncs, function() bumpToken(token, forceVector, 1, lightName) end)
		end
		return U.sequence(seqFuncs, 0.5)
	end
end

local function bumpStabilityToken(count)
	local forceVector = Vector(0, 15, 3.5)
	return bumpToken(getBoardTokens().Stability, forceVector, count, "Stability")
end

local function bumpResourceToken(tokenName, count)
	local forceVector = Vector(0, 15, 3.5)
	return bumpToken(getBoardTokens().resource[tokenName], forceVector, count, tokenName)
end

function DIR.BumpToken(tokenName, count)
	local tokenPos = getTokenPositionsFromBoard()
	local min, max = 1, tokenName == "Stability" and 19 or 17
	if tokenName == "Stability" and (tokenPos.Stability == 19 or tokenPos.Stability == 1) then
		return 0
	end
	count = math.max(math.min(count, max - tokenPos[tokenName]), min - tokenPos[tokenName])
	if tokenName == "Stability" then
		return bumpStabilityToken(count)
	elseif U.isIn(tokenName, C.Resources) then
		return bumpResourceToken(tokenName, count)
	end
end

function DIR.InitCountZones()
	U.forEach(S.getPlayers(), function(player)
		-- Player Private Power
		local powerZone = getObjectsWithAllTags({"zonePrivatePower", player.color})[1]
		if powerZone then
			powerZone.call("SetCountTag", "PowerToken")
			powerZone.call("SetColor", Color.Yellow)
			powerZone.call("SetIcon", "powerIcon")
			powerZone.call("SetIconColor", C.RootColors.Amber)
			powerZone.call("Activate")
		end

		-- Player Private Coin
		local coinZone = getObjectsWithAllTags({"zonePrivateCoin", player.color})[1]
		if coinZone then
			coinZone.call("SetCountTag", "CoinToken")
			coinZone.call("SetColor", Color.Yellow)
			coinZone.call("SetIcon", "coinIcon")
			coinZone.call("SetIconColor", C.RootColors.Amber)
			coinZone.call("Activate")
		end

		V.InitCountZones(player)
	end)

	-- Balance Plinth
	local balanceZone = getObjectsWithTag("zoneBalance")[1]
	if balanceZone then
		balanceZone.call("SetCountTag", "PowerToken")
		balanceZone.call("SetColor", Color.Yellow)
		balanceZone.call("SetIcon", "powerIcon")
		balanceZone.call("SetIconColor", C.RootColors.Amber)
		balanceZone.call("Activate")
	end
end

-- #region Initialization Functions~
INITFUNCS = {
	NONE = function()
		return {
			function()
				S.setStateVal({}, "playerData")
				P.ClearSeats()

				S.UpdateSeatedPlayers()
				return MSG.Splash("Resetting Table")
			end
		}
	end,
	SESSIONINIT = {
		SeatPlayers = function()
			return {
				function()
					P.InitializeSeats()
					local players = S.getPlayers()
					return {
						MSG.Splash("Seating Players"),
						function() return #U.filter(players, function(pl) return pl.getHandCount() == 0 end) == 0 end
					}
				end,
				DIR.ADVANCE
			}
		end,
		HouseSelection = function()
			return {
				DIR.InitHouseSelection
			}
		end
	},
	CHRONSETUP = function()
		U.Assert("INITFUNCS.CHRONSETUP", S.getStateVal("gameState", "gameCount") == 1)
		local queryResponse = {Prologue = "D1", ["Main Story"] = "0"}
		return {
			function()
				return MSG.SplashQuery(
					"How do you want to start your Chronicle of A King's Dilemma?",
					"Host",
					queryResponse,
					S.getPlayer("Host")
				)
			end,
			function() return P.SetCamera("Lectern") end,
			function()
				L.LoadLights({ "lightLectern" }, "default")
				return MSG.Splash("Chronicle Setup")
			end,
			function()
				S.setStateVal(({ ["D1"] = "Harald IV", ["0"] = "Harald V" })[queryResponse.response], "gameState", "kingName")
				return DIR.OpenEnvelope(queryResponse.response)
			end
		}
	end,
	GAMESETUP = {
		MainBoard = function()
			return {
				function()
					P.SetCamera("MainBoard")
					DIR.AddToDilemmaDeck()
					return MSG.Splash("Board Setup")
				end,
				DIR.SpawnBoardTokens,
				function()
					V.ElevateBalance()
					return L.SetLightMode("lightBalance", "bright", nil, 0.5)
				end,
				function()
					DIR.InitCountZones()
					V.SpawnBalanceTokens(3)
					L.SetLightMode("lightBalance", "on", nil, 3)
					return 1.5
				end,
				function() return P.SetCamera("BehindScreen") end,
				function()
					MSG.Splash("Distributing Power & Coin")
					return {
						DIR.SpawnStartingPlayerPower(),
						DIR.SpawnStartingPlayerCoins()
					}
				end,
				DIR.ADVANCE
			}
		end,
		LeaderModerator = function()
			local leader, moderator
			return {
				function()
					MSG.Splash(P.GetLeaderName() .. " Is Most Prestigious")
					L.SetLightMode("lightLeader", "on", nil, 2)
					return 1
				end,
				function() return P.AssignLeader(leader) end,
				function()
					MSG.Splash(P.GetModeratorName() .. " Is Least Prestigious")
					L.SetLightMode("lightModerator", "on", nil, 2)
					return 1
				end,
				function() return P.AssignModerator(moderator) end,
				DIR.ADVANCE
			}
		end,
		LegacySetup = function()
			return {
				function()
					P.SetCamera("MainBoard")
					return MSG.Splash("Applying Legacy Effects")
				end,
				function()
					return MSG.Splash("Assigning Open Agendas")
				end,
				DIR.ADVANCE
			}
		end,
		SecretAgendas = function()
			local agendaDeck, agendaCard
			return {
				function()
					agendaDeck = getObjectsWithTag("SecretAgenda")[1]
					U.Val("SecretAgendas", agendaDeck, U.isGameObject(agendaDeck) and agendaDeck.type == "Deck")
					P.SetCamera("Lectern")
					return MSG.Splash("Assigning Secret Agendas")
				end,
				function()
					agendaDeck.setLock(true)
					L.SetLightMode("lightLectern", "spotlightDilemmaDeck", nil, 1)
					return {
						U.setPositionSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.High.position), 1),
						U.setRotationSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.High.rotation), 1)
					}
				end,
				function()
					U.setPositionSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.Low.position), 0.5)
					U.setRotationSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.Low.rotation), 0.5)
					return 0.25
				end,
				function()
					agendaDeck.shuffle()
					return 0.5
				end,
				function()
					local isSpawned = false
					agendaCard = agendaDeck.takeObject({
						position = Vector({ -0.01, 6.95, 24.41 }),
						rotation = Vector({ 0, 0, 180 }),
						callback_function = function(obj)
							obj.setLock(true)
							isSpawned = true
						end
					})
					return function() return isSpawned == true end
				end,
				function()
					return {
						U.setRotationSlow(agendaCard, Vector(C.Spots.Staging.SecretAgenda.Burnt.rotation), 2),
						U.setPositionSlow(agendaCard, Vector(C.Spots.Staging.SecretAgenda.Burnt.position), 2, "speedUp")
					}
				end,
				function()
					P.SetCamera("BehindScreen")
					return P.DealAll(agendaDeck, P.GetLeastPrestigious())
				end,
				function()
					L.SetLightMode("lightLectern", "off")
					L.SetLightMode("lightPlayerSpotlight", "player" .. S.getPlayerNum(P.GetLeastPrestigious()))
					L.SetLightMode("lightFront", "dim")
					return MSG.Splash("Choose Your Secret Agenda", P.GetLeastPrestigious())
				end
			}
		end,
		PrepareFirstRound = function()
			return {
				function()
					S.setStateVal(0, "roundState", "roundNum")
					S.setStateVal(false, "roundState", "passModClaimed")
					S.setStateVal(getTokenMomentums(), "roundState", "boardTokens", "momentum")
					return DIR.ADVANCE()
				end
			}
		end
	},
	PLAY = {
		StartRound = function()
			return {
				function()
					S.setStateVal(S.getStateVal("roundState", "roundNum") + 1, "roundState", "roundNum")
					S.setStateVal(getTokenPositionsFromBoard(), "roundState", "boardTokens", "positions")
					S.setStateVal(P.GetLeader().color, "roundState", "currentTurn")
					S.setStateVal(0, "roundState", "ayeTotal")
					S.setStateVal(0, "roundState", "nayTotal")
					U.forEach(S.getPlayers(), function(player)
						S.setStateVal(false, "turnState", player.color, "vote")
						S.setStateVal(0, "turnState", player.color, "powerCommitted")
					end)
					return DIR.ADVANCE()
				end
			}
		end,
		DrawDilemma = function()
			local coverCard = O.Pieces.CoverCard()
			local dilemmaSource = U.findBelowObject(coverCard, function(obj) return obj.type == "Card" or obj.type == "Deck" end)
			U.Val("DIR.DrawDilemmaCard", dilemmaSource, #dilemmaSource == 1)
			dilemmaSource = dilemmaSource[1]
			local dilemmaCard
			return {
				function()
					return {
						P.SetCamera("DilemmaDraw"),
						MSG.Splash("The Dilemma")
					}
				end,
				function()
					L.SetLightMode("lightLectern", "spotlightDilemmaDeck")
					if dilemmaSource.type == "Deck" then
						dilemmaSource.takeObject({
							position = C.Spots.Staging.DilemmaDraw.position,
							rotation = C.Spots.Staging.DilemmaDraw.rotation,
							top = false,
							callback_function = function(obj)
								obj.setLock(true)
								dilemmaCard = obj
							end
						})
						return function() return dilemmaCard ~= nil end
					elseif dilemmaSource.type == "Card" then
						dilemmaCard = dilemmaSource
						dilemmaCard.setLock(true)
						return {
							U.setPositionSlow(dilemmaCard, C.Spots.Staging.DilemmaDraw.position),
							U.setRotationSlow(dilemmaCard, C.Spots.Staging.DilemmaDraw.rotation)
						}
					end
				end,
				function()
					L.SetLightMode("lightLectern", "off", nil, 0.5)
					L.SetLightMode("lightDilemmaMain", "on", nil, 2)
					dilemmaCard.addTag("OnDisplay")
					return {
						U.setPositionSlow(dilemmaCard, C.Spots.Main.Dilemma.faceDown.position, 2, "speedUp"),
						U.setRotationSlow(dilemmaCard, C.Spots.Main.Dilemma.faceDown.rotation, 2, "speedUp"),
						U.setScaleSlow(dilemmaCard, C.Spots.Main.Dilemma.faceDown.scale, 2, "speedUp")
					}
				end,
				function()
					return {
						L.SetLightMode("lightDilemmaAye", "on", nil, 1),
						L.SetLightMode("lightDilemmaNay", "on", nil, 1)
					}
				end,
				function()
					UI.setAttribute("consequencesQuery", "visibility", P.GetLeader().color)
					UI.show("consequencesQuery")
					UI.show("consequencesSidebar")
					return 0
				end
			}
		end,
		Discussion = function()
			return {
				function()
					UI.hide("consequencesQuery")
					P.SetCamera("BehindScreen")
					return MSG.Splash("The Debate")
				end
			}
		end,
		Vote = function()
			local queryResponse = {Yes = "true", No = "false"}
			return {
				function()
					return MSG.SplashQuery(
						"Does the card on display require a vote?",
						P.GetLeaderName(),
						queryResponse,
						P.GetLeader()
					)
				end,
				function()
					if queryResponse.response == "true" then
						return U.RunSequence({
							function()
								MSG.Splash("The Vote")
								V.InitCountZones()
								return V.SetVotingLights()
							end,
							function()
								DIR.DisplayPassHUD(P.GetLeader())
								return V.StartTurn(P.GetLeader())
							end
						})
					else
						return U.RunSequence({
							function() return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.EndRound) end,
							function() return DIR.InitializePhase() end
						})
					end
				end
			}
		end,
		VoteResolution = function()
			return {
				function()
					UI.hide("consequencesSidebar")
					return {
						L.SetLightMode({"lightBehind"}, "ambient"),
						L.SetLightMode({"lightFront"}, "dim"),
						L.SetLightMode({"lightPlayerSpotlight"}, "off")
					}
				end,
				function()
					local nayTotal = S.getStateVal("roundState", "nayTotal")
					local ayeTotal = S.getStateVal("roundState", "ayeTotal")
					if ayeTotal == nayTotal then
						local query = {Aye = "Aye", Nay = "Nay"}
						return U.RunSequence({
							function()
								return L.SetLightMode({"lightPlayerSpotlight"}, "player" .. S.getPlayerNum(P.GetModerator()), nil, 1)
							end,
							function()
								if ayeTotal == 0 then
									MSG.Splash("The decision is the Moderator's to make.")
									return MSG.SplashQuery(
										"Does the proposed resolution succeed?",
										P.GetModeratorName(),
										query,
										P.GetModerator()
									)
								else
									MSG.Splash("The Moderator will break the tie.")
									return MSG.SplashQuery(
										"The tie-breaking vote is yours to cast.",
										P.GetModeratorName(),
										query,
										P.GetModerator()
									)
								end
							end,
							function()
								L.SetLightMode({"lightPlayerSpotlight"}, "off")
								S.setStateVal(query.response, "roundState", "voteResult")
								if ayeTotal == 0 then
									return {
										MSG.Splash(P.GetModeratorName() .. " claims leadership over the vote."),
										P.AssignLeader(P.GetModerator())
									}
								end
								return 0
							end
						})
					elseif ayeTotal > nayTotal then
						S.setStateVal("Aye", "roundState", "voteResult")
					else
						S.setStateVal("Nay", "roundState", "voteResult")
					end
					return 0
				end,
				function()
					if S.getStateVal("roundState", "voteResult") == "Aye" then
						return MSG.Splash("The resolution passes!", nil, nil, {color = U.GetHex(Color.Blue)})
					else
						return MSG.Splash("The resolution is rejected!", nil, nil, {color = U.GetHex(Color.Red)})
					end
				end,
				function()
					if S.getPlayerVoteStatus(P.GetLeader()) ~= S.getStateVal("roundState", "voteResult") then
						local winningPlayers = U.filter(S.getPlayers(), function(player) return S.getPlayerVoteStatus(player) == S.getStateVal("roundState", "voteResult") end)
						table.sort(winningPlayers, function(playerA, playerB) return S.getPlayerPowerCommitted(playerA) > S.getPlayerPowerCommitted(playerB) end)
						if #winningPlayers > 1 and S.getPlayerPowerCommitted(winningPlayers[1]) == S.getPlayerPowerCommitted(winningPlayers[2]) then
							local tiedPlayers = U.filter(winningPlayers, function(player) return S.getPlayerPowerCommitted(player) == S.getPlayerPowerCommitted(winningPlayers[1]) end)
							local queryResponse = {}
							U.forEach(tiedPlayers, function(player) queryResponse[P.GetPlayerName(player)] = player end)
							return U.RunSequence({
								function()
									return MSG.SplashQuery(
										"Of the supporting players who committed the most power, who shall become Leader?",
										P.GetModeratorName(),
										queryResponse,
										P.GetModerator()
									)
								end,
								function()
									MSG.Splash(P.GetModeratorName() .. " assigns Leadership to " .. P.GetPlayerName(queryResponse.response))
									return 0.5
								end,
								function()
									return P.AssignLeader(queryResponse.response)
								end
							})
						else
							return U.RunSequence({
								function()
									MSG.Splash(P.GetPlayerName(winningPlayers[1]) .. " supported the vote with the most Power and claims Leadership.")
									return 0.5
								end,
								function()
									return P.AssignLeader(winningPlayers[1])
								end
							})
						end
					else
						return 0
					end
				end,
				function()
					local passPlayers = U.filter(S.getPlayers(), function(player) return U.isIn(S.getPlayerVoteStatus(player), {"Pass", "PassMod"}) end)
					if #passPlayers > 0 then
						return U.RunSequence({
							function()
								MSG.Splash("Granting Coin for Abstaining")
								return U.map(passPlayers, function(player) return L.SetLightMode("lightFront", "ambient", player, 1) end)
							end,
							unpack(U.iMap(passPlayers, function(player) return
								U.RunSequence({
									function()
										L.SetLightMode("lightFront", "bright", player, 0.5)
										return P.SpawnCoins(player, 1)
									end,
									function() return L.SetLightMode("lightFront", "dim", player, 0.5) end
								})
							end))
						})
					end
					return 0
				end,
				function()
					local passPowerPlayers = U.filter(S.getPlayers(), function(player) return S.getPlayerVoteStatus(player) == "Pass" end)
					local balanceZone = getObjectsWithTag("zoneBalance")[1]
					local balancePower = OU.GetTotalValue(balanceZone, "PowerToken")
					if #passPowerPlayers > 0 and balancePower >= #passPowerPlayers then
						local powerPerPlayer = math.floor(balancePower / #passPowerPlayers)
						if powerPerPlayer > 0 then
							return U.RunSequence({
								function()
									MSG.Splash("Distributing Balance Power")
									return U.map(passPowerPlayers, function(player) return L.SetLightMode("lightFront", "ambient", player, 1) end)
								end,
								unpack(U.iMap(passPowerPlayers, function(player) return
									U.RunSequence({
										function()
											L.SetLightMode("lightFront", "bright", player, 0.5)
											return OU.TransferValue(
												balanceZone,
												P.GetPlayerZone(player, "Power"),
												powerPerPlayer,
												"PowerToken")
										end,
										function() return L.SetLightMode("lightFront", "dim", player, 0.5) end
									})
								end))
							})
						end
					end
					return 0
				end,
				function()
					local losingPlayers = U.filter(S.getPlayers(), function(player) return U.isIn(S.getPlayerVoteStatus(player), {"Aye", "Nay"}) and S.getPlayerVoteStatus(player) ~= S.getStateVal("roundState", "voteResult") end)
					if #losingPlayers > 0 then
						return U.RunSequence({
							function()
								MSG.Splash("Returning Power to Losing Players")
								return U.map(losingPlayers, function(player) return L.SetLightMode("lightFront", "ambient", player, 1) end)
							end,
							unpack(U.iMap(losingPlayers, function(player) return
								U.RunSequence({
									function()
										L.SetLightMode("lightFront", "bright", player, 0.5)
										Wait.time(function() V.LowerRiser(player) end, 2)
										return OU.TransferValue(
											P.GetPlayerZone(player, "Public"),
											P.GetPlayerZone(player, "Power"),
											OU.GetTotalValue(P.GetPlayerZone(player, "Public"), "PowerToken"),
											"PowerToken")
									end,
									function() return L.SetLightMode("lightFront", "dim", player, 0.5) end
								})
							end))
						})
					end
					return 0
				end,
				function()
					local winningPlayers = U.filter(S.getPlayers(), function(player) return S.getPlayerVoteStatus(player) == S.getStateVal("roundState", "voteResult") end)
					if #winningPlayers > 0 then
						local balanceZone = getObjectsWithTag("zoneBalance")[1]
						return U.RunSequence({
							function()
								MSG.Splash("Moving Committed Power to Balance")
								return U.map(winningPlayers, function(player) return L.SetLightMode("lightFront", "ambient", player, 1) end)
							end,
							unpack(U.iMap(winningPlayers, function(player) return
								U.RunSequence({
									function()
										L.SetLightMode("lightFront", "bright", player, 0.5)
										Wait.time(function() V.LowerRiser(player) end, 2)
										return OU.TransferValue(
											P.GetPlayerZone(player, "Public"),
											balanceZone,
											OU.GetTotalValue(P.GetPlayerZone(player, "Public"), "PowerToken"),
											"PowerToken")
									end,
									function() return L.SetLightMode("lightFront", "dim", player, 0.5) end
								})
							end))
						})
					end
					return 0
				end,
				function() return L.SetLightMode("lightVote", "off") end,
				DIR.ADVANCE
			}
		end,
		DisplayOutcome = function()
			V.InitCountZones()
			return {
				function()
					local voteResult = S.getStateVal("roundState", "voteResult")
					if voteResult == nil then return 0 end

					local dilemmaCard = getObjectsWithAllTags({ "Dilemma", "OnDisplay" })[1]
					if dilemmaCard == nil then return U.AlertGM("No Dilemma Card Displayed!") end

					P.SetCamera("DilemmaResult")
					MSG.Splash("Rewards & Consequences")

					L.SetLightMode("lightDilemmaAye", "off", nil, 0.5)
					L.SetLightMode("lightDilemmaNay", "off", nil, 0.5)
					L.SetLightMode("lightDilemmaMain", voteResult or "off", nil, 2)

					if voteResult == nil then
						S.setStateVal(C.Phases.EnvelopeCheck, "gameState", "gamePhase")
						-- next 'DIR.ADVANCE' will move to EndRound
						return 0
					end

					if voteResult == "Nay" then
						dilemmaCard.alt_view_angle = Vector(0, 180, 180)
					else
						dilemmaCard.alt_view_angle = Vector(0, 0, 0)
					end

					return {
						U.setPositionSlow(dilemmaCard, C.Spots.Main.Dilemma["faceUp" .. voteResult].position, 2),
						U.setRotationSlow(dilemmaCard, C.Spots.Main.Dilemma["faceUp" .. voteResult].rotation, 2),
						dilemmaCard
					}
				end,
				DIR.ADVANCE
			}
		end,
		ApplyChanges = function()
			return {
				function() return MSG.Splash("Apply Changes to Resources") end
			}
		end,
		ApplyMomentum = function()
			local resourceTokens = getBoardTokens().resource
			local resourceDeltas = getTokenPositionDeltas(getTokenPositionsFromState(), getTokenPositionsFromBoard())
			local resourceBumps = getResourceTokenBumpsFromMomentum()
			local stabilityBumps = getStabilityTokenBumpsFromMomentum()
			log({stateData = S.getStateVal("roundState", "boardTokens"), resourceDeltas = resourceDeltas, resourceBumps = resourceBumps, stabilityBumps = stabilityBumps})
			return {
				function() return MSG.Splash("Applying Momentum") end,
				function()
					return U.RunSequence(U.iMap(C.Resources, function(resource)
						if resourceDeltas[resource] == 0 then return function() return 0 end end
						if resourceBumps[resource] == 0 then
							-- Token moved, but opposite direction to momentum: flip momentum
							return function()
								S.setStateVal(resourceDeltas[resource] > 0 and 1 or -1, "roundState", "boardTokens", "momentum", resource)
								return U.RunSequence({
									function()
										resourceTokens[resource].flip()
										return resourceTokens[resource]
									end,
									function() DIR.UpdateTokenLight(resource); return 0 end
								})
							end
						else
							-- Token moved in same direction to momentum: bump by momentum, bump stability, set momentum to 2
							return function()
								return U.RunSequence({
									function()
										return {
											DIR.BumpToken("Stability", stabilityBumps[resource]),
											DIR.BumpToken(resource, resourceBumps[resource])
										}
									end,
									function()
										S.setStateVal(resourceDeltas[resource] > 0 and 2 or -2, "roundState", "boardTokens", "momentum", resource)
										return {
											DIR.UpdateTokenLight(resource),
											DIR.UpdateTokenLight("Stability")
										}
									end
								})
							end
						end
					end))
				end,
				DIR.ADVANCE
			}
		end,
		StickerCheck = function()
			return {
				function()
					MSG.Splash("Checking for Chronicle Stickers")
					local queryResponse = {Yes = "true", No = "false"}
					return U.RunSequence({
						function()
							return MSG.SplashQuery(
								"Does the Dilemma unlock a Chronicle Sticker?",
								P.GetLeaderName(),
								queryResponse,
								P.GetLeader()
							)
						end,
						function()
							if queryResponse.response == "true" then
								return MSG.Splash("I gotta add Sticker retrieval in here ...")
							end
						end,
						DIR.ADVANCE
					})
				end
			}
		end,
		EnvelopeCheck = function()
			return {
				function()
					MSG.Splash("Checking for Chronicle Envelopes")
					local queryResponse = {Yes = "true", No = "false"}
					return U.RunSequence({
						function()
							return MSG.SplashQuery(
								"Does the Dilemma unlock a Chronicle Envelope?",
								P.GetLeaderName(),
								queryResponse,
								P.GetLeader()
							)
						end,
						function()
							if queryResponse.response == "true" then
								return MSG.Splash("I gotta add Envelope retrieval in here ...")
							end
						end,
						DIR.ADVANCE
					})
				end
			}
		end,
		EndRound = function()
			return {
				function()
					local voteResult = S.getStateVal("roundState", "voteResult")
					local dilemmaCard = getObjectsWithAllTags({ "Dilemma", "OnDisplay" })[1]
					if dilemmaCard == nil then return U.AlertGM("No Dilemma Card Displayed!") end
					L.SetLightMode("lightDilemmaMain", "off", nil, 2)
					L.SetLightMode("lightLectern", "ambient")

					dilemmaCard.removeTag("OnDisplay")
					dilemmaCard.addTag("Played")

					if voteResult == nil then
						return U.RunSequence({
							function()
								return {
									L.SetLightMode("lightLectern", "storyCard"),
									U.setPositionSlow(Vector(C.Spots.Staging.StoryCard.Display.position):add(Vector(0, 5, 0))),
									U.setRotationSlow(C.Spots.Staging.StoryCard.Display.rotation),
									U.setScaleSlow(C.Spots.Staging.StoryCard.Display.scale)
								}
							end,
							function()
								dilemmaCard.setLock(false)
								return { dilemmaCard, 0.5 }
							end,
							function()
								local curPos = Vector(dilemmaCard.getPosition())
								return function() return not dilemmaCard.getPosition():equals(curPos, 1) end
							end,
							function()
								-- 'spoof' state so next DIR.ADVANCE jumps to StartRound
								S.setStateVal("gameState", "gameMode", C.Modes.GAMESETUP)
								S.setStateVal("gameState", "gamePhase", C.Phases.GAMESETUP.PrepareFirstRound)
								return L.SetLightMode("lightLectern", "ambient")
							end
						})
					end

					local playedDilemmas = getObjectsWithAllTags({ "Dilemma", "Played" })
					local dilemmaTransform = C.Spots.Main.Dilemma["board" .. voteResult][#playedDilemmas]

					return U.RunSequence({
						function()
							dilemmaCard.setLock(false)
							return {
								U.setPositionSlow(dilemmaCard, dilemmaTransform.position, 2),
								U.setRotationSlow(dilemmaCard, dilemmaTransform.rotation, 2),
								U.setScaleSlow(dilemmaCard, dilemmaTransform.scale, 2)
							}
						end,
						function()
							-- Check Abdication
							local stabilityToken = getObjectsWithTag("StabilityMarker")[1]
							local stabilityZPos = stabilityToken.getPosition().z
							if stabilityZPos > 9 or stabilityZPos < -15 then
								return DIR.EndGame("Abdication")
							end

							-- Check King Death
							local playedDilemmas = getObjectsWithAllTags({ "Dilemma", "Played" })
							if #playedDilemmas == 10 then
								return DIR.EndGame("Death")
							elseif #playedDilemmas > 6 then
								local queryResponse = {Yes = "true", No = "false"}
								return U.RunSequence({
									function()
										return MSG.SplashQuery(
											"Does the dilemma bear a skull icon?",
											P.GetLeaderName(),
											queryResponse,
											P.GetLeader()
										)
									end,
									function()
										if queryResponse.response == "true" then
											return DIR.EndGame("Death")
										end

										return DIR.InitializePhase()
									end
								})
							else
								DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.StartRound)
								return DIR.InitializePhase()
							end
						end
					})
				end
			}
		end
	},
	END = {
		Score = function()
			return {


			}
		end,
		Realm = function()
			return {


			}
		end,
		Achievements = function()
			return {


			}
		end,
		Alignments = function()
			return {


			}
		end,
		Cleanup = function()
			return {


			}
		end
	}
}
-- #endregion

-- #region Session Setup & Phase Control~
function DIR.InitSession()
	UI.hide("sessionInitDisplay")
	UI.show("gameStatusDisplay")
	return U.RunSequence({
		function()
			S.UpdateSeatedPlayers()
			return 0
		end,
		function()
			UI.hide("splashScreen")
			P.SetCamera("BehindScreen")
			DIR.InitCountZones()
			return 0.75
		end,
		function()
			if S.isInMode(C.Modes.NONE) then
				DIR.ADVANCE()
			else
				DIR.JumpToStatePhase()
			end
			return 1
		end
	})
end

function DIR.ADVANCE(waitFunc)
	local mode, phase = S.getNextPhase()
	local function startPhase()
		S.setStateVal(mode, "gameState", "gameMode")
		S.setStateVal(phase, "gameState", "gamePhase")
		DIR.InitializePhase()
	end

	if waitFunc then
		U.waitUntil(startPhase, waitFunc, false)
	else
		startPhase()
	end
end

function DIR.RESET()
	S.setStateVal("NONE", "gameState", "gameMode")
	S.setStateVal("NONE", "gameState", "gamePhase")
	HOUSE_SELECTION = {}
	P.InitializeSeats()
	DIR.InitializePhase()
end

function DIR.InitializePhase()
	Global.call("UpdatePhaseDisplay")
	local mode = S.getStateVal("gameState", "gameMode")
	local phase = S.getStateVal("gameState", "gamePhase")
	local seqFuncs = INITFUNCS[mode]
	if U.Type(seqFuncs) == "table" then
		seqFuncs = seqFuncs[phase]
	end
	if U.Type(seqFuncs) == "function" then
		seqFuncs = seqFuncs()
	end
	U.RunSequence(seqFuncs)
end

function DIR.JumpToStatePhase(mode, phase)
	if mode ~= nil then
		S.setStateVal(mode, "gameState", "gameMode")
		S.setStateVal(mode, "gameState", "gamePhase")
	end
	if phase ~= nil then
		S.setStateVal(phase, "gameState", "gamePhase")
	end

	-- ... further logic to resync game environment to whatever point in the game we're at.
	P.ActivatePlayerScreenHUD()
	return L.InitLights()
end

-- #endregion

-- #region Chronicle Setup~
function DIR.SetChronicleType(isForcing)
	U.Assert("DIR.ADVANCE", S.getStateVal("gameState", "gameCount") == 1)
	if S.getStateVal("gameState", "chronicleType") ~= "" and not isForcing then return 0.25 end
	S.setStateVal(nil, "gameState", "chronicleType")
	local host = S.getPlayer("Host")
	host.showOptionsDialog(
		"How do you want to start your Chronicle of A King's Dilemma?",
		{ "Prologue", "Main" },
		"Prologue",
		function(response) S.setStateVal(response, "gameState", "chronicleType") end
	)
	return function() return S.getStateVal("gameState", "chronicleType") ~= nil end
end

function DIR.StartChronicle()
	U.Assert("DIR.StartChronicle", U.isIn(S.getStateVal("gameState", "chronicleType"), { "Main", "Prologue" }))
	local startingEnvelope = ({ Prologue = "D1", Main = "0" })[S.getStateVal("gameState", "chronicleType")]
	local kingName = ({ Prologue = "Harald IV", Main = "Harald V" })[S.getStateVal("gameState", "chronicleType")]

	return U.RunSequence({
		-- function() return L.SetLightMode("lightLectern", "spotlightChronicleCard") end,
		-- function() return DIR.PlaceChronicleCard(kingName) end,
		function()

			return P.SetCamera("Lectern") end,
		function()
			-- P.SetCamera("DilemmaPlinth")
			return DIR.OpenEnvelope(startingEnvelope) --, true)
		end
	})
end

-- #region House Selection ~
local HOUSE_SELECTION = {}
local function getUnselectedPlayers()
	return U.filter(S.getPlayers(), function(player)
		if S.getPlayerVal(player, "house") ~= nil then return false end
		if U.isIn(player.color, U.getValues(HOUSE_SELECTION)) then return false end
		return true
	end)
end

local function getHouseStatus(houseName, player)
	local playerOfHouseData = U.find(S.getStateVal("playerStorage"), function(pData) return pData.house == houseName end)
	if playerOfHouseData then
		local playerID = playerOfHouseData.id
		local seatedPlayerOfHouse = U.find(S.getStateVal("playerData"), function(pData) return pData.id == playerID end)
		if seatedPlayerOfHouse then
			if seatedPlayerOfHouse.color == player.color then
				return "Claimed", "BySelf", Color[player.color]
			else
				return "Claimed", "ByOther", Color[seatedPlayerOfHouse.color]
			end
		end
		return "Claimed", "ByAbsent"
	elseif HOUSE_SELECTION[houseName] then
		if HOUSE_SELECTION[houseName] == player.color then
			return "Selected", "BySelf", Color[player.color]
		else
			return "Selected", "ByOther", Color[HOUSE_SELECTION[houseName]]
		end
	else
		return "Available"
	end
end

function DIR.InitHouseSelection()
	HOUSE_SELECTION = {}
	if #getUnselectedPlayers() == 0 then
		DIR.AssignSelectedHouses()
	else
		U.forEach(S.getPlayers(), function(player)
			UI.show("houseSelection_" .. player.color)
		end)
		DIR.RefreshHouseHUD()
	end
end

local function getPlayerSelectedHouse(player)
	return U.findIndex(HOUSE_SELECTION, function(color) return color == player.color end)
end

local flagColors = {
	Available = function() return Color.Grey end,
	Hovered = function() return Color.White end,
	ClaimedByOther = function(playerColor) return playerColor:setAt("a", 0.5) end,
	ClaimedBySelf = function(playerColor) return playerColor end,
	ClaimedByAbsent = function() return Color.Grey:setAt("a", 0.1) end,
	SelectedByOther = function(playerColor) return playerColor:lerp(C.RootColors.PureBlack, 0.5) end,
	SelectedBySelf = function(playerColor) return playerColor:lerp(Color.White, 0.5) end,
	SelectedByOtherHover = function(playerColor) return playerColor end,
	SelectedBySelfHover = function() return Color.White end,
	Invisible = function() return C.RootColors.PureBlack:setAt("a", 0) end
}

function DIR.RefreshHouseHUD(houseName, player)
	if houseName == nil then return U.forEach(C.Houses, function(house) DIR.RefreshHouseHUD(house, player) end) end
	if player == nil then return U.forEach(S.getPlayers(), function(pl) DIR.RefreshHouseHUD(houseName, pl) end) end

	local houseStatus, statusDetail, statusColor = getHouseStatus(houseName, player)
	-- log({houseName = houseName, player = player.color, houseStatus = houseStatus, statusDetail = statusDetail, statusColor = statusColor})

	local flagID = "houseFlag_" .. houseName .. "_" .. player.color
	local hoverID = "houseHover_" .. houseName .. "_" .. player.color

	local flagAttrs = {
		color = U.GetHex(flagColors.Available()),
		image = C.Images.Flags.Base[houseName]
	}
	local hoverAttrs = {
		color = U.GetHex(flagColors.Invisible()),
		raycastTarget = "true",
		onMouseDown = "HUD_Click",
		onMouseEnter = "HUD_HoverOn",
		onMouseExit = "HUD_HoverOff"
	}

	if houseStatus == "Claimed" then
		-- log({ Claimed = houseName, statusDetail = statusDetail, statusColor = statusColor })
		flagAttrs.image = C.Images.Flags.Claimed[houseName]
		hoverAttrs.onMouseDown = ""
		hoverAttrs.color = U.GetHex(flagColors.Invisible())
		if statusDetail == "ByOther" then
			flagAttrs.color = U.GetHex(flagColors.ClaimedByOther(statusColor))
		elseif statusDetail == "BySelf" then
			flagAttrs.color = U.GetHex(flagColors.ClaimedBySelf(statusColor))
			hoverAttrs.color = U.GetHex(Color.White)
		elseif statusDetail == "ByAbsent" then
			flagAttrs.color = U.GetHex(flagColors.ClaimedByAbsent())
		end
	elseif houseStatus == "Selected" then
		flagAttrs.image = C.Images.Flags.Claimed[houseName]
		if statusDetail == "ByOther" then
			flagAttrs.color = U.GetHex(flagColors.SelectedByOther(statusColor))
			hoverAttrs.color = U.GetHex(flagColors.SelectedByOtherHover(statusColor))
			hoverAttrs.onMouseDown = ""
		elseif statusDetail == "BySelf" then
			flagAttrs.color = U.GetHex(flagColors.SelectedBySelf(statusColor))
			hoverAttrs.color = U.GetHex(flagColors.SelectedBySelfHover())
		end
	end

	UI.setAttributes(flagID, flagAttrs)
	UI.setAttributes(hoverID, hoverAttrs)
end

function DIR.HouseHUDClick(player, houseName)
	local houseStatus = getHouseStatus(houseName, player)
	-- log({ HOUSES_START = HOUSE_SELECTION, houseStatus = houseStatus, numUnselected = #getUnselectedPlayers() })
	if houseStatus == "Selected" then
		HOUSE_SELECTION[houseName] = false
	elseif houseStatus == "Available" then
		local curHouse = getPlayerSelectedHouse(player)
		if curHouse then
			HOUSE_SELECTION[curHouse] = false
			DIR.RefreshHouseHUD(curHouse)
		end
		HOUSE_SELECTION[houseName] = player.color
	end
	-- log({ HOUSES_END = HOUSE_SELECTION, numUnselected = #getUnselectedPlayers() })
	if #getUnselectedPlayers() == 0 then
		U.RunSequence({
			function()
				DIR.RefreshHouseHUD(houseName)
				return 2
			end,
			function()
				U.forEach(C.SeatColors, function(col) UI.hide("houseSelection_" .. col) end)
				return 2
			end,
			function()
				return DIR.AssignSelectedHouses()
			end
		})
	else
		DIR.RefreshHouseHUD(houseName)
	end
end

function DIR.HouseHUDHoverOn(player, houseName)
	local houseStatus = getHouseStatus(houseName, player)
	local curHouse = getPlayerSelectedHouse(player)
	if curHouse ~= nil then
		UI.setAttribute("houseInfo_" .. curHouse .. "_" .. player.color, "active", "false")
	end
	UI.show("houseInfo_" .. houseName .. "_" .. player.color)

	if houseStatus == "Available" then
		UI.setAttributes("houseFlag_" .. houseName .. "_" .. player.color, {
			color = U.GetHex(flagColors.Hovered())
		})
		UI.setAttributes("houseHover_" .. houseName .. "_" .. player.color, {
			color = U.GetHex(flagColors.Hovered())
		})
	end
end

function DIR.HouseHUDHoverOff(player, houseName)
	local houseStatus, statusDetail, statusColor = getHouseStatus(houseName, player)
	local curHouse = getPlayerSelectedHouse(player)
	if curHouse == houseName then return end
	if curHouse ~= nil then
		UI.setAttribute("houseInfo_" .. curHouse .. "_" .. player.color, "active", "true")
	end
	UI.hide("houseInfo_" .. houseName .. "_" .. player.color)

	if houseStatus == "Available" then
		UI.setAttributes("houseFlag_" .. houseName .. "_" .. player.color, {
			color = U.GetHex(flagColors.Available())
		})
		UI.setAttributes("houseHover_" .. houseName .. "_" .. player.color, {
			color = U.GetHex(flagColors.Invisible())
		})
	end
end

function DIR.AssignSelectedHouses()
	local newPlayerColors = {}
	if HOUSE_SELECTION ~= nil then
		U.forEach(HOUSE_SELECTION, function(color, houseName)
			if not color or not houseName then return end
			local player = S.getPlayer(color)
			table.insert(newPlayerColors, color)
			S.setPlayerVal(houseName, player, "house")
			S.setPlayerVal(nil, player, "houseName")
		end)
	end
	return U.RunSequence(U.concat({
			function()
				MSG.Splash("Setting Up Play Spaces")
				return 0.5
			end
		},
		U.map(S.getPlayers(), function(player)
			return function()
				local house = S.getPlayerVal(player, "house")
				return HouseScreen.Spawn(player, house, U.isIn(player.color, newPlayerColors))
			end
		end),
		{
			function() return 2 end,
			function() L.LoadLights({"lightBehind"}, "ambient"); return 2.5 end,
			function()
				P.ActivatePlayerScreenHUD()
				return L.LoadLights({ "lightFront" }, "ambient")
			end,
			function()
				U.AlertGM("All Done!")
				return 1
			end
		}
	))
end

-- #endregion

-- #endregion



-- #region Game Setup~
function DIR.SpawnBoardTokens()
	local seqFuncs = {}

	table.insert(seqFuncs, function()
		return U.RunSequence({
			function() return OU.SpawnFromSourceObj(O.SpawnSources.stabilityToken(), { "StabilityMarker" }, C.Spots.Board.StabilityToken.center, Vector(0, 1, 0)) end,
			function() return L.SetLightMode("lightStability", "on") end
		})
	end)

	U.iForEach(C.Resources, function(resName)
		table.insert(seqFuncs, function()
			return U.RunSequence({
				function()
					return OU.SpawnFromSourceObj(
						O.SpawnSources[string.lower(resName) .. "Token"](),
						{ "ResourceMarker", resName },
						C.Spots.Board.ResourceTokens[resName].center,
						Vector(0, 1, 0)
					)
				end,
				function()
					local tk = getBoardTokens().resource[resName]
					tk.setRotation(Vector(0, 180, U.randBetween(0, 1, true) * 180))
					tk.addForce(Vector(-0.07, 30, 0), 3)
					tk.addTorque(Vector(0, 0, 1.9), 3)
					return tk
				end,
				function() return DIR.UpdateTokenLight(resName) end
			})
		end)
	end)

	return U.RunSequence(seqFuncs, 1000, 1)
end

function DIR.EndSecretAgendas()
	L.SetLightMode("lightLectern", "ambient")
	L.SetLightMode("lightFront", "ambient")
	L.SetLightMode("lightPlayerSpotlight", "off")

	local heldAgendas = {}

	U.forEach(S.getPlayers(), function(player)
		heldAgendas = U.concat(heldAgendas, U.filter(player.getHandObjects(), function(obj) return obj.hasTag("SecretAgenda") end))
	end)

	U.forEach(heldAgendas, function(obj)
		obj.use_hands = false
		obj.setLock(true)
		obj.setPositionSmooth(C.Spots.Staging.SecretAgenda.Burnt.position)
		obj.setRotationSmooth(C.Spots.Staging.SecretAgenda.Burnt.rotation)
		Wait.time(function() obj.use_hands = true end, 0.5)
	end)
	U.AlertGM("Secret Agendas Dealt!")
end

function DIR.SpawnStartingPlayerPower()
	return U.RunSequence(U.map(S.getPlayers(), function(player)
		local numPower = 8 + (S.getPlayerVal(player, "startingPowerBonus") or 0)
		return function() return { 1, P.SpawnPower(player, numPower) } end
	end))
end

function DIR.SpawnStartingPlayerCoins()
	return U.RunSequence(U.map(S.getPlayers(), function(player)
		local numCoins = 10 + (S.getPlayerVal(player, "startingCoinsBonus") or 0)
		return function() return { 1, P.SpawnCoins(player, numCoins) } end
	end))
end

-- #endregion

-- #region Game Round~

-- #region Opening Envelopes & Adding New Dilemmas~
local function getDilemmaDeck()
	local coverCard = O.Pieces.CoverCard()
	return U.findBelowObject(coverCard, function(obj) return obj.type == "Card" or obj.type == "Deck" end)[1]
end

function DIR.PromptLeaderToHandleEnvelope(envDeck)
	local queryResponse = {Yes = "true", No = "false"}
	return U.RunSequence({
		function()
			MSG.SplashQuery(
				"Does this Envelope's Story Card contain special instructions?",
				"Leader",
				queryResponse,
				P.GetLeader()
			)
			return function() return queryResponse.response ~= nil end
		end,
		function()
			if queryResponse.response == "true" then
				return U.RunSequence({
					function()
						return {
							U.setPositionSlow(envDeck, C.Spots.Main.Dilemma.aboveDeck.position),
							U.setRotationSlow(envDeck, C.Spots.Main.Dilemma.aboveDeck.rotation)
						}
					end,
					function()
						envDeck.setLock(false)
						MSG.Splash({
							"Carry out instructions, then place",
							"new Dilemmas above Dilemma Deck."
						}, P.GetLeader().color, 4)
						return {0.5, envDeck}
					end
				})
			else
				return DIR.AddToDilemmaDeck(envDeck)
			end
		end
	})
end

function DIR.OpenEnvelope(envKey, isStandard)
	U.Assert("DIR.OpenEnvelope", envKey, "string")
	local envContainer = O.SecretContainers.Envelopes()
	U.Assert("DIR.OpenEnvelope", envContainer, "Object")

	local envGUID = OU.FindContainedObjGUID(envContainer, function(objData)
		return string.lower(objData.name) == string.lower(envKey)
	end)

	if not envGUID then
		U.Alert("Envelope '" .. envKey .. "' Not Found! Check Case & Spelling", Color(1, 0, 0))
		return
	end

	local envDeck, storyCard

	local seqFuncs = {
		function() return { L.SetLightMode("lightLectern", "spotlightEnvelope", nil, 0.25) } end,
		function()
			U.setPositionSlow(envContainer, C.Spots.Staging.Lectern.Envelopes.position)
			U.setRotationSlow(envContainer, C.Spots.Staging.Lectern.Envelopes.rotation)
			return { envContainer, L.SetLightMode("lightLectern", "spotlightPlinth", nil, 0.1) }
		end,
		function()
			envContainer.takeObject({
				position = C.Spots.Staging.Lectern.Display.position,
				rotation = C.Spots.Staging.Lectern.Display.rotation,
				guid = envGUID,
				callback_function = function(obj)
					envDeck = obj
					envDeck.setLock(true)
				end
			})
			return function() return envDeck ~= nil end
		end,
		function()
			U.setPositionSlow(envContainer, C.Spots.Storage.Envelopes.position)
			U.setRotationSlow(envContainer, C.Spots.Storage.Envelopes.rotation)
			return 0.3
		end,
		function()
			envDeck.takeObject({
				position = C.Spots.Staging.Lectern.TopCard.position,
				rotation = C.Spots.Staging.Lectern.TopCard.rotation,
				-- smooth = false,
				callback_function = function(obj)
					storyCard = obj
					storyCard.setTags({ "StoryCard" })
					storyCard.setLock(true)
					Wait.frames(function() storyCard.addForce(Vector(0, -1, 0), 3) end)
				end
			})
			return function() return storyCard ~= nil end
		end,
		function()
			return L.SetLightMode("lightLectern", "spotlightTransit", nil, 0.3)
		end
	}

	table.insert(seqFuncs, function() return DIR.PresentStoryCard(storyCard) end)

	if isStandard == true then
		table.insert(seqFuncs, function() return DIR.AddToDilemmaDeck(envDeck) end)
	else
		table.insert(seqFuncs, function() return DIR.PromptLeaderToHandleEnvelope(envDeck) end)
	end

	return U.RunSequence(seqFuncs)
end

function DIR.PresentStoryCard(storyCard)
	U.Assert("DIR.PresentStoryCard", storyCard, "Object")
	return U.RunSequence({
		function()
			storyCard.setPositionSmooth(Vector(C.Spots.Staging.StoryCard.Display.position):add(Vector(0, 5, 0)))
			storyCard.setRotationSmooth(Vector(C.Spots.Staging.StoryCard.Display.rotation))
			return {
				storyCard,
				L.SetLightMode("lightLectern", "storyCard")
			}
		end,
		function()
			storyCard.setLock(false)
			Wait.frames(function() storyCard.addForce(Vector(0, -1, 0), 3) end)
			return {
				storyCard,
				1.5
			}
		end,
		function()
			return P.SetCamera("MainBoard")
		end,
		function()
			L.SetLightMode({ "lightMainTop", "lightMainBottom" }, "ambient", nil, 2)
			return function()
				return not Vector.equals(storyCard.getPosition(),
					Vector(C.Spots.Staging.StoryCard.Display.position), 1)
			end
		end,
		function()
			return L.SetLightMode({ "lightLectern" }, "ambient", nil, 2)
		end
	})
end

function DIR.AddToDilemmaDeck(dilemmas)
	local coverCard = O.Pieces.CoverCard()
	U.Assert("DIR.AddToDilemmaDeck", coverCard, "Object")

	local seqFuncs = {}

	if dilemmas == nil then
		dilemmas = U.findAboveObject(coverCard, function(obj) return obj.type == "Deck" or obj.type == "Card" end, {box = true})
		U.Val("DIR.AddToDilemmaDeck", dilemmas, #dilemmas <= 1, "Multiple sources of dilemmas found above Cover Card. Consolidate them into a deck." )
		dilemmas = dilemmas[1]
		if dilemmas == nil then return 0 end
		table.insert(seqFuncs, function()
			return {
				U.setPositionSlow(dilemmas, dilemmas.getPosition():add(Vector(0, 4, 4))),
				U.setRotationSlow(dilemmas, coverCard.getRotation())
			}
		end)
	end

	U.Assert("DIR.AddToDilemmaDeck: Object Test", dilemmas, "Object")
	U.Assert("DIR.AddToDilemmaDeck: Deck or Card Test", U.isIn(dilemmas.type, { "Card", "Deck" }))

	coverCard.setLock(true)
	dilemmas.setLock(true)

	table.insert(seqFuncs, function()
		return {
			U.setPositionSlow(coverCard, coverCard.getPosition():add(Vector(0, 2, -3))),
			U.setRotationSlow(coverCard, coverCard.getRotation():add(Vector(0, 0, 70)))
		}
	end)

	local dilemmaCardDestPos = coverCard.getPosition():add(Vector(0, 4, 0))
	local dilemmaCardDestRot = coverCard.getRotation()

	local function addNextDilemma()
		dilemmaCardDestPos:add(Vector(0, 0.4, 0))
		if dilemmas.type == "Deck" then
			dilemmas.takeObject({
				position = dilemmaCardDestPos,
				rotation = dilemmaCardDestRot,
				callback_function = function(obj)
					obj.setTags({ "Dilemma" })
					obj.setLock(false)
				end
			})
			if dilemmas.remainder ~= nil then
				dilemmas = dilemmas.remainder
			end
			return 0.3
		elseif dilemmas.type == "Card" then
			dilemmas.setTags({ "Dilemma" })
			dilemmas.setLock(false)
			dilemmas.setPositionSmooth(dilemmaCardDestPos)
			dilemmas.setRotationSmooth(dilemmaCardDestRot)
			return 0.3
		end
	end

	if dilemmas.type == "Deck" then
		for i = 1, #dilemmas.getObjects() do
			table.insert(seqFuncs, addNextDilemma)
		end
	else
		table.insert(seqFuncs, addNextDilemma)
	end

	table.insert(seqFuncs, function()
		return {
			U.setPositionSlow(coverCard, C.Spots.Main.CoverCard.Closed.position),
			U.setRotationSlow(coverCard, C.Spots.Main.CoverCard.Closed.rotation)
		}
	end)
	table.insert(seqFuncs, function()
		coverCard.setLock(false)
		return { coverCard, 0.1 }
	end)
	table.insert(seqFuncs, function()
		getDilemmaDeck().shuffle()
	end)

	return U.RunSequence(seqFuncs)
end

-- #endregion

-- #region Voting~
function DIR.DisplayPassHUD(playerRef)
	local player = S.getPlayer(playerRef)
	return U.RunSequence({
		function()
			UI.setAttribute("passTurnHUD", "visibility", player.color)
			V.UpdateHUD(player, true)
			return 0.5
		end,
		function()
			UI.show("passTurnHUD")
			return 0.5
		end
	})
end
function DIR.TurnHUDClick(elemID)
	log({elemID = elemID})
	U.RunSequence({
		function()
			UI.hide("passTurnHUD")
			return V.EndTurn(elemID == "turnHUD_passMod") end,
		function()
			local activePlayers = U.filter(Player.getAvailableColors(), function(pColor)
				return pColor == S.getStateVal("roundState", "currentTurn") or U.isIn(S.getStateVal("turnState", pColor, "vote"), {false, "Aye", "Nay"})
			end)
			local playerIndex = U.findIndex(activePlayers, function(pColor) return pColor == S.getStateVal("roundState", "currentTurn") end)
			local nextPlayer
			if playerIndex == #activePlayers then
				nextPlayer = activePlayers[1]
			else
				nextPlayer = activePlayers[playerIndex + 1]
			end
			log({activePlayers = activePlayers, playerIndex = playerIndex, nextPlayer = nextPlayer})
			if P.GetLeader().color == nextPlayer then
				-- return DIR.ADVANCE()
				return 0
			end
			return U.RunSequence({
				function()
					DIR.DisplayPassHUD(nextPlayer)
					return V.StartTurn(nextPlayer)
				end
			})
		end
	})
end
-- #endregion


-- #region Momentum & Stability~
function DIR.BumpStability(amount)


end

function DIR.ApplyTokenMomentum(resource)

end


function DIR.GetUpdatedTokenMomentum(token, resource)
	local startTurnData = S.getStateVal("roundState", "boardTokens")
	if startTurnData == nil then return DIR.GetTokenMomentum(token, resource) end

	local startTurnPos = startTurnData[resource].pos
	local startTurnMomentum = startTurnData[resource].momentum
	local currentPos = OU.FindNearestSnapPoint(token, O.UninteractableObjs.Board())

	if startTurnPos > currentPos then
		if startTurnMomentum < 0 then
			return 1
		else
			return 2
		end
	elseif startTurnPos < currentPos then
		if startTurnMomentum > 0 then
			return -1
		else
			return -2
		end
	else
		return startTurnMomentum
	end
end

function DIR.UpdateTokenLight(resource)
	if resource == nil then return U.iMap(U.concat({"Stability"}, C.Resources), DIR.UpdateTokenLight) end
	if resource == "Stability" then
		return L.SetLightMode("lightStability", "on", nil, 0.5)
	end
	local momentum = getTokenMomentum(resource)
	local dir = momentum < 0 and "Down" or "Up"
	momentum = math.abs(momentum)
	return L.SetLightMode("light" .. resource, "momentum" .. dir .. momentum, nil, 0.5)
end

function DIR.UpdateMomentum(resource)
	if resource == nil then return U.map(C.Resources, DIR.UpdateMomentum) end
	local token = getObjectsWithAllTags({ "ResourceMarker", resource })[1]
	U.Assert("DIR.UpdateMomentum", token, "Object")
	local newMomentum = DIR.GetUpdatedTokenMomentum(token, resource)
	local newMomentumDir = newMomentum < 0 and "Down" or "Up"
	local newMomentumVal = math.abs(newMomentum)

	local seqFuncs = {}
	if newMomentum < 0 ~= U.isFlipped(token) then
		table.insert(seqFuncs, function()
			token.flip();
			return token
		end)
	end
	table.insert(seqFuncs, function()
		L.SetLightMode("light" .. resource, "momentum" .. newMomentumDir .. newMomentumVal)
	end)
	return U.RunSequence(seqFuncs)
end

function DIR.GetStabilityBump()
	local stabilityPos = S.getStateVal("roundState", "boardTokens", "positions", "Stability")
	local curPositions = getTokenPositionsFromBoard()
	U.forEach(C.Resources, function(resource)
		local prevPos = S.getStateVal("roundState", "boardTokens", "positions", resource)
		local curPos = curPositions[resource]
		local deltaPos = curPos - prevPos
		stabilityPos = math.max(math.min(stabilityPos + deltaPos, 19), 1)
	end)
	local boardStabilityPos = curPositions.Stability
	return stabilityPos - boardStabilityPos
end
-- #endregion


-- #endregion

-- #region End of Game~
function DIR.EndGame(endTrigger)
	if endTrigger == "Abdication" then
		return MSG.Splash("The King has Abdicated the Throne")
	elseif endTrigger == "Death" then
		return MSG.Splash("The King Is Dead!")
	end
end

local function getUpdatedChronicleCardState(cScriptState)
	local scriptState = JSON.decode(cScriptState)
	local playerKeys = { "1", "8", "15", "22", "29" }
	U.forEach(S.getPlayers(), function(player, i)
		local houseName = S.getPlayerVal(player, "houseName") or ""
		scriptState[playerKeys[i]] = houseName
	end)
	return JSON.encode(scriptState)
end

function DIR.PlaceChronicleCard(kingName)
	local sourceObj = O.SpawnSources.chronicleCard()
	local spawnData = sourceObj.getData()
	local cCard
	spawnData.Nickname = kingName
	spawnData.Description = os.date("%b ") .. os.date("*t").day .. " '" .. os.date("*t").year - 2000
	spawnData.Transform = OU.unfoldTransform(C.Spots.Main.ChronicleCard)
	spawnData.Tags = { "Lectern", "ChronicleCardActive" }
	spawnData.LuaScriptState = getUpdatedChronicleCardState(spawnData.LuaScriptState)
	spawnObjectData({
		data = spawnData,
		callback_function = function(obj) cCard = obj end
	})
	return function()
		-- log({ cCard = cCard })
		return cCard ~= nil
	end
end

function DIR.UpdateChronicleCardNames()
	local cCard = getObjectsWithTag("ChronicleCardActive")[1]
	if cCard == nil then return end
	local cData = cCard.getData()
	cCard.setCustomObject({ LuaScriptState = getUpdatedChronicleCardState(cData.LuaScriptState) })
	cCard.reload()
end

-- #endregion


return DIR