local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
local C = require("kingsdilemma.lib.constants")
local P = require("kingsdilemma.core.players")
local O = require("kingsdilemma.lib.objects")
local OU = require("kingsdilemma.objects.objUtilities")
local V = require("kingsdilemma.core.voting")
local L = require("kingsdilemma.core.lighting")
local MSG = require("kingsdilemma.core.messaging")
local HouseScreen = require("kingsdilemma.objs.p3screen")

local DIR = {}
local HOUSE_SELECTION, newPlayerColors = {}, {}


local function getBoardTokens()
	local tokens = {
		Stability = getObjectsWithTag("StabilityMarker")[1],
		resource = {}
	}
	local rTokens = getObjectsWithTag("ResourceMarker")
	table.sort(rTokens, function(a, b) return a.getPosition().x < b.getPosition().x end)
	tokens.resource.Influence = rTokens[1]
	tokens.resource.Wealth = rTokens[2]
	tokens.resource.Morale = rTokens[3]
	tokens.resource.Welfare = rTokens[4]
	tokens.resource.Knowledge = rTokens[5]
	return tokens
end

local function getTokenPositionsFromBoard()
	local board = O.UninteractableObjs.Board()
	local boardTokens = getBoardTokens()
	return {
		Stability = OU.FindNearestSnapPoint(boardTokens.Stability, board),
		Influence = OU.FindNearestSnapPoint(boardTokens.resource.Influence, board),
		Wealth = OU.FindNearestSnapPoint(boardTokens.resource.Wealth, board),
		Morale = OU.FindNearestSnapPoint(boardTokens.resource.Morale, board),
		Welfare = OU.FindNearestSnapPoint(boardTokens.resource.Welfare, board),
		Knowledge = OU.FindNearestSnapPoint(boardTokens.resource.Knowledge, board)
	}
end

local function getResourcePositionsFromBoard()
	local tokenPositions = getTokenPositionsFromBoard()
	tokenPositions.Stability = nil
	return tokenPositions
end

local function getTokenPositionsFromState()
	return {
		Influence = S.getStateVal("roundState", "boardTokens", "positions", "Influence"),
		Wealth = S.getStateVal("roundState", "boardTokens", "positions", "Wealth"),
		Morale = S.getStateVal("roundState", "boardTokens", "positions", "Morale"),
		Welfare = S.getStateVal("roundState", "boardTokens", "positions", "Welfare"),
		Knowledge = S.getStateVal("roundState", "boardTokens", "positions", "Knowledge"),
	}
end

local function getTokenMomentum(resource)
	local startTurnData = S.getStateVal("roundState", "boardTokens")
	if startTurnData == nil or startTurnData.momentum == nil or startTurnData.momentum[resource] == nil then
		local token = getBoardTokens().resource[resource]
		U.Assert("getTokenMomentum", token, "Object")
		return U.isFlipped(token) and -1 or 1
	else
		return startTurnData.momentum[resource]
	end
end

local function getTokenMomentums()
	return {
		Influence = getTokenMomentum("Influence"),
		Wealth = getTokenMomentum("Wealth"),
		Morale = getTokenMomentum("Morale"),
		Welfare = getTokenMomentum("Welfare"),
		Knowledge = getTokenMomentum("Knowledge"),
	}
end


local function bumpToken(token, unitForceVector, count, lightName)
	local forceVector = Vector(unitForceVector):scale(count > 0 and Vector(1, 1, 1) or Vector(1, 1, -1))
	local absCount = math.abs(count)
	if absCount <= 3 then
		if lightName then
			Wait.time(function() DIR.UpdateTokenLight(lightName) end, 0.6)
		end
		return token.addForce(Vector(forceVector):scale(Vector(1, 1, math.abs(count))), 3)
	else
		local seqFuncs = {}
		while absCount >= 3 do
			absCount = absCount - 3
			table.insert(seqFuncs, function() bumpToken(token, forceVector, 3, lightName) end)
		end
		while absCount >= 2 do
			absCount = absCount - 2
			table.insert(seqFuncs, function() bumpToken(token, forceVector, 2, lightName) end)
		end
		while absCount >= 1 do
			absCount = absCount - 1
			table.insert(seqFuncs, function() bumpToken(token, forceVector, 1, lightName) end)
		end
		return U.sequence(seqFuncs, 0.5)
	end
end

local function bumpStabilityToken(count)
	local forceVector = Vector(0, 15, 3.5)
	return bumpToken(getBoardTokens().Stability, forceVector, count, "Stability")
end

local function bumpResourceToken(tokenName, count)
	local forceVector = Vector(0, 15, 3.5)
	return bumpToken(getBoardTokens().resource[tokenName], forceVector, count, tokenName)
end

function DIR.BumpToken(tokenName, count)
	local tokenPos = getTokenPositionsFromBoard()
	local min, max = 1, tokenName == "Stability" and 19 or 17
	if tokenName == "Stability" and (tokenPos.Stability == 19 or tokenPos.Stability == 1) then
		return 0
	end
	count = math.max(math.min(count, max - tokenPos[tokenName]), min - tokenPos[tokenName])
	if tokenName == "Stability" then
		return bumpStabilityToken(count)
	elseif U.isIn(tokenName, C.Resources) then
		return bumpResourceToken(tokenName, count)
	end
end

function DIR.InitCountZones()
	U.forEach(S.getPlayers(), function(player)
		-- Player Private Power
		local powerZone = P.GetPlayerZone(player, "Power")
		if powerZone then
			powerZone.call("SetCountTag", "PowerToken")
			powerZone.call("SetColor", Color.Yellow)
			powerZone.call("SetIcon", "powerIcon")
			powerZone.call("SetIconColor", Color(C.RootColors.Amber):setAt("a", 0.6))
			powerZone.call("Activate")
		end

		-- Player Private Coin
		local coinZone = P.GetPlayerZone(player, "Coin")
		if coinZone then
			coinZone.call("SetCountTag", "CoinToken")
			coinZone.call("SetColor", Color.Yellow)
			coinZone.call("SetIcon", "coinIcon")
			coinZone.call("SetIconColor", Color(C.RootColors.Amber):setAt("a", 0.6))
			coinZone.call("Activate")
		end

		V.InitCountZones(player)
	end)

	-- Balance Plinth
	local balanceZone = getObjectsWithTag("zoneBalance")[1]
	if balanceZone then
		balanceZone.call("SetCountTag", "PowerToken")
		balanceZone.call("SetColor", Color.Yellow)
		balanceZone.call("SetIcon", "powerIcon")
		balanceZone.call("SetIconColor", Color(C.RootColors.Amber):setAt("a", 0.6))
		balanceZone.call("Activate")
	end
end

-- #region Initialization Functions~
local agendaDeck, agendaCard
local dilemmaCard
local queryResponse

INITFUNCS = {
	NONE = function() return {
		function()
			S.setStateVal({}, "playerData")
			P.ClearSeats()

			S.UpdatedSeatedPlayerData()
			return MSG.Splash("Resetting Table")
		end
	} end,
	SESSIONINIT = {
		SeatPlayers = function() return {
			DIR.ADVANCE
		} end,
		HouseSelection = function() return {
			function()
				if #DIR.GetUnselectedPlayers() == 0 then return 0 end
				return U.RunSequence({
					function() return MSG.Splash("House Selection", nil, 2) end,
					function()
						HOUSE_SELECTION = {}
						DIR.InitHouseSelectionHUD()
						return function() return HOUSE_SELECTION.isComplete == true end
					end
				})
			end,
			function()
				newPlayerColors = {}
				U.forEach(HOUSE_SELECTION, function(houseName, color)
					if not color or not houseName then return end
					if not U.isIn(color, C.SeatColors) then return end
					local player = S.getPlayer(color)
					table.insert(newPlayerColors, color)
					S.setPlayerVal(houseName, player, "house")
					S.setPlayerVal(nil, player, "houseName")
				end)
				UI.setAttribute("houseSelectionHUD", "active", "false")
				MSG.Splash("Setting Up Play Spaces", nil, 5)
				return 0.5
			end,
			function()
				return U.map(S.getPlayers(), function(player)
					return HouseScreen.Spawn(
						player,
						S.getPlayerVal(player, "house"),
						U.isIn(player.color, newPlayerColors)
					)
				end)
			end,
			function() return 2 end,
			function()
				L.LoadLights({"lightBehind"}, "ambient", 1.5)
				return 0.75
			end,
			function()
				P.ActivatePlayerScreenHUD()
				return L.LoadLights({ "lightFront" }, "ambient")
			end,
			function()
				UI.show("refHUDControls")
				return U.AlertGM("All Done!")
			end
		} end
	},
	CHRONSETUP = function()
		return {
			function()
				U.Assert("INITFUNCS.CHRONSETUP", S.getStateVal("gameState", "gameCount") == 0)
				queryResponse = {Prologue = "D1", ["Main Story"] = "0"}
				return MSG.SplashQuery(
					"How do you want to start your\nChronicle of The King's Dilemma?",
					"Host",
					queryResponse,
					S.getPlayer("Host")
				)
			end,
			function()
				MSG.Splash(P.GetLeaderName() .. " Is Most Prestigious")
				return L.SetLightMode("lightLeader", "on", nil, 0.5)
			end,
			P.AssignLeader,
			function()
				MSG.Splash(P.GetModeratorName() .. " Is Least Prestigious")
				return L.SetLightMode("lightModerator", "on", nil, 0.5)
			end,
			P.AssignModerator,
			function() return P.SetCamera("Lectern") end,
			function()
				L.LoadLights({ "lightLectern" }, "default")
				return MSG.Splash("Chronicle Setup")
			end,
			function()
				S.setStateVal(queryResponse.response, "gameState", "chronicleType")
				S.setStateVal(({
					["D1"] = "Harald IV",
					["0"] = "Harald V"
				})[queryResponse.response], "gameState", "kingName")
				return DIR.FetchEnvelope(queryResponse.response)
			end
		}
	end,
	GAMESETUP = {
		MainBoard = function() return {
			function()
				S.resetRoundState()
				S.setStateVal(S.getStateVal("gameState", "gameCount") + 1, "gameState", "gameCount")
				P.SetCamera("MainBoard")
				DIR.AddToDilemmaDeck()
				return MSG.Splash("Board Setup")
			end,
			DIR.SpawnBoardTokens,
			function()
				V.ElevateBalance()
				return L.SetLightMode("lightBalance", "bright", nil, 0.5)
			end,
			function()
				DIR.InitCountZones()
				V.SpawnBalanceTokens(3)
				L.SetLightMode("lightBalance", "on", nil, 3)
				return 1.5
			end,
			function() return P.SetCamera("BehindScreen") end,
			function()
				MSG.Splash("Distributing Power & Coin")
				return {
					DIR.SpawnStartingPlayerPower(),
					DIR.SpawnStartingPlayerCoins()
				}
			end,
			DIR.ADVANCE
		} end,
		LeaderModerator = function()
			if S.getStateVal("gameState", "leader") ~= nil then
				return {DIR.ADVANCE}
			else
				return {
					function()
						MSG.Splash(P.GetLeaderName() .. " Is Most Prestigious")
						return L.SetLightMode("lightLeader", "on", nil, 0.5)
					end,
					P.AssignLeader,
					function()
						MSG.Splash(P.GetModeratorName() .. " Is Least Prestigious")
						return L.SetLightMode("lightModerator", "on", nil, 0.5)
					end,
					P.AssignModerator,
					DIR.ADVANCE
				}
			end
		end,
		LegacySetup = function() return {
			function()
				P.SetCamera("MainBoard")
				return MSG.Splash("Legacy Effects")
			end,
			function()
				P.SetCamera("Stickers")
				return MSG.Splash("Open Agendas")
			end,
			DIR.ADVANCE
		} end,
		SecretAgendas = function()
			return {
				function()
					agendaDeck = getObjectsWithTag("SecretAgenda")[1]
					U.Val("SecretAgendas", agendaDeck, U.isGameObject(agendaDeck) and agendaDeck.type == "Deck")
					P.SetCamera("Lectern")
					return MSG.Splash("Secret Agendas")
				end,
				function()
					agendaDeck.setLock(true)
					L.SetLightMode("lightLectern", "spotlightDilemmaDeck", nil, 1)
					return {
						U.setPositionSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.High.position), 1),
						U.setRotationSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.High.rotation), 1)
					}
				end,
				function()
					U.setPositionSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.Low.position), 0.5)
					U.setRotationSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.Low.rotation), 0.5)
					return 0.25
				end,
				function()
					agendaDeck.shuffle()
					return 0.5
				end,
				function()
					local isSpawned = false
					agendaCard = agendaDeck.takeObject({
						position = Vector({ -0.01, 6.95, 24.41 }),
						rotation = Vector({ 0, 0, 180 }),
						callback_function = function(obj)
							obj.setLock(true)
							isSpawned = true
						end
					})
					return function() return isSpawned == true end
				end,
				function()
					return {
						U.setRotationSlow(agendaCard, Vector(C.Spots.Staging.SecretAgenda.Burnt.rotation), 2),
						U.setPositionSlow(agendaCard, Vector(C.Spots.Staging.SecretAgenda.Burnt.position), 2, "speedUp")
					}
				end,
				function()
					P.SetCamera("BehindScreen")
					return P.DealAll(agendaDeck, P.GetLeastPrestigious())
				end,
				function()
					L.SetLightMode("lightLectern", "off")
					L.SetLightMode("lightPlayerSpotlight", "player" .. S.getPlayerNum(P.GetLeastPrestigious()))
					L.SetLightMode("lightFront", "dim")
					return MSG.Splash("Choose Your Secret Agenda", P.GetLeastPrestigious())
				end
			}
		end,
		PrepareFirstRound = function()
			return {
				function()
					S.setStateVal(0, "roundState", "roundNum")
					S.setStateVal(getTokenMomentums(), "roundState", "boardTokens", "momentum")
					return DIR.ADVANCE()
				end
			}
		end
	},
	PLAY = {
		StartRound = function() return {
				function()
					S.setStateVal(S.getStateVal("roundState", "roundNum") + 1, "roundState", "roundNum")
					S.setStateVal(getTokenPositionsFromBoard(), "roundState", "boardTokens", "positions")
					S.setStateVal(P.GetLeader().color, "roundState", "currentTurn")
					S.setStateVal(false, "roundState", "passModClaimed")
					S.setStateVal(0, "roundState", "ayeTotal")
					S.setStateVal(0, "roundState", "nayTotal")
					U.forEach(S.getPlayers(), function(player)
						S.setPlayerTurnVal(false, player, "vote")
						S.setPlayerTurnVal(0, player, "powerCommitted")
					end)
					return DIR.ADVANCE()
				end
			}
		end,
		DrawDilemma = function() return {
				function()
					S.setStateVal({}, "roundState", "consequences")
					return {
						P.SetCamera("DilemmaDraw"),
						MSG.Splash("The Dilemma")
					}
				end,
				function()
					L.SetLightMode("lightLectern", "spotlightDilemmaDeck")
					return DIR.StageDilemmaCard()
				end,
				function()
					dilemmaCard = getObjectsWithAllTags({"Dilemma", "OnDisplay"})[1]
					DIR.InitConsequencesQuery()
					L.SetLightMode("lightLectern", "off", nil, 0.5)
					L.SetLightMode("lightDilemmaMain", "on", nil, 2)
					L.SetLightMode("lightDilemmaMain", "on", nil, 2)
					L.SetLightMode("lightDilemmaRef", "on")
					DIR.SpawnReferenceDilemmas(dilemmaCard)
					return {
						U.setPositionSlow(dilemmaCard, C.Spots.Main.Dilemma.faceDown.position, 2, "speedUp"),
						U.setRotationSlow(dilemmaCard, C.Spots.Main.Dilemma.faceDown.rotation, 2, "speedUp"),
						U.setScaleSlow(dilemmaCard, C.Spots.Main.Dilemma.faceDown.scale, 2, "speedUp")
					}
				end,
				function()
					MSG.Splash(P.GetLeaderName() .. ", the Dilemma Card is Yours", P.GetLeader())
					return {
						L.SetLightMode("lightDilemmaAye", "on", nil, 1),
						L.SetLightMode("lightDilemmaNay", "on", nil, 1)
					}
				end
			}
		end,
		Discussion = function()
			return {
				function()
					U.forEach(S.getPlayers(), function(player)
						if string.lower(UI.getAttribute("consequencesQuery_" .. player.color, "active")) == "true" then
							UI.hide("consequencesQuery_" .. player.color)
						end
					end)
					P.SetCamera("BehindScreen")
					return MSG.Splash("The Debate")
				end
			}
		end,
		Vote = function()
			local queryResponse = {Yes = "true", No = "false"}
			return {
				function()
					return MSG.SplashQuery(
						"Is a vote required this round?",
						P.GetLeaderName(),
						queryResponse,
						P.GetLeader()
					)
				end,
				function()
					if queryResponse.response == "true" then
						return U.RunSequence({
							function()
								MSG.Splash("The Vote")
								V.InitCountZones()
								return V.SetVotingLights()
							end,
							function()
								DIR.DisplayPassHUD(P.GetLeader())
								return V.StartTurn(P.GetLeader())
							end
						})
					else
						return U.RunSequence({
							function() return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.EndRound) end,
							function() return DIR.InitializePhase() end
						})
					end
				end
			}
		end,
		VoteResolution = function()
			return {
				function()
					UI.hide("consequencesSidebar")
					U.forEach(getObjectsWithTag("RefDilemma"), function(obj) obj.destruct() end)
					L.SetLightMode("lightDilemmaRef", "off")
					return {
						L.SetLightMode({"lightBehind"}, "ambient"),
						L.SetLightMode({"lightFront"}, "dim"),
						L.SetLightMode({"lightPlayerSpotlight"}, "off")
					}
				end,
				function()
					local nayTotal = S.getStateVal("roundState", "nayTotal")
					local ayeTotal = S.getStateVal("roundState", "ayeTotal")
					if ayeTotal == nayTotal then
						local query = {Aye = "Aye", Nay = "Nay"}
						return U.RunSequence({
							function()
								return L.SetLightMode({"lightPlayerSpotlight"}, "player" .. S.getPlayerNum(P.GetModerator()), nil, 1)
							end,
							function()
								if ayeTotal == 0 then
									MSG.Splash("Leadership falls to the Moderator, " .. P.GetModeratorName() .. ".")
									P.AssignLeader(P.GetModerator())
									return MSG.SplashQuery(
										"Does the proposed resolution succeed?",
										P.GetModeratorName(),
										query,
										P.GetModerator()
									)
								else
									MSG.Splash({
										"Tie.",
										"The Moderator will cast the deciding vote."
									})
									return MSG.SplashQuery(
										"Cast the tie-breaking vote.",
										P.GetModeratorName(),
										query,
										P.GetModerator()
									)
								end
							end,
							function()
								L.SetLightMode({"lightPlayerSpotlight"}, "off")
								S.setStateVal(query.response, "roundState", "voteResult")
								return 0
							end
						})
					elseif ayeTotal > nayTotal then
						S.setStateVal("Aye", "roundState", "voteResult")
					else
						S.setStateVal("Nay", "roundState", "voteResult")
					end
					return 0
				end,
				function()
					if S.getStateVal("roundState", "voteResult") == "Aye" then
						return MSG.Splash("The Resolution is Approved", nil, nil, {color = U.GetHex(Color.Blue)})
					else
						return MSG.Splash("The Resolution is Rejected", nil, nil, {color = U.GetHex(Color.Red)})
					end
				end,
				function()
					if S.getPlayerVoteStatus(P.GetLeader()) ~= S.getStateVal("roundState", "voteResult") then
						local winningPlayers = U.filter(S.getPlayers(), function(player) return S.getPlayerVoteStatus(player) == S.getStateVal("roundState", "voteResult") end)
						if #winningPlayers == 0 then return 0 end
						table.sort(winningPlayers, function(playerA, playerB) return S.getPlayerPowerCommitted(playerA) > S.getPlayerPowerCommitted(playerB) end)
						if #winningPlayers > 1 and S.getPlayerPowerCommitted(winningPlayers[1]) == S.getPlayerPowerCommitted(winningPlayers[2]) then
							local tiedPlayers = U.filter(winningPlayers, function(player) return S.getPlayerPowerCommitted(player) == S.getPlayerPowerCommitted(winningPlayers[1]) end)
							local queryResponse = {}
							U.forEach(tiedPlayers, function(player) queryResponse[P.GetPlayerName(player)] = player end)
							return U.RunSequence({
								function()
									return MSG.SplashQuery(
										"Pass Leadership to which player?",
										P.GetModeratorName(),
										queryResponse,
										P.GetModerator()
									)
								end,
								function()
									if P.GetModeratorName() == P.GetPlayerName(queryResponse.response) then
										MSG.Splash(P.GetModeratorName() .. " retains Leadership.")
									else
										MSG.Splash(P.GetModeratorName() .. " assigns Leadership to " .. P.GetPlayerName(queryResponse.response) .. ".")
									end
									return P.AssignLeader(queryResponse.response)
								end
							})
						else
							return U.RunSequence({
								function()
									MSG.Splash(P.GetPlayerName(winningPlayers[1]) .. " claims Leadership.")
									return P.AssignLeader(winningPlayers[1])
								end
							})
						end
					else
						return 0
					end
				end,
				function()
					local passPlayers = U.filter(S.getPlayers(), function(player) return U.isIn(S.getPlayerVoteStatus(player), {"Pass", "PassMod"}) end)
					if #passPlayers > 0 then
						MSG.Splash("Granting Coin for Abstaining")
						return U.RunSequence(U.iMap(passPlayers, function(player) return function()
							P.SpawnCoins(player, 1)
							L.PulseLight("lightFront", player)
							return 0.5
						end end))
					end
					return 0
				end,
				function()
					local passPowerPlayers = U.filter(S.getPlayers(), function(player) return S.getPlayerVoteStatus(player) == "Pass" end)
					local balanceZone = getObjectsWithTag("zoneBalance")[1]
					local balancePower = OU.GetTotalValue(balanceZone, "PowerToken")
					if #passPowerPlayers > 0 then
						local powerPerPlayer = math.floor(balancePower / #passPowerPlayers)
						if powerPerPlayer > 0 then
							MSG.Splash("Gathering Power")
							OU.TransferValue(
								balanceZone,
								U.iMap(passPowerPlayers, function(player) return P.GetPlayerZone(player, "Power") end),
								powerPerPlayer,
								"PowerToken"
							)
							return U.RunSequence(U.iMap(passPowerPlayers, function(player) return function()
								L.PulseLight("lightFront", player)
								return 0.75
							end end))
						end
					end
					return 0
				end,
				function()
					local losingPlayers = U.filter(S.getPlayers(), function(player) return U.isIn(S.getPlayerVoteStatus(player), {"Aye", "Nay"}) and S.getPlayerVoteStatus(player) ~= S.getStateVal("roundState", "voteResult") end)
					if #losingPlayers > 0 then
						MSG.Splash("Returning Power to Losing Players")
						return U.RunSequence(U.iMap(losingPlayers, function(player) return function()
							OU.TransferValue(
								P.GetPlayerZone(player, "Public"),
								P.GetPlayerZone(player, "Power"),
								OU.GetTotalValue(P.GetPlayerZone(player, "Public"), "PowerToken"),
								"PowerToken"
							)
							Wait.time(function() V.LowerRiser(player) end, 2)
							L.PulseLight("lightFront", player)
							return 0.75
						end end))
					end
					return 0
				end,
				function()
					local winningPlayers = U.filter(S.getPlayers(), function(player) return S.getPlayerVoteStatus(player) == S.getStateVal("roundState", "voteResult") end)
					if #winningPlayers > 0 then
						MSG.Splash("Moving Committed Power to Balance")
						local balanceZone = getObjectsWithTag("zoneBalance")[1]
						return U.RunSequence(U.iMap(winningPlayers, function(player) return function()
							OU.TransferValue(
								P.GetPlayerZone(player, "Public"),
								balanceZone,
								OU.GetTotalValue(P.GetPlayerZone(player, "Public"), "PowerToken"),
								"PowerToken"
							)
							Wait.time(function() V.LowerRiser(player) end, 2)
							L.PulseLight("lightFront", player)
							return 0.75
						end end))
					end
					return 0
				end,
				function() return L.SetLightMode("lightVote", "off") end,
				DIR.ADVANCE
			}
		end,
		DisplayOutcome = function()
			V.InitCountZones()
			return {
				function()
					local voteResult = S.getStateVal("roundState", "voteResult")
					if voteResult == nil then return 0 end

					dilemmaCard = getObjectsWithAllTags({ "Dilemma", "OnDisplay" })[1]
					if dilemmaCard == nil then return U.AlertGM("No Dilemma Card Displayed!") end

					P.SetCamera("DilemmaResult")
					MSG.Splash("Rewards & Consequences")

					L.SetLightMode("lightDilemmaAye", "off", nil, 0.5)
					L.SetLightMode("lightDilemmaNay", "off", nil, 0.5)
					L.SetLightMode("lightDilemmaMain", voteResult or "off", nil, 2)

					if voteResult == nil then
						S.setStateVal(C.Phases.EnvelopeCheck, "gameState", "gamePhase")
						-- next 'DIR.ADVANCE' will move to EndRound
						return 0
					end

					if voteResult == "Nay" then
						dilemmaCard.alt_view_angle = Vector(0, 180, 180)
					else
						dilemmaCard.alt_view_angle = Vector(0, 0, 0)
					end

					return {
						U.setPositionSlow(dilemmaCard, C.Spots.Main.Dilemma["faceUp" .. voteResult].position, 0.5),
						U.setRotationSlow(dilemmaCard, C.Spots.Main.Dilemma["faceUp" .. voteResult].rotation, 0.5),
						dilemmaCard
					}
				end
			}
		end,
		ApplyChanges = function()
			return {
				function()
					local voteResult = S.getStateVal("roundState", "voteResult")
					U.setPositionSlow(dilemmaCard, C.Spots.Main.Dilemma["faceUp" .. voteResult .. "Resolve"].position, 2)
					U.setRotationSlow(dilemmaCard, C.Spots.Main.Dilemma["faceUp" .. voteResult .. "Resolve"].rotation, 2)
					return MSG.Splash("Apply Changes to Resources") end
			}
		end,
		ApplyMomentum = function()

			local function getTokenPositionDeltas(startPositions, endPositions)
				local boardPositions = getTokenPositionsFromBoard()
				local statePositions = getTokenPositionsFromState()
				return {
					Influence = endPositions.Influence - startPositions.Influence,
					Wealth = endPositions.Wealth - startPositions.Wealth,
					Morale = endPositions.Morale - startPositions.Morale,
					Welfare = endPositions.Welfare - startPositions.Welfare,
					Knowledge = endPositions.Knowledge - startPositions.Knowledge
				}
			end

			local function getUnboundTokenPositionsAfterApplyingMomentum()
				local tokenMomentums = getTokenMomentums()
				local curTokenPositions = getTokenPositionsFromBoard()
				local positionDeltas = getTokenPositionDeltas(getTokenPositionsFromState(), curTokenPositions)
				local newTokenPositions = U.clone(curTokenPositions)

				U.iForEach(C.Resources, function(resource)
					if tokenMomentums[resource] * positionDeltas[resource] > 0 then
						-- moving in same direction: apply momentum
						newTokenPositions[resource] = newTokenPositions[resource] + tokenMomentums[resource]
					end
				end)

				return newTokenPositions
			end

			local resourceTokens = getBoardTokens().resource
			local resourceDeltas = getTokenPositionDeltas(getTokenPositionsFromState(), getTokenPositionsFromBoard())
			local resourceBumps = getTokenPositionDeltas(getTokenPositionsFromBoard(), getUnboundTokenPositionsAfterApplyingMomentum())
			local stabilityBumps = getTokenPositionDeltas(getTokenPositionsFromBoard(), getUnboundTokenPositionsAfterApplyingMomentum())
			return {
				function() return MSG.Splash("Applying Momentum") end,
				function()
					return U.RunSequence(U.iMap(C.Resources, function(resource)
						if resourceDeltas[resource] == 0 then return function() return 0 end end
						if resourceBumps[resource] == 0 then
							-- Token moved, but opposite direction to momentum: flip momentum
							return function()
								S.setStateVal(resourceDeltas[resource] > 0 and 1 or -1, "roundState", "boardTokens", "momentum", resource)
								return U.RunSequence({
									function()
										resourceTokens[resource].flip()
										return resourceTokens[resource]
									end,
									function() DIR.UpdateTokenLight(resource); return 0 end
								})
							end
						else
							-- Token moved in same direction to momentum: bump by momentum, bump stability, set momentum to 2
							return function()
								return U.RunSequence({
									function()
										return {
											DIR.BumpToken("Stability", stabilityBumps[resource]),
											DIR.BumpToken(resource, resourceBumps[resource])
										}
									end,
									function()
										S.setStateVal(resourceDeltas[resource] > 0 and 2 or -2, "roundState", "boardTokens", "momentum", resource)
										return {
											DIR.UpdateTokenLight(resource),
											DIR.UpdateTokenLight("Stability")
										}
									end
								})
							end
						end
					end))
				end,
				DIR.ADVANCE
			}
		end,
		StickerCheck = function() return {
			function()
				MSG.Splash("Checking for Chronicle Stickers")
				queryResponse = {Yes = "true", No = "false"}
				return MSG.SplashQuery(
					"Does the Dilemma unlock a Chronicle Sticker?",
					P.GetLeaderName(),
					queryResponse,
					P.GetLeader()
				)
			end,
			function()
				if queryResponse.response == "true" then
					return DIR.PromptForSticker(P.GetLeader())
				end
				return DIR.ADVANCE()
			end
		} end,
		EnvelopeCheck = function() return {
			function()
				MSG.Splash("Checking for Chronicle Envelopes")
				queryResponse = {Yes = "true", No = "false"}
				return MSG.SplashQuery(
					"Does the Dilemma unlock a Chronicle Envelope?",
					P.GetLeaderName(),
					queryResponse,
					P.GetLeader()
				)
			end,
			function()
				if queryResponse.response == "true" then
					return DIR.PromptForEnvelope(P.GetLeader())
				end
				return DIR.ADVANCE()
			end
		} end,
		EndRound = function()
			return {
				function()
					DIR.AddToDilemmaDeck()
					local voteResult = S.getStateVal("roundState", "voteResult")
					local dilemmaCard = getObjectsWithAllTags({ "Dilemma", "OnDisplay" })[1]
					if dilemmaCard == nil then return U.AlertGM("No Dilemma Card Displayed!") end
					L.SetLightMode("lightDilemmaMain", "off", nil, 2)
					L.SetLightMode("lightLectern", "ambient")

					dilemmaCard.removeTag("OnDisplay")
					dilemmaCard.addTag("Played")

					if voteResult == nil then
						return U.RunSequence({
							function()
								return {
									P.SetCamera("MainBoard"),
									L.SetLightMode("lightLectern", "storyCard"),
									U.setPositionSlow(dilemmaCard, Vector(C.Spots.Staging.StoryCard.Display.position):add(Vector(0, 5, 0)), 2),
									U.setRotationSlow(dilemmaCard, C.Spots.Staging.StoryCard.Display.rotation, 2),
									U.setScaleSlow(dilemmaCard, C.Spots.Staging.StoryCard.Display.scale, 1)
								}
							end,
							function()
								dilemmaCard.setLock(false)
								dilemmaCard.removeTag("Played")
								return { dilemmaCard, 0.5 }
							end,
							function()
								local curPos = Vector(dilemmaCard.getPosition())
								return function() return not dilemmaCard.getPosition():equals(curPos, 1) end
							end,
							function()
								-- 'spoof' state so next DIR.ADVANCE jumps to StartRound
								S.setStateVal(C.Modes.GAMESETUP, "gameState", "gameMode")
								S.setStateVal(C.Phases.GAMESETUP.PrepareFirstRound, "gameState", "gamePhase")
								return L.SetLightMode("lightLectern", "ambient")
							end
						})
					end

					local playedDilemmas = getObjectsWithAllTags({ "Dilemma", "Played" })
					local dilemmaTransform = C.Spots.Main.Dilemma["board" .. voteResult][#playedDilemmas]

					return U.RunSequence({
						function()
							dilemmaCard.setLock(false)
							return {
								U.setPositionSlow(dilemmaCard, Vector(dilemmaTransform.position):add(Vector(-3, 0, 0)), 2),
								U.setRotationSlow(dilemmaCard, dilemmaTransform.rotation, 2),
								U.setScaleSlow(dilemmaCard, dilemmaTransform.scale, 1),
								dilemmaCard
							}
						end,
						function()
							return U.setPositionSlow(dilemmaCard, Vector(dilemmaTransform.position):setAt("y", C.TableHeight), 1)
						end,
						function()
							-- Check Abdication
							local stabilityToken = getObjectsWithTag("StabilityMarker")[1]
							local stabilityZPos = stabilityToken.getPosition().z
							if stabilityZPos > 9 or stabilityZPos < -15 then
								return DIR.EndGame("Abdication")
							end

							-- Check King Death
							local playedDilemmas = getObjectsWithAllTags({ "Dilemma", "Played" })
							if #playedDilemmas == 10 then
								return DIR.EndGame("Death")
							elseif #playedDilemmas > 6 then
								local queryResponse = {Yes = "true", No = "false"}
								return U.RunSequence({
									function()
										return MSG.SplashQuery(
											"Does the dilemma bear a skull icon?",
											P.GetLeaderName(),
											queryResponse,
											P.GetLeader()
										)
									end,
									function()
										if queryResponse.response == "true" then
											return DIR.EndGame("Death")
										end
										DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.StartRound)
										return DIR.InitializePhase()
									end
								})
							else
								DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.StartRound)
								return DIR.InitializePhase()
							end
						end
					})
				end
			}
		end
	},
	END = {
		Score = function()
			return {


			}
		end,
		Realm = function()
			return {


			}
		end,
		Achievements = function()
			return {


			}
		end,
		Alignments = function()
			return {


			}
		end,
		Cleanup = function()
			return {


			}
		end
	}
}
-- #endregion

-- #region Session Setup & Phase Control~
function DIR.InitPreflight()
	UI.hide("sessionPreflightDisplay")
	UI.show("sessionInitDisplay")

	Global.call("UpdatePhaseDisplay")
	U.forEach(getObjectsWithTag("Private"), function(obj)
		local color = U.findColorTag(obj)
		if color then
			obj.setInvisibleTo(S.getOtherColors(color))
		end
	end)
	L.PrimeLights()
	U.forEach(O.UninteractableObjs, function(oFunc)
		oFunc().interactable = false
		oFunc().gizmo_selectable = false
	end)

	-- #region DEBUG
	console.load()
	Global.call("InitTestFuncButtons") -- Assign names to test function buttons
	-- #endregion

	if S.isInMode(C.Modes.NONE) then
		UI.setValue("gameNumText", "Game " .. S.getStateVal("gameState", "gameCount") + 1)
	else
		UI.setValue("gameNumText", "Game " .. S.getStateVal("gameState", "gameCount"))
	end
end


function DIR.InitSession(isNotShuffling)
	UI.hide("sessionInitDisplay")
	UI.show("gameStatusDisplay")
	return U.RunSequence({
		function()
			UI.hide("splashScreen")
			MSG.Splash("Seating Players", nil, 3)
			return P.AssignPlayerColors(isNotShuffling)
		end,
		function()
			P.InitializeSeatHandZones()
			local players = S.getPlayers()
			return {
				function() return #U.filter(players, function(pl) return pl.getHandCount() == 0 end) == 0 end
			}
		end,
		function()
			DIR.InitCountZones()
			return P.SetCamera("BehindScreen")
		end,
		function()
			if S.isInMode(C.Modes.NONE) then
				return DIR.ADVANCE()
			end
			return DIR.JumpToStatePhase()
		end
	})
end

function DIR.ADVANCE(waitFunc)
	local mode, phase = S.getNextPhase()
	local function startPhase()
		S.setStateVal(mode, "gameState", "gameMode")
		S.setStateVal(phase, "gameState", "gamePhase")
		DIR.InitializePhase()
	end

	if waitFunc then
		U.waitUntil(startPhase, waitFunc, false)
	else
		startPhase()
	end
end

function DIR.RESET()
	S.setStateVal("NONE", "gameState", "gameMode")
	S.setStateVal("NONE", "gameState", "gamePhase")
	HOUSE_SELECTION = {}
	P.InitializeSeatHandZones()
	DIR.InitializePhase()
end

function DIR.InitializePhase()
	Global.call("UpdatePhaseDisplay")
	local mode = S.getStateVal("gameState", "gameMode")
	local phase = S.getStateVal("gameState", "gamePhase")
	local seqFuncs = INITFUNCS[mode]
	if U.Type(seqFuncs) == "table" then
		seqFuncs = seqFuncs[phase]
	end
	if U.Type(seqFuncs) == "function" then
		seqFuncs = seqFuncs()
	end
	U.RunSequence(seqFuncs)
end

function DIR.JumpToStatePhase(mode, phase)
	if mode ~= nil then
		S.setStateVal(mode, "gameState", "gameMode")
		S.setStateVal(mode, "gameState", "gamePhase")
	end
	if phase ~= nil then
		S.setStateVal(phase, "gameState", "gamePhase")
	end

	if S.isInPhase({C.Phases.PLAY.DrawDilemma, C.Phases.PLAY.Discussion, C.Phases.PLAY.Vote}) then
		DIR.InitConsequencesQuery()
	end
	if S.isInMode({C.Modes.CHRONSETUP, C.Modes.GAMESETUP, C.Modes.PLAY, C.Modes.END}) then
		UI.show("refHUDControls")
	end

	-- ... further logic to resync game environment to whatever point in the game we're at.
	P.ActivatePlayerScreenHUD()
	return L.InitLights()
end

-- #endregion

-- #region Chronicle Setup~

-- #region House Selection ~

function DIR.GetUnselectedPlayers()
	return U.filter(S.getPlayers(), function(player)
		return not HOUSE_SELECTION[player.color] and not S.getPlayerVal(player, "house")
	end)
end

local function isHouseClaimed(houseName) return S.getPlayerOfHouse(houseName) ~= false end
local function getSelectingPlayer(houseName) return U.findIndex(HOUSE_SELECTION, function(hName) return houseName == hName end) end

function DIR.InitHouseSelectionHUD()

	if #DIR.GetUnselectedPlayers() == 0 then
		HOUSE_SELECTION.isComplete = true
		else
		U.forEach(C.Houses, function(houseName)
			if isHouseClaimed(houseName) then
				local claimColor = S.getPlayerOfHouse(houseName)
				if U.isIn(claimColor, Player.getAvailableColors()) then
					claimColor = Color[claimColor]
					UI.setAttribute("houseHUD_Dark_" .. houseName, "color", U.GetHex(Color(claimColor):lerp(Color(C.RootColors.PureBlack):setAt("a", 1), 0.5)))
					UI.setAttribute("houseHUD_Dark_" .. houseName, "active", "true")
				else
					claimColor = Color.Black
					UI.setAttribute("houseHUD_Dark_" .. houseName, "color", U.GetHex(Color(C.RootColors.PureBlack):setAt("a", 0.85)))
					UI.setAttribute("houseHUD_Dark_" .. houseName, "active", "true")
				end
				UI.setAttribute("houseHUD_BannerBW_" .. houseName, "color", U.GetHex(claimColor))
			end
		end)
		UI.show("houseSelectionHUD")
	end

end

function DIR.UnselectHouse(houseName)
	HOUSE_SELECTION[U.findIndex(HOUSE_SELECTION, function(hName) return houseName == hName end)] = nil
	UI.setAttribute("houseHUD_BannerBW_" .. houseName, "color", U.GetHex(Color.White))
	UI.setAttribute("houseHUD_Overlay_" .. houseName, "color", U.GetHex(Color.White))
	UI.setAttribute("houseHUD_Dark_" .. houseName, "active", "false")
	UI.setAttribute("houseHUD_Overlay_" .. houseName, "active", "false")
end

function DIR.SelectHouse(player, houseName)
	HOUSE_SELECTION[player.color] = houseName
	UI.setAttribute("houseHUD_BannerBW_" .. houseName, "color", U.GetHex(Color[player.color]))
	UI.setAttribute("houseHUD_Overlay_" .. houseName, "color", U.GetHex(Color[player.color]:setAt("a", 0.5)))
	UI.setAttribute("houseHUD_Dark_" .. houseName, "color", U.GetHex(Color[player.color]:setAt("a", 0.5)))
	UI.setAttribute("houseHUD_Dark_" .. houseName, "active", "true")
	UI.setAttribute("houseHUD_Overlay_" .. houseName, "active", "true")
	if #DIR.GetUnselectedPlayers() == 0 then
		Wait.time(function() HOUSE_SELECTION.isComplete = true end, 1.5)
		end
end

function DIR.HouseHUDClick(player, houseName)
	if isHouseClaimed(houseName) then return end
	if S.getPlayerHouse(player) then return end
	if not U.isIn(houseName, C.Houses) then return end
	local curSelection = getSelectingPlayer(houseName)
	if curSelection ~= nil and curSelection ~= player.color then return end
	local curHouse = HOUSE_SELECTION[player.color]
	if curHouse ~= nil then DIR.UnselectHouse(curHouse) end
	if curHouse ~= houseName then DIR.SelectHouse(player, houseName) end
end

function DIR.HouseHUDHoverOn(player, houseName)
	UI.setAttribute("houseHUD_Bright_" .. houseName .. "_" .. player.color, "active", "false")
	UI.setAttribute("houseHUD_Info_" .. houseName .. "_" .. player.color, "active", "false")
	UI.show("houseHUD_Bright_" .. houseName .. "_" .. player.color)
	UI.show("houseHUD_Info_" .. houseName .. "_" .. player.color)
end

function DIR.HouseHUDHoverOff(player, houseName)
	UI.setAttribute("houseHUD_Bright_" .. houseName .. "_" .. player.color, "active", "true")
	UI.setAttribute("houseHUD_Info_" .. houseName .. "_" .. player.color, "active", "true")
	UI.hide("houseHUD_Bright_" .. houseName .. "_" .. player.color)
	UI.hide("houseHUD_Info_" .. houseName .. "_" .. player.color)
end

-- #endregion

-- #endregion



-- #region Game Setup~
function DIR.SpawnBoardTokens()
	local seqFuncs = {}

	table.insert(seqFuncs, function()
		Wait.time(function() L.SetLightMode("lightStability", "on") end, 1)
		return OU.SpawnFromSourceObj(O.SpawnSources.stabilityToken(), { "StabilityMarker" }, C.Spots.Board.StabilityToken.center, Vector(0, 1, 0))
	end)

	U.iForEach(C.Resources, function(resName)
		table.insert(seqFuncs, function()
			return U.RunSequence({
				function()
					return OU.SpawnFromSourceObj(
						O.SpawnSources[string.lower(resName) .. "Token"](),
						{ "ResourceMarker", resName },
						C.Spots.Board.ResourceTokens[resName].center,
						Vector(0, 1, 0)
					)
				end,
				function()
					local tk = getBoardTokens().resource[resName]
					tk.setRotation(Vector(0, 180, U.randBetween(0, 1, true) * 180))
					tk.addForce(Vector(-0.07, 30, 0), 3)
					tk.addTorque(Vector(0, 0, 1.9), 3)
					U.waitUntil(function() DIR.UpdateTokenLight(resName) end, {0.5, tk})
					return tk
				end
			})
		end)
	end)

	return U.RunSequence(seqFuncs, 1000, 1)
end

function DIR.EndSecretAgendas()
	L.SetLightMode("lightLectern", "ambient")
	L.SetLightMode("lightFront", "ambient")
	L.SetLightMode("lightPlayerSpotlight", "off")

	local heldAgendas = {}

	U.forEach(S.getPlayers(), function(player)
		heldAgendas = U.concat(heldAgendas, U.filter(player.getHandObjects(), function(obj) return obj.hasTag("SecretAgenda") end))
	end)

	U.forEach(heldAgendas, function(obj)
		obj.use_hands = false
		obj.setLock(true)
		obj.setPositionSmooth(C.Spots.Staging.SecretAgenda.Burnt.position)
		obj.setRotationSmooth(C.Spots.Staging.SecretAgenda.Burnt.rotation)
		Wait.time(function() obj.use_hands = true end, 0.5)
	end)
	U.AlertGM("Secret Agendas Dealt!")
end

function DIR.SpawnStartingPlayerPower()
	return U.RunSequence(U.map(S.getPlayers(), function(player)
		local numPower = 8 + (S.getPlayerVal(player, "startingPowerBonus") or 0)
		return function()
			L.PulseLight("lightFront", player)
			return { 1, P.SpawnPower(player, numPower) }
		end
	end))
end

function DIR.SpawnStartingPlayerCoins()
	return U.RunSequence(U.map(S.getPlayers(), function(player)
		local numCoins = 10 + (S.getPlayerVal(player, "startingCoinsBonus") or 0)
		return function() return { 1, P.SpawnCoins(player, numCoins) } end
	end))
end
-- #endregion

-- #region Game Round~

-- #region Stickers & Envelopes~
function DIR.PromptForSticker(player)
	UI.setAttribute("stickerQuery_" .. player.color, "active", "false")
	UI.setAttribute("stickerQuery_" .. player.color, "text", " ")
	UI.show("stickerQuery_" .. player.color)
end

function DIR.ConfirmFetchSticker(player, stickerKey)
	U.forEach(S.getPlayers(), function(ply) UI.hide("stickerQuery_" .. ply.color) end)
	local query = {Yes = "true", No = "false"}
	return U.RunSequence({
		function()
			return MSG.SplashQuery(
				"Confirm Sticker Key '" .. stickerKey .. "'",
				P.GetPlayerName(player),
				query,
				player
			)
		end,
		function()
			if query.response == "true" then
				return DIR.FetchSticker(stickerKey)
			else
				return DIR.PromptForSticker(player)
			end
		end
	})
end

function DIR.FetchSticker(stickerKey)
	local stickerContainer = O.SecretContainers.Stickers()
	local stickerGUID = OU.FindContainedObjGUID(stickerContainer, function(objData)
		return string.lower(objData.name) == string.lower(stickerKey)
	end)

	if not stickerGUID then
		U.Alert("Sticker '" .. stickerKey .. "' Not Found! Check Case & Spelling", Color(1, 0, 0))
		return
	end

	local sticker
	local displayedDilemma = getObjectsWithAllTags({"Dilemma", "OnDisplay"})[1]

	return U.RunSequence({
		function()
			P.SetCamera("Lectern")
			if displayedDilemma ~= nil then
				local yRot = displayedDilemma.getRotation().y
				local outcome = yRot > 170 and "Nay" or "Aye"
				return {
					U.setPositionSlow(displayedDilemma, C.Spots.Main.Dilemma["faceUp" .. outcome .. "Shrink"].position, 0.5),
					U.setScaleSlow(displayedDilemma, C.Spots.Main.Dilemma["faceUp" .. outcome .. "Shrink"].scale, 0.5),
					L.SetLightMode("lightLectern", "spotlightSticker", nil, 0.25)
				}
			else
				return L.SetLightMode("lightLectern", "spotlightSticker", nil, 0.25)
			end
		end,
		function()
			U.setPositionSlow(stickerContainer, C.Spots.Staging.Lectern.Stickers.position)
			U.setRotationSlow(stickerContainer, C.Spots.Staging.Lectern.Stickers.rotation)
			return { stickerContainer, L.SetLightMode("lightLectern", "spotlightPlinth", nil, 0.1) }
		end,
		function()
			stickerContainer.takeObject({
				position = C.Spots.Staging.Lectern.Display.position,
				rotation = C.Spots.Staging.Lectern.Display.rotation,
				guid = stickerGUID,
				callback_function = function(obj)
					sticker = obj
					sticker.addTag("ChronicleSticker")
					sticker.setLock(true)
				end
			})
			return function() return sticker ~= nil end
		end,
		function()
			U.setPositionSlow(stickerContainer, C.Spots.Storage.Stickers.position)
			U.setRotationSlow(stickerContainer, C.Spots.Storage.Stickers.rotation)
			return 0.3
		end,
		function() return L.SetLightMode("lightLectern", "spotlightTransit", nil, 0.3) end,
		function()
			sticker.setPositionSmooth(Vector(C.Spots.Staging.Sticker.Display.position):add(Vector(0, 5, 0)))
			sticker.setRotationSmooth(Vector(C.Spots.Staging.Sticker.Display.rotation))
			return {
				sticker,
				L.SetLightMode("lightLectern", "spotlightDilemmaDeck")
			}
		end,
		function()
			sticker.setLock(false)
			Wait.frames(function() sticker.addForce(Vector(0, -1, 0), 3) end)
			return {
				sticker,
				1.5
			}
		end,
		function()
			P.SetCamera("Stickers")
			return function()
				return not Vector.equals(sticker.getPosition(),
					Vector(C.Spots.Staging.Sticker.Display.position), 1)
			end
		end,
		function() return L.SetLightMode({ "lightLectern" }, "ambient", nil, 0.5) end
	})
end

function DIR.PromptForEnvelope(player)
	UI.setAttribute("envelopeQuery_" .. player.color, "active", "false")
	UI.setAttribute("envelopeQuery_" .. player.color, "text", " ")
	UI.show("envelopeQuery_" .. player.color)
end

function DIR.ConfirmFetchEnvelope(player, envKey)
	U.forEach(S.getPlayers(), function(ply) UI.hide("envelopeQuery_" .. ply.color) end)
	local query = {Yes = "true", No = "false"}
	return U.RunSequence({
		function()
			return MSG.SplashQuery(
				"Confirm Envelope Key '" .. envKey .. "'",
				P.GetPlayerName(player),
				query,
				player
			)
		end,
		function()
			if query.response == "true" then
				return DIR.FetchEnvelope(envKey, false)
			else
				return DIR.PromptForEnvelope(player)
			end
		end
	})
end

function DIR.FetchEnvelope(envKey)
	U.Assert("DIR.FetchEnvelope", envKey, "string")
	local envContainer = O.SecretContainers.Envelopes()
	U.Assert("DIR.FetchEnvelope", envContainer, "Object")

	local envGUID = OU.FindContainedObjGUID(envContainer, function(objData)
		return string.lower(objData.name) == string.lower(envKey)
	end)

	if not envGUID then return U.Alert("Envelope '" .. envKey .. "' Not Found! Check Case & Spelling", Color(1, 0, 0)) end

	local displayedDilemma = getObjectsWithAllTags({"Dilemma", "OnDisplay"})[1]

	local envDeck, storyCard

	-- local seqFuncs = {
	return U.RunSequence({
		function()
				P.SetCamera("Lectern")
				if displayedDilemma ~= nil then
					local yRot = displayedDilemma.getRotation().y
					local outcome = yRot > 170 and "Nay" or "Aye"
					return {
						U.setPositionSlow(displayedDilemma, C.Spots.Main.Dilemma["faceUp" .. outcome .. "Shrink"].position, 0.5),
						U.setScaleSlow(displayedDilemma, C.Spots.Main.Dilemma["faceUp" .. outcome .. "Shrink"].scale, 0.5),
						L.SetLightMode("lightLectern", "spotlightEnvelope", nil, 0.25)
					}
				else
					return L.SetLightMode("lightLectern", "spotlightEnvelope", nil, 0.25)
				end
		end,
		function()
			U.setPositionSlow(envContainer, C.Spots.Staging.Lectern.Envelopes.position)
			U.setRotationSlow(envContainer, C.Spots.Staging.Lectern.Envelopes.rotation)
			return { envContainer, L.SetLightMode("lightLectern", "spotlightPlinth", nil, 0.1) }
		end,
		function()
			envContainer.takeObject({
				position = C.Spots.Staging.Lectern.Display.position,
				rotation = C.Spots.Staging.Lectern.Display.rotation,
				guid = envGUID,
				callback_function = function(obj)
					envDeck = obj
					envDeck.setLock(true)
				end
			})
			return function() return envDeck ~= nil end
		end,
		function()
			U.setPositionSlow(envContainer, C.Spots.Storage.Envelopes.position)
			U.setRotationSlow(envContainer, C.Spots.Storage.Envelopes.rotation)
			return 0.3
		end,
		function()
			envDeck.takeObject({
				position = C.Spots.Staging.Lectern.TopCard.position,
				rotation = C.Spots.Staging.Lectern.TopCard.rotation,
				-- smooth = false,
				callback_function = function(obj)
					storyCard = obj
					storyCard.setTags({ "StoryCard" })
					storyCard.setLock(true)
					storyCard.use_hands = false
					Wait.frames(function() storyCard.addForce(Vector(0, -1, 0), 3) end)
				end
			})
			return function() return storyCard ~= nil end
		end,
		function()
			return L.SetLightMode("lightLectern", "spotlightTransit", nil, 0.3)
		end,
		function()
			storyCard.setPositionSmooth(Vector(C.Spots.Staging.StoryCard.Display.position):add(Vector(0, 5, 0)))
			storyCard.setRotationSmooth(Vector(C.Spots.Staging.StoryCard.Display.rotation))
			return {
				storyCard,
				L.SetLightMode("lightLectern", "storyCard")
			}
		end,
		function()
			storyCard.setLock(false)
			Wait.frames(function() storyCard.addForce(Vector(0, -1, 0), 3) end)
			return {
				storyCard,
				1.5
			}
		end,
		function()
			MSG.Splash(P.GetLeaderName() .. ", the Story Card is Yours", P.GetLeader())
			return P.SetCamera("Stickers")
		end,
		function()
			L.SetLightMode({ "lightMainTop", "lightMainBottom" }, "ambient", nil, 2)
			return function()
				return not Vector.equals(storyCard.getPosition(),
					Vector(C.Spots.Staging.StoryCard.Display.position), 1)
			end
		end,
		function()
			local coverCard = O.Pieces.CoverCard()
			coverCard.setLock(true)
			coverCard.setPositionSmooth(coverCard.getPosition():add(Vector(0, 1, 0)))
			U.setPositionSlow(envDeck, C.Spots.Main.Dilemma.aboveDeck.position)
			U.setRotationSlow(envDeck, C.Spots.Main.Dilemma.aboveDeck.rotation)
			envDeck.setLock(false)
			-- DIR.PromptLeaderToHandleEnvelope(envDeck)
			return L.SetLightMode({ "lightLectern" }, "ambient", nil, 0.5)
		end
	})
end
-- #endregion

-- #region Dilemma Cards & Consequences Query~
local function getDilemmaDeck()
	local coverCard = O.Pieces.CoverCard()
	return U.findBelowObject(coverCard, function(obj) return obj.type == "Card" or obj.type == "Deck" end)[1]
end

function DIR.StageDilemmaCard()
	local coverCard = O.Pieces.CoverCard()
	local dilemmaSource = U.findBelowObject(coverCard, function(obj) return obj.type == "Card" or obj.type == "Deck" end)
	U.Val("DIR.DrawDilemmaCard", dilemmaSource, #dilemmaSource == 1)
	dilemmaSource = dilemmaSource[1]
	local dilemmaCard
	if dilemmaSource.type == "Deck" then
		dilemmaSource.takeObject({
			position = C.Spots.Staging.DilemmaDraw.position,
			rotation = C.Spots.Staging.DilemmaDraw.rotation,
			top = false,
			callback_function = function(obj)
				obj.use_hands = false
				obj.addTag("OnDisplay")
				obj.setLock(true)
				dilemmaCard = obj
			end
		})
		return function() return dilemmaCard ~= nil end
	elseif dilemmaSource.type == "Card" then
		dilemmaCard = dilemmaSource
		dilemmaCard.use_hands = false
		dilemmaCard.setLock(true)
		dilemmaCard.addTag("OnDisplay")
		return {
			U.setPositionSlow(dilemmaCard, C.Spots.Staging.DilemmaDraw.position),
			U.setRotationSlow(dilemmaCard, C.Spots.Staging.DilemmaDraw.rotation)
		}
	end
end

function DIR.SpawnReferenceDilemmas(dilemmaCard)
	U.forEach(S.getPlayers(), function(player)
		local angle = S.getPlayerAngle(player)
		local targetTransform = OU.RotateByAngle(C.Spots.Player.DilemmaSpot, angle)
		local tags = {"RefDilemma"}
		OU.SpawnFromSourceObj(dilemmaCard, tags, targetTransform, nil, nil, true)

	end)
end

function DIR.AddToDilemmaDeck(dilemmas)
	local coverCard = O.Pieces.CoverCard()
	U.Assert("DIR.AddToDilemmaDeck", coverCard, "Object")

	local seqFuncs = {}

	if dilemmas == nil then
		dilemmas = U.findAboveObject(coverCard, function(obj) return obj.type == "Deck" or obj.type == "Card" end, {box = true})
		U.Val("DIR.AddToDilemmaDeck", dilemmas, #dilemmas <= 1, "Multiple sources of dilemmas found above Cover Card. Consolidate them into a deck." )
		dilemmas = dilemmas[1]
		if dilemmas == nil then return 0 end
		table.insert(seqFuncs, function()
			return {
				U.setPositionSlow(dilemmas, dilemmas.getPosition():add(Vector(0, 4, 4))),
				U.setRotationSlow(dilemmas, coverCard.getRotation())
			}
		end)
	end

	U.Assert("DIR.AddToDilemmaDeck: Object Test", dilemmas, "Object")
	U.Assert("DIR.AddToDilemmaDeck: Deck or Card Test", U.isIn(dilemmas.type, { "Card", "Deck" }))

	coverCard.setLock(true)
	dilemmas.setLock(true)

	table.insert(seqFuncs, function()
		return {
			U.setPositionSlow(coverCard, coverCard.getPosition():add(Vector(0, 2, -3))),
			U.setRotationSlow(coverCard, coverCard.getRotation():add(Vector(0, 0, 70)))
		}
	end)

	local dilemmaCardDestPos = coverCard.getPosition():add(Vector(0, 4, 0))
	local dilemmaCardDestRot = coverCard.getRotation()

	local function addNextDilemma()
		dilemmaCardDestPos:add(Vector(0, 0.4, 0))
		if dilemmas.type == "Deck" then
			dilemmas.takeObject({
				position = dilemmaCardDestPos,
				rotation = dilemmaCardDestRot,
				callback_function = function(obj)
					obj.use_hands = false
					obj.setTags({ "Dilemma" })
					obj.setLock(false)
				end
			})
			if dilemmas.remainder ~= nil then
				dilemmas = dilemmas.remainder
			end
			return 0.3
		elseif dilemmas.type == "Card" then
			dilemmas.use_hands = false
			dilemmas.setTags({ "Dilemma" })
			dilemmas.setLock(false)
			dilemmas.setPositionSmooth(dilemmaCardDestPos)
			dilemmas.setRotationSmooth(dilemmaCardDestRot)
			return 0.3
		end
	end

	if dilemmas.type == "Deck" then
		for i = 1, #dilemmas.getObjects() do
			table.insert(seqFuncs, addNextDilemma)
		end
	else
		table.insert(seqFuncs, addNextDilemma)
	end

	table.insert(seqFuncs, function()
		return {
			U.setPositionSlow(coverCard, C.Spots.Main.CoverCard.Closed.position),
			U.setRotationSlow(coverCard, C.Spots.Main.CoverCard.Closed.rotation)
		}
	end)
	table.insert(seqFuncs, function()
		coverCard.setLock(false)
		return { coverCard, 0.1 }
	end)
	table.insert(seqFuncs, function()
		getDilemmaDeck().shuffle()
	end)

	return U.RunSequence(seqFuncs)
end

function DIR.InitConsequencesQuery(playerRef)
	local player = playerRef == nil and P.GetLeader() or S.getPlayer(playerRef)
	U.forEach({"Sticker", unpack(C.Resources)}, function(resource)
		U.forEach({"P", "N"}, function(outcome)
			local stateVal = S.getStateVal("roundState", "consequences", outcome, resource) or "O"
			U.forEach({"O", "P", "N"}, function(conType)
				if conType == "O" then
					UI.setAttribute("consequence_" .. outcome .. "_" .. conType .. "_" .. resource .. "_" .. player.color, "active", tostring(conType == stateVal))
				else
					UI.setAttribute("consequence_" .. outcome .. "_" .. conType .. "_" .. resource .. "_" .. player.color, "active", tostring(conType == stateVal))
					UI.setAttribute("conDisplay_" .. outcome .. "_" .. conType .. "_" .. resource, "active", tostring(conType == stateVal))
				end
			end)
		end)
	end)
	if S.isInPhase(C.Phases.PLAY.DrawDilemma) then
		UI.show("consequencesQuery_" .. player.color)
	end
	UI.show("consequencesSidebar")
	return 0.5
end
-- #endregion

-- #region Vote Turn Control~
function DIR.DisplayPassHUD(playerRef)
	local player = S.getPlayer(playerRef)
	return U.RunSequence({
		function()
			UI.setAttribute("turnHUD_" .. player.color, "active", "false")
			V.UpdateHUD(player, true)
			return 0.5
		end,
		function()
			UI.show("turnHUD_" .. player.color)
			return 0.5
		end
	})
end
function DIR.TurnHUDClick(action, color)
	U.RunSequence({
		function()
			UI.hide("turnHUD_" .. color)
			return V.EndTurn(action == "passMod") end,
		function()
			local activePlayers = U.filter(Player.getAvailableColors(), function(pColor)
				return pColor == S.getStateVal("roundState", "currentTurn") or U.isIn(S.getStateVal("turnState", pColor, "vote"), {false, "Aye", "Nay"})
			end)
			local playerIndex = U.findIndex(activePlayers, function(pColor) return pColor == S.getStateVal("roundState", "currentTurn") end)
			local nextPlayer
			if playerIndex == #activePlayers then
				nextPlayer = activePlayers[1]
			else
				nextPlayer = activePlayers[playerIndex + 1]
			end
			-- log({activePlayers = activePlayers, playerIndex = playerIndex, nextPlayer = nextPlayer})
			if P.GetLeader().color == nextPlayer or not U.isIn(S.getPlayerVoteStatus(nextPlayer), {false, "Aye", "Nay"}) then
				return DIR.ADVANCE()
				-- return 0
			end
			return U.RunSequence({
				function()
					DIR.DisplayPassHUD(nextPlayer)
					return V.StartTurn(nextPlayer)
				end
			})
		end
	})
end
-- #endregion


-- #region Momentum & Stability~
function DIR.UpdateTokenLight(resource)
	if resource == nil then return U.iMap(U.concat({"Stability"}, C.Resources), DIR.UpdateTokenLight) end
	if resource == "Stability" then
		return L.SetLightMode("lightStability", "on", nil, 0.5)
	end
	local momentum = getTokenMomentum(resource)
	local dir = momentum < 0 and "Down" or "Up"
	momentum = math.abs(momentum)
	return L.SetLightMode("light" .. resource, "momentum" .. dir .. momentum, nil, 0.5)
end

function DIR.GetStabilityBump()
	local stabilityPos = S.getStateVal("roundState", "boardTokens", "positions", "Stability")
	local curPositions = getTokenPositionsFromBoard()
	U.forEach(C.Resources, function(resource)
		local prevPos = S.getStateVal("roundState", "boardTokens", "positions", resource)
		local curPos = curPositions[resource]
		local deltaPos = curPos - prevPos
		stabilityPos = math.max(math.min(stabilityPos + deltaPos, 19), 1)
	end)
	local boardStabilityPos = curPositions.Stability
	return stabilityPos - boardStabilityPos
end
-- #endregion


-- #endregion

-- #region End of Game~
function DIR.EndGame()
	local stabilityPos = getTokenPositionsFromBoard().Stability

	if stabilityPos == 19 then
		S.setStateVal("AbdicatedTop", "gameState", "endState")
	elseif stabilityPos == 1 then
		S.setStateVal("AbdicatedBottom", "gameState", "endState")
	else
		S.setStateVal("Death", "gameState", "endState")
		return MSG.Splash("The King Is Dead!")
	end
	return MSG.Splash("The King has Abdicated the Throne")
end

function DIR.GetSecretAgenda(playerRef)
	local player = S.getPlayer(playerRef)
	local secretAgendaCard = getObjectsWithAllTags({player.color, "SecretAgenda"})
	U.Val("DIR.GetSecretAgenda", secretAgendaCard, #secretAgendaCard == 1, "Unable to find " .. player.color .. "'s Secret Agenda!")
	secretAgendaCard = secretAgendaCard[1]
	local secretAgendaTag = U.find(secretAgendaCard.getTags(), function(tag) return string.match(tag, "^SA_") end)
	U.Val("DIR.GetSecretAgenda", secretAgendaTag, U.Type(secretAgendaTag) == "string", "Unable to find " .. player.color .. "'s Secret Agenda type!")
	return string.gsub(secretAgendaTag, "^SA_", "")
end

function DIR.GetCoinStandings()
	local coinTotals = U.map(S.getPlayers(), function(player)
		return {
			color = player.color,
			total = OU.GetTotalValue(P.GetPlayerZone(player, "Coin"), "CoinToken")
		}
	end)
	table.sort(coinTotals, function(a, b) return a.total > b.total end)
	local placement, lastTotal = 1, coinTotals[1].total
	U.iForEach(coinTotals, function(cData)
		if cData.total < lastTotal then
			placement = placement + 1
		end
		cData.placement = placement
		lastTotal = cData.total
	end)

	local results = {}

	U.forEach(S.getPlayers(), function(player)
		results[player.color] = U.find(coinTotals, function(cData) return cData.color == player.color end)
	end)

	return results
end

function DIR.GetSecretAgendaScore(playerRef, tokenPositions, coinStandings)
	local player = S.getPlayer(playerRef)
	local secretAgendaData = C.SecretAgendaData[DIR.GetSecretAgenda(playerRef)]
	local scoreReport = {}
	if U.isIn("resPoints", secretAgendaData) then
		-- resFunc is a filter function that will return number of qualifying tokens
		local numTokens = #U.filter(U.getValues(tokenPositions), secretAgendaData.resFunc)
		scoreReport.resources = secretAgendaData.resPoints[numTokens + 1]
	else
		-- resFunc takes all data and returns final score
		scoreReport.resources = secretAgendaData.resFunc(nil, tokenPositions)
	end

	if coinStandings.placement <= 3 then
		scoreReport.coin = secretAgendaData.coinPoints[coinStandings.placement]
	else
		scoreReport.coin = 0
	end

	return scoreReport
end

function DIR.GetSecretAgendaScores()
	local results = {}
	local tokenPositions = getResourcePositionsFromBoard()
	local coinStandings = DIR.GetCoinStandings()
	U.forEach(S.getPlayers(), function(player)
		results[player.color] = DIR.GetSecretAgendaScore(player, tokenPositions, coinStandings[player.color])
	end)
	return results
end

function DIR.GetOpenAgendaScore(playerRef, tokenPositions)
	local posOpenAgendas = S.getPlayerVal(playerRef, "openAgendas", "positive") or {}
	local negOpenAgendas = S.getPlayerVal(playerRef, "openAgendas", "negative") or {}
	local scoreReport = {positive = {}, negative = {}}
	local resPositions = U.getValues(tokenPositions)
	table.sort(resPositions, function(a, b) return a.slot > b.slot end)
	-- log({tokenPositions = tokenPositions})
	local topResources, secondResources = {}, {}
	table.insert(topResources, U.shift(resPositions))
	while (#resPositions > 0 and resPositions[1].slot == topResources[1].slot) do
		table.insert(topResources, U.shift(resPositions))
	end
	if #resPositions > 0 then
		table.insert(secondResources, U.shift(resPositions))
		while (#resPositions > 0 and resPositions[1].slot == secondResources[1].slot) do
			table.insert(secondResources, U.shift(resPositions))
		end
	end

	resPositions = U.getValues(tokenPositions)

	table.sort(resPositions, function(a, b) return a.slot < b.slot end)
	local botResources, secBotResources = {}, {}
	table.insert(botResources, U.shift(resPositions))
	while (#resPositions > 0 and resPositions[1].slot == botResources[1].slot) do
		table.insert(botResources, U.shift(resPositions))
	end
	if #resPositions > 0 then
		table.insert(secBotResources, U.shift(resPositions))
		while (#resPositions > 0 and resPositions[1].slot == secBotResources[1].slot) do
			table.insert(secBotResources, U.shift(resPositions))
		end
	end

	-- log({topResources = topResources, secondResources = secondResources, botResources = botResources, secBotResources = secBotResources})


	U.iForEach(posOpenAgendas, function(res)
		if U.find(topResources, function(rData) return rData.resource == res end) then
			scoreReport.positive[res] = 3
		elseif U.find(secondResources, function(rData) return rData.resource == res end) then
			scoreReport.positive[res] = 1
		end
	end)

	U.iForEach(negOpenAgendas, function(res)
		if U.find(botResources, function(rData) return rData.resource == res end) then
			scoreReport.negative[res] = -3
		elseif U.find(secBotResources, function(rData) return rData.resource == res end) then
			scoreReport.negative[res] = -1
		end
	end)

	return scoreReport
end

function DIR.GetOpenAgendaScores()
	local results = {}
	local tokenPositions = U.map(getResourcePositionsFromBoard(), function(slot, res)
		return {resource = res, slot = slot}
	end)
	U.forEach(S.getPlayers(), function(player)
		results[player.color] = DIR.GetOpenAgendaScore(player, tokenPositions)
	end)
	return results
end

function DIR.GetPowerBonus()
	local powerTotals = U.map(S.getPlayers(), function(player)
		return {
			color = player.color,
			total = OU.GetTotalValue(P.GetPlayerZone(player, "Power"), "PowerToken")
		}
	end)
	table.sort(powerTotals, function(a, b) return a.total > b.total end)
	local placement, lastTotal = 1, powerTotals[1].total
	U.iForEach(powerTotals, function(pData)
		if pData.total < lastTotal then
			placement = placement + 1
		end
		pData.placement = placement
		lastTotal = pData.total
	end)

	local results = {}

	U.forEach(S.getPlayers(), function(player)
		results[player.color] = U.find(powerTotals, function(pData) return pData.color == player.color end)
		if results[player.color].placement == 1 then
			results[player.color].points = 2
		elseif results[player.color].placement == 2 then
			results[player.color].points = 1
		else
			results[player.color].points = 0
		end
	end)

	return results
end

function DIR.GetFinalScores()
	local results = {
		SecretAgenda = DIR.GetSecretAgendaScores(),
		OpenAgenda = DIR.GetOpenAgendaScores(),
		PowerBonus = DIR.GetPowerBonus()
	}
	local byPlayer = {}
	U.forEach(S.getPlayers(), function(player)
		byPlayer[player.color] = {
			color = player.color,
			secretAgenda = DIR.GetSecretAgenda(player),
			resources = results.SecretAgenda[player.color].resources,
			openAgendas = results.OpenAgenda[player.color],
			coin = results.SecretAgenda[player.color].coin,
			power = results.PowerBonus[player.color].points
		}
		byPlayer[player.color].total = byPlayer[player.color].resources
			+ byPlayer[player.color].coin
			+ byPlayer[player.color].power
			+ U.sumVals(U.getValues(byPlayer[player.color].openAgendas.positive))
			+ U.sumVals(U.getValues(byPlayer[player.color].openAgendas.negative))
	end)
	return byPlayer
end

function DIR.GetFinalStandings()
	local scoring = C.FinalScoring[S.getStateVal("gameState", "endState")]
	local scores = U.getValues(DIR.GetFinalScores())
	-- log({scores = scores})
	table.sort(scores, function(a, b) return a.total > b.total end)
	local lastPlace = scores[#scores].total
	for i = #scores, 1, -1 do
		if scores[i].total == lastPlace then
			scores[i].placement = "LAST"
			scores[i].prestige = scoring[5].prestige
			scores[i].crave = scoring[5].crave
			if scores[i].secretAgenda == "Rebel" and S.getStateVal("gameState", "endState") ~= "Death" then
				scores[i].crave = scores[i].crave + 1
			end
		else
			break
		end
	end

	if scores[1].placement ~= "LAST" then
		local placement = 1
		scores[1].placement = placement
		scores[1].prestige = scoring[placement].prestige
		scores[1].crave = scoring[placement].crave
		for i = 2, #scores do
			if scores[i].placement == "LAST" then
				break
			elseif scores[i].total == scores[i - 1].total then
				scores[i].placement = placement
			else
				placement = placement + 1
				scores[i].placement = placement
			end
			scores[i].prestige = scoring[placement].prestige
			scores[i].crave = scoring[placement].crave
			if scores[i].secretAgenda == "Rebel" and S.getStateVal("gameState", "endState") ~= "Death" then
				scores[i].crave = scores[i].crave + 1
			end
		end
	end
	return scores
end

-- function DIR.


local function getUpdatedChronicleCardState(cScriptState)
	local scriptState = JSON.decode(cScriptState)
	local playerKeys = { "1", "8", "15", "22", "29" }
	U.forEach(S.getPlayers(), function(player, i)
		local houseName = S.getPlayerVal(player, "houseName") or ""
		scriptState[playerKeys[i]] = houseName
	end)
	return JSON.encode(scriptState)
end

function DIR.PlaceChronicleCard(kingName)
	local sourceObj = O.SpawnSources.chronicleCard()
	local spawnData = sourceObj.getData()
	local cCard
	spawnData.Nickname = kingName
	spawnData.Description = os.date("%b ") .. os.date("*t").day .. " '" .. os.date("*t").year - 2000
	spawnData.Transform = OU.unfoldTransform(C.Spots.Main.ChronicleCard)
	spawnData.Tags = { "Lectern", "ChronicleCardActive" }
	spawnData.LuaScriptState = getUpdatedChronicleCardState(spawnData.LuaScriptState)
	spawnObjectData({
		data = spawnData,
		callback_function = function(obj) cCard = obj end
	})
	return function()
		-- log({ cCard = cCard })
		return cCard ~= nil
	end
end

function DIR.UpdateChronicleCardNames()
	local cCard = getObjectsWithTag("ChronicleCardActive")[1]
	if cCard == nil then return end
	local cData = cCard.getData()
	cCard.setCustomObject({ LuaScriptState = getUpdatedChronicleCardState(cData.LuaScriptState) })
	cCard.reload()
end

-- #endregion


return DIR