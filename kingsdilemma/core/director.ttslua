local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
local C = require("kingsdilemma.lib.constants")
local P = require("kingsdilemma.core.players")
local O = require("kingsdilemma.lib.objects")
local OU = require("kingsdilemma.objects.objUtilities")
local V = require("kingsdilemma.core.voting")
local L = require("kingsdilemma.core.lighting")
local MSG = require("kingsdilemma.core.messaging")
local HouseScreen = require("kingsdilemma.objs.p3screen")

local DIR = {}
local HOUSE_SELECTION, newPlayerColors = {}, {}

local ISDEBUGGING = false

-- #region Token Object Getters~
local function getBoardTokens()
	local tokens = {
		Stability = getObjectsWithTag("StabilityMarker")[1],
		resource = {}
	}
	local rTokens = getObjectsWithTag("ResourceMarker")
	table.sort(rTokens, function(a, b) return a.getPosition().x < b.getPosition().x end)
	tokens.resource.Influence = rTokens[1]
	tokens.resource.Wealth = rTokens[2]
	tokens.resource.Morale = rTokens[3]
	tokens.resource.Welfare = rTokens[4]
	tokens.resource.Knowledge = rTokens[5]
	return tokens
end

function DIR.GetTokenPositionsFromBoard()
	local board = O.UninteractableObjs.Board()
	local boardTokens = getBoardTokens()
	return {
		Stability = OU.FindNearestSnapPoint(boardTokens.Stability, board),
		Influence = OU.FindNearestSnapPoint(boardTokens.resource.Influence, board),
		Wealth = OU.FindNearestSnapPoint(boardTokens.resource.Wealth, board),
		Morale = OU.FindNearestSnapPoint(boardTokens.resource.Morale, board),
		Welfare = OU.FindNearestSnapPoint(boardTokens.resource.Welfare, board),
		Knowledge = OU.FindNearestSnapPoint(boardTokens.resource.Knowledge, board)
	}
end

local function getTokenMomentums()
	local boardTokens = getBoardTokens()
local function getTokenMomentum(resource)
	local startTurnData = S.getStateVal("roundState", "boardTokens")
	if startTurnData == nil or startTurnData.momentum == nil or startTurnData.momentum[resource] == nil then
			local token = boardTokens.resource[resource]
			-- U.Assert("getTokenMomentum", token, "Object")
		return U.isFlipped(token) and -1 or 1
	else
		return startTurnData.momentum[resource]
	end
end
	return {
		Influence = getTokenMomentum("Influence"),
		Wealth = getTokenMomentum("Wealth"),
		Morale = getTokenMomentum("Morale"),
		Welfare = getTokenMomentum("Welfare"),
		Knowledge = getTokenMomentum("Knowledge")
	}
end
-- #endregion

-- #region INITIALIZATION FUNCTIONS
local agendaDeck, agendaCard
local displayCard
local queryResponse

INITFUNCS = {
	NONE = function() return {
		function()
			S.setStateVal({}, "playerData")
			P.ClearSeats()

			S.UpdatedSeatedPlayerData()
			return MSG.Splash("Resetting Table")
		end
	} end,
	SESSIONINIT = {
		SeatPlayers = function() return {
			DIR.ADVANCE
		} end,
		HouseSelection = function() return {
			function()
				if #DIR.GetUnselectedPlayers() == 0 then return 0 end
				return U.RunSequence({
					function() return MSG.Splash("House Selection", nil, 2) end,
					function()
						HOUSE_SELECTION = {}
						DIR.InitHouseSelectionHUD()
						return function() return HOUSE_SELECTION.isComplete == true end
					end
				})
			end,
			function()
				newPlayerColors = {}
				U.forEach(HOUSE_SELECTION, function(houseName, color)
					if not color or not houseName then return end
					if not U.isIn(color, C.SeatColors) then return end
					local player = S.getPlayer(color)
					table.insert(newPlayerColors, color)
					S.setPlayerVal(houseName, player, "house")
					S.setPlayerVal(nil, player, "houseName")
				end)
				UI.setAttribute("houseSelectionHUD", "active", "false")
				MSG.Splash("Setting Up Play Spaces", nil, 5)
				return 0.5
			end,
			function()
				return U.map(S.getPlayers(), function(player)
					return HouseScreen.Spawn(
						player,
						S.getPlayerVal(player, "house"),
						U.isIn(player.color, newPlayerColors)
					)
				end)
			end,
			function() return 2 end,
			function()
				L.LoadLights({"lightBehind"}, "ambient", 1.5)
				return 0.75
			end,
			function()
				P.ActivatePlayerScreenHUD()
				return L.LoadLights({ "lightFront" }, "ambient")
			end,
			function()
				UI.show("refHUDControls")
				return U.AlertGM("All Done!")
			end
		} end
	},
	CHRONSETUP = function()
		return {
			function()
				U.Assert("INITFUNCS.CHRONSETUP", S.getStateVal("gameState", "gameCount") == 0)
				queryResponse = {Prologue = "D1", ["Main Story"] = "0"}
				return MSG.SplashQuery(
					"How do you want to start your\nChronicle of The King's Dilemma?",
					"Host",
					queryResponse,
					U.getHost()
				)
			end,
			function()
				MSG.Splash(P.GetLeaderName() .. " Is Most Prestigious")
				return L.SetLightMode("lightLeader", "on", nil, 0.5)
			end,
			P.AssignLeader,
			function()
				MSG.Splash(P.GetModeratorName() .. " Is Least Prestigious")
				return L.SetLightMode("lightModerator", "on", nil, 0.5)
			end,
			P.AssignModerator,
			function() return P.SetCamera("Lectern") end,
			function()
				L.LoadLights({ "lightLectern" }, "default")
				return MSG.Splash("Chronicle Setup")
			end,
			function()
				S.setStateVal(queryResponse.response, "gameState", "chronicleType")
				S.setStateVal(({
					["D1"] = "Harald IV",
					["0"] = "Harald V"
				})[queryResponse.response], "gameState", "kingName")
				return DIR.FetchEnvelope(queryResponse.response)
			end
		}
	end,
	GAMESETUP = {
		InitializeState = function() return {
			function()
				S.setStateVal(nil, "gameState", "endState")
				S.setStateVal(nil, "gameState", "endTime")
				S.setStateVal(nil, "gameState", "gameDuration")
				S.LogGameStartTime()
				S.setStateVal(S.getStateVal("gameState", "gameCount") + 1, "gameState", "gameCount")
				S.resetRoundState()
				return 0
			end,
			DIR.ADVANCE
		} end,
		MainBoard = function() return {
			function()
				P.SetCamera("MainBoard")
				DIR.AddToDilemmaDeck()
				return MSG.Splash("Board Setup")
			end,
			DIR.SpawnBoardTokens,
			function()
				V.ElevateBalance()
				return L.SetLightMode("lightBalance", "bright", nil, 0.5)
			end,
			function()
				DIR.InitCountZones()
				V.SpawnBalanceTokens(3)
				L.SetLightMode("lightBalance", "on", nil, 3)
				return 1.5
			end,
			function() return P.SetCamera("BehindScreen") end,
			function()
				MSG.Splash("Distributing Power & Coin")
				return {
					DIR.SpawnStartingPlayerPower(),
					DIR.SpawnStartingPlayerCoins()
				}
			end,
			DIR.ADVANCE
		} end,
		LeaderModerator = function()
			if S.getStateVal("gameState", "leader") ~= nil then
				return {DIR.ADVANCE}
			else
				return {
					function()
						MSG.Splash(P.GetLeaderName() .. " Is Most Prestigious")
						return L.SetLightMode("lightLeader", "on", nil, 0.5)
					end,
					P.AssignLeader,
					function()
						MSG.Splash(P.GetModeratorName() .. " Is Least Prestigious")
						return L.SetLightMode("lightModerator", "on", nil, 0.5)
					end,
					P.AssignModerator,
					DIR.ADVANCE
				}
			end
		end,
		LegacySetup = function() return {
			function()
				P.SetCamera("MainBoard")
				return MSG.Splash("Legacy Effects")
			end,
			function()
				P.SetCamera("Stickers")
				return MSG.Splash("Open Agendas")
			end,
			DIR.ADVANCE
		} end,
		SecretAgendas = function()
			return {
				function()
					agendaDeck = getObjectsWithTag("SecretAgenda")[1]
					U.Val("SecretAgendas", agendaDeck, U.isGameObject(agendaDeck) and agendaDeck.type == "Deck")
					P.SetCamera("Lectern")
					return MSG.Splash("Secret Agendas")
				end,
				function()
					agendaDeck.setLock(true)
					L.SetLightMode("lightLectern", "spotlightDilemmaDeck", nil, 1)
					return {
						U.setPositionSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.High.position), 1),
						U.setRotationSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.High.rotation), 1)
					}
				end,
				function()
					U.setPositionSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.Low.position), 0.5)
					U.setRotationSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.Low.rotation), 0.5)
					return 0.25
				end,
				function()
					agendaDeck.shuffle()
					return 0.5
				end,
				function()
					local isSpawned = false
					agendaCard = agendaDeck.takeObject({
						position = Vector({ -0.01, 6.95, 24.41 }),
						rotation = Vector({ 0, 0, 180 }),
						callback_function = function(obj)
							obj.setLock(true)
							isSpawned = true
						end
					})
					return function() return isSpawned == true end
				end,
				function()
					return {
						U.setRotationSlow(agendaCard, Vector(C.Spots.Staging.SecretAgenda.Burnt.rotation), 2),
						U.setPositionSlow(agendaCard, Vector(C.Spots.Staging.SecretAgenda.Burnt.position), 2, "speedUp")
					}
				end,
				function()
					P.SetCamera("BehindScreen")
					return P.DealAll(agendaDeck, P.GetLeastPrestigious())
				end,
				function()
					L.SetLightMode("lightLectern", "off")
					L.SetLightMode("lightPlayerSpotlight", "player" .. S.getPlayerNum(P.GetLeastPrestigious()))
					L.SetLightMode("lightFront", "dim")
					return MSG.Splash("Choose Your Secret Agenda", P.GetLeastPrestigious())
				end
			}
		end,
		PrepareFirstRound = function()
			return {
				function()
					S.setStateVal(0, "roundState", "roundNum")
					S.setStateVal(getTokenMomentums(), "roundState", "boardTokens", "momentum")
					return DIR.ADVANCE()
				end
			}
		end
	},
	PLAY = {
		StartRound = function() return {
				function()
					S.setStateVal(S.getStateVal("roundState", "roundNum") + 1, "roundState", "roundNum")
					S.setStateVal(DIR.GetTokenPositionsFromBoard(), "roundState", "boardTokens", "positions")
					S.setStateVal(P.GetLeader().color, "roundState", "currentTurn")
					S.setStateVal(false, "roundState", "passModClaimed")
					S.setStateVal(0, "roundState", "ayeTotal")
					S.setStateVal(0, "roundState", "nayTotal")
					U.forEach(S.getPlayers(), function(player)
						S.setPlayerTurnVal(false, player, "vote")
						S.setPlayerTurnVal(0, player, "powerCommitted")
					end)
					return DIR.ADVANCE()
				end
			}
		end,
		DrawDilemma = function() return {
				function()
					S.setStateVal({}, "roundState", "consequences")
					return {
						P.SetCamera("DilemmaDraw"),
						MSG.Splash("The Dilemma")
					}
				end,
				function()
					L.SetLightMode("lightLectern", "spotlightDilemmaDeck")
					return DIR.DrawDilemmaCard()
				end,
				function()
					displayCard = getObjectsWithTag("OnDisplay")[1]
					if displayCard.hasTag("Dilemma") then
					DIR.InitConsequencesQuery()
					end
					L.SetLightMode("lightLectern", "off", nil, 0.5)
					L.SetLightMode("lightDilemmaMain", "on", nil, 2)
					L.SetLightMode("lightDilemmaRef", "on")
					DIR.SpawnReferenceDilemmas(displayCard)
					return {
						U.setPositionSlow(displayCard, C.Spots.Main.Dilemma.faceDown.position, 2, "speedUp"),
						U.setRotationSlow(displayCard, C.Spots.Main.Dilemma.faceDown.rotation, 2, "speedUp"),
						U.setScaleSlow(displayCard, C.Spots.Main.Dilemma.faceDown.scale, 2, "speedUp")
					}
				end,
				function()
					if displayCard.hasTag("TriggerCard") then
						U.RunSequence({
							function()
								return MSG.SplashQuery(
									"Reveal Trigger Card Back?",
									P.GetLeaderName(),
									queryResponse,
									P.GetLeader()
								)
							end,
							function()
									return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.DisplayOutcome)
							end
						})
					else
					MSG.Splash(P.GetLeaderName() .. ", the Dilemma Card is Yours", P.GetLeader())
					return {
						L.SetLightMode("lightDilemmaAye", "on", nil, 1),
						L.SetLightMode("lightDilemmaNay", "on", nil, 1)
					}
				end
				end
			}
		end,
		Vote = function()
			local queryResponse = {Yes = "true", No = "false"}
			return {
				function()
					U.forEach(S.getPlayers(), function(player)
						if string.lower(UI.getAttribute("consequencesQuery_" .. player.color, "active")) == "true" then
							UI.hide("consequencesQuery_" .. player.color)
						end
					end)
					P.SetCamera("BehindScreen")
					return MSG.SplashQuery(
						"Is a vote required this round?",
						P.GetLeaderName(),
						queryResponse,
						P.GetLeader()
					)
				end,
				function()
					if queryResponse.response == "true" then
						return U.RunSequence({
							function()
								MSG.Splash("The Vote")
								V.InitCountZones()
								return V.SetVotingLights()
							end,
							function()
								DIR.DisplayPassHUD(P.GetLeader())
								return V.StartTurn(P.GetLeader())
							end
						})
					else
						return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.EndRound)
					end
				end
			}
		end,
		VoteResolution = function()
			return {
				function()
					UI.hide("consequencesSidebar")
					U.forEach(getObjectsWithTag("RefDilemma"), function(obj) obj.destruct() end)
					L.SetLightMode("lightDilemmaRef", "off")
					return {
						L.SetLightMode({"lightBehind"}, "ambient"),
						L.SetLightMode({"lightFront"}, "dim"),
						L.SetLightMode({"lightPlayerSpotlight"}, "off")
					}
				end,
				function()
					local nayTotal = S.getStateVal("roundState", "nayTotal")
					local ayeTotal = S.getStateVal("roundState", "ayeTotal")
					if ayeTotal == nayTotal then
						local query = {Aye = "Aye", Nay = "Nay"}
						return U.RunSequence({
							function()
								return L.SetLightMode({"lightPlayerSpotlight"}, "player" .. S.getPlayerNum(P.GetModerator()), nil, 1)
							end,
							function()
								if ayeTotal == 0 then
									MSG.Splash("Leadership falls to the Moderator, " .. P.GetModeratorName() .. ".")
									P.AssignLeader(P.GetModerator())
									return MSG.SplashQuery(
										"Does the proposed resolution succeed?",
										P.GetModeratorName(),
										query,
										P.GetModerator()
									)
								else
									MSG.Splash({
										"Tie.",
										"The Moderator will cast the deciding vote."
									})
									return MSG.SplashQuery(
										"Cast the tie-breaking vote.",
										P.GetModeratorName(),
										query,
										P.GetModerator()
									)
								end
							end,
							function()
								L.SetLightMode({"lightPlayerSpotlight"}, "off")
								S.setStateVal(query.response, "roundState", "voteResult")
								return 0
							end
						})
					elseif ayeTotal > nayTotal then
						S.setStateVal("Aye", "roundState", "voteResult")
					else
						S.setStateVal("Nay", "roundState", "voteResult")
					end
					return 0
				end,
				function()
					if S.getStateVal("roundState", "voteResult") == "Aye" then
						return MSG.Splash("The Resolution is Approved", nil, nil, {color = U.GetHex(Color.Blue)})
					else
						return MSG.Splash("The Resolution is Rejected", nil, nil, {color = U.GetHex(Color.Red)})
					end
				end,
				function()
					if S.getPlayerVoteStatus(P.GetLeader()) ~= S.getStateVal("roundState", "voteResult") then
						local winningPlayers = U.filter(S.getPlayers(), function(player) return S.getPlayerVoteStatus(player) == S.getStateVal("roundState", "voteResult") end)
						if #winningPlayers == 0 then return 0 end
						table.sort(winningPlayers, function(playerA, playerB) return S.getPlayerPowerCommitted(playerA) > S.getPlayerPowerCommitted(playerB) end)
						if #winningPlayers > 1 and S.getPlayerPowerCommitted(winningPlayers[1]) == S.getPlayerPowerCommitted(winningPlayers[2]) then
							local tiedPlayers = U.filter(winningPlayers, function(player) return S.getPlayerPowerCommitted(player) == S.getPlayerPowerCommitted(winningPlayers[1]) end)
							local queryResponse = {}
							U.forEach(tiedPlayers, function(player) queryResponse[P.GetPlayerName(player)] = player end)
							return U.RunSequence({
								function()
									return MSG.SplashQuery(
										"Pass Leadership to which player?",
										P.GetModeratorName(),
										queryResponse,
										P.GetModerator()
									)
								end,
								function()
									if P.GetModeratorName() == P.GetPlayerName(queryResponse.response) then
										MSG.Splash(P.GetModeratorName() .. " retains Leadership.")
									else
										MSG.Splash(P.GetModeratorName() .. " assigns Leadership to " .. P.GetPlayerName(queryResponse.response) .. ".")
									end
									return P.AssignLeader(queryResponse.response)
								end
							})
						else
							return U.RunSequence({
								function()
									MSG.Splash(P.GetPlayerName(winningPlayers[1]) .. " claims Leadership.")
									return P.AssignLeader(winningPlayers[1])
								end
							})
						end
					else
						return 0
					end
				end,
				function()
					local passPlayers = U.filter(S.getPlayers(), function(player) return U.isIn(S.getPlayerVoteStatus(player), {"Pass", "PassMod"}) end)
					if #passPlayers > 0 then
						MSG.Splash("Granting Coin for Abstaining")
						return U.RunSequence(U.iMap(passPlayers, function(player) return function()
							P.SpawnCoins(player, 1)
							L.PulseLight("lightFront", player)
							return 0.5
						end end))
					end
					return 0
				end,
				function()
					local passPowerPlayers = U.filter(S.getPlayers(), function(player) return S.getPlayerVoteStatus(player) == "Pass" end)
					local balanceZone = getObjectsWithTag("zoneBalance")[1]
					local balancePower = OU.GetTotalValue(balanceZone, "PowerToken")
					if #passPowerPlayers > 0 then
						local powerPerPlayer = math.floor(balancePower / #passPowerPlayers)
						if powerPerPlayer > 0 then
							MSG.Splash("Gathering Power")
							OU.TransferValue(
								balanceZone,
								U.iMap(passPowerPlayers, function(player) return P.GetPlayerZone(player, "Power") end),
								powerPerPlayer,
								"PowerToken"
							)
							return U.RunSequence(U.iMap(passPowerPlayers, function(player) return function()
								L.PulseLight("lightFront", player)
								return 0.75
							end end))
						end
					end
					return 0
				end,
				function()
					local losingPlayers = U.filter(S.getPlayers(), function(player) return U.isIn(S.getPlayerVoteStatus(player), {"Aye", "Nay"}) and S.getPlayerVoteStatus(player) ~= S.getStateVal("roundState", "voteResult") end)
					if #losingPlayers > 0 then
						MSG.Splash("Returning Power to Losing Players")
						return U.RunSequence(U.iMap(losingPlayers, function(player) return function()
							OU.TransferValue(
								P.GetPlayerZone(player, "Public"),
								P.GetPlayerZone(player, "Power"),
								OU.GetTotalValue(P.GetPlayerZone(player, "Public"), "PowerToken"),
								"PowerToken"
							)
							Wait.time(function() V.LowerRiser(player) end, 2)
							L.PulseLight("lightFront", player)
							return 0.75
						end end))
					end
					return 0
				end,
				function()
					local winningPlayers = U.filter(S.getPlayers(), function(player) return S.getPlayerVoteStatus(player) == S.getStateVal("roundState", "voteResult") end)
					if #winningPlayers > 0 then
						MSG.Splash("Moving Committed Power to Balance")
						local balanceZone = getObjectsWithTag("zoneBalance")[1]
						return U.RunSequence(U.iMap(winningPlayers, function(player) return function()
							OU.TransferValue(
								P.GetPlayerZone(player, "Public"),
								balanceZone,
								OU.GetTotalValue(P.GetPlayerZone(player, "Public"), "PowerToken"),
								"PowerToken"
							)
							Wait.time(function() V.LowerRiser(player) end, 2)
							L.PulseLight("lightFront", player)
							return 0.75
						end end))
					end
					return 0
				end,
				function() return L.SetLightMode("lightVote", "off") end,
				DIR.ADVANCE
			}
		end,
		DisplayOutcome = function() return {
			function()
			V.InitCountZones()
				displayCard = getObjectsWithTag({ "OnDisplay" })
				if #displayCard > 1 then return U.AlertGM("Too Many 'OnDisplay' Cards!") end
				displayCard = displayCard[1]
				if displayCard == nil then return U.AlertGM("No Card Displayed!") end

					L.SetLightMode("lightDilemmaAye", "off", nil, 0.5)
					L.SetLightMode("lightDilemmaNay", "off", nil, 0.5)

				if S.getStateVal("roundState", "displayedCardType") == "dilemma" then
					U.Assert("Displayed Card is a Dilemma?", displayCard.hasTag("Dilemma"))

					local voteResult = S.getStateVal("roundState", "voteResult")
					if voteResult == nil then
						return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.EnvelopeCheck, false)
					end

					P.SetCamera("DilemmaResult")
					MSG.Splash("Rewards & Consequences")
					L.SetLightMode("lightDilemmaMain", voteResult or "off", nil, 2)

					if voteResult == "Nay" then
						displayCard.alt_view_angle = Vector(0, 180, 180)
					else
						displayCard.alt_view_angle = Vector(0, 0, 0)
					end

					return {
						U.setPositionSlow(displayCard, C.Spots.Main.Dilemma["faceUp" .. voteResult].position, 0.5),
						U.setRotationSlow(displayCard, C.Spots.Main.Dilemma["faceUp" .. voteResult].rotation, 0.5),
						displayCard
					}
				elseif S.getStateVal("roundState", "displayedCardType") == "trigger" then
					U.Assert("Displayed Card is a Trigger Card?", displayCard.hasTag("TriggerCard"))

					P.SetCamera("DilemmaDraw")
					L.SetLightMode("lightDilemmaMain", "on", nil, 2)

					MSG.Splash("Resolve Triggered Event")

					DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.ApplyMomentum, false)

					return {
						U.setPositionSlow(displayCard, C.Spots.Main.Trigger.faceUp.position, 0.5),
						U.setRotationSlow(displayCard, C.Spots.Main.Trigger.faceUp.rotation, 0.5),
						displayCard
					}
				end
			end
		} end,
		ApplyChanges = function()
			return {
				function()
					local voteResult = S.getStateVal("roundState", "voteResult")
					U.setPositionSlow(displayCard, C.Spots.Main.Dilemma["faceUp" .. voteResult .. "Resolve"].position, 2)
					U.setRotationSlow(displayCard, C.Spots.Main.Dilemma["faceUp" .. voteResult .. "Resolve"].rotation, 2)
					return MSG.Splash("Apply Changes to Resources") end
			}
		end,
		ApplyMomentum = function()

			local tokenPositionsFromState, tokenPositionsFromBoard
			local resourceTokens, resourceDeltas, resourceBumps
			local unboundPosAfterMomentum
			local stabilityBumps

			-- unboundPositionsAfterApplyingMomentum,

			-- local function getTokenPositionsFromState()
			-- 	return {
			-- 		Influence = S.getStateVal("roundState", "boardTokens", "positions", "Influence"),
			-- 		Wealth = S.getStateVal("roundState", "boardTokens", "positions", "Wealth"),
			-- 		Morale = S.getStateVal("roundState", "boardTokens", "positions", "Morale"),
			-- 		Welfare = S.getStateVal("roundState", "boardTokens", "positions", "Welfare"),
			-- 		Knowledge = S.getStateVal("roundState", "boardTokens", "positions", "Knowledge"),
			-- 	}
			-- end

			local function getTokenPositionDeltas(startPositions, endPositions)
				return {
					Influence = endPositions.Influence - startPositions.Influence,
					Wealth = endPositions.Wealth - startPositions.Wealth,
					Morale = endPositions.Morale - startPositions.Morale,
					Welfare = endPositions.Welfare - startPositions.Welfare,
					Knowledge = endPositions.Knowledge - startPositions.Knowledge
				}
			end

			-- local function getUnboundTokenPositionsAfterApplyingMomentum()
			-- 	local tokenMomentums = getTokenMomentums()
			-- 	local curTokenPositions = getTokenPositionsFromBoard()

			-- 	local positionDeltas = getTokenPositionDeltas(getTokenPositionsFromState(), curTokenPositions)
			-- 	local newTokenPositions = U.clone(curTokenPositions)

			-- 	U.iForEach(C.Resources, function(resource)
			-- 		if tokenMomentums[resource] * positionDeltas[resource] > 0 then
			-- 			-- moving in same direction: apply momentum
			-- 			newTokenPositions[resource] = newTokenPositions[resource] + tokenMomentums[resource]
			-- 		end
			-- 	end)

			-- 	return newTokenPositions
			-- end

			-- local resourceTokens = getBoardTokens().resource
			-- local resourceDeltas = getTokenPositionDeltas(getTokenPositionsFromState(), getTokenPositionsFromBoard())
			-- local resourceBumps = getTokenPositionDeltas(getTokenPositionsFromBoard(), getUnboundTokenPositionsAfterApplyingMomentum())
			-- local stabilityBumps = getTokenPositionDeltas(getTokenPositionsFromBoard(), getUnboundTokenPositionsAfterApplyingMomentum())
			return {
				function()
					tokenPositionsFromState = {
						Influence = S.getStateVal("roundState", "boardTokens", "positions", "Influence"),
						Wealth = S.getStateVal("roundState", "boardTokens", "positions", "Wealth"),
						Morale = S.getStateVal("roundState", "boardTokens", "positions", "Morale"),
						Welfare = S.getStateVal("roundState", "boardTokens", "positions", "Welfare"),
						Knowledge = S.getStateVal("roundState", "boardTokens", "positions", "Knowledge"),
					}
					tokenPositionsFromBoard = DIR.GetTokenPositionsFromBoard()
					unboundPosAfterMomentum = U.clone(tokenPositionsFromBoard)
					resourceDeltas = getTokenPositionDeltas(tokenPositionsFromState, tokenPositionsFromBoard)
					return MSG.Splash("Applying Momentum")
				end,
				function()
					local tokenMomentums = getTokenMomentums()

					U.iForEach(C.Resources, function(resource)
						if tokenMomentums[resource] * resourceDeltas[resource] > 0 then
							-- moving in same direction: apply momentum
							unboundPosAfterMomentum[resource] = unboundPosAfterMomentum[resource] + tokenMomentums[resource]
						end
					end)

					resourceTokens = getBoardTokens().resource
					resourceBumps = getTokenPositionDeltas(tokenPositionsFromBoard, unboundPosAfterMomentum)
					stabilityBumps = getTokenPositionDeltas(tokenPositionsFromBoard, unboundPosAfterMomentum)

					return U.RunSequence(U.iMap(C.Resources, function(resource)
						if resourceDeltas[resource] == 0 then return function() return 0 end end
						if resourceBumps[resource] == 0 then
							-- Token moved, but opposite direction to momentum: flip momentum
							return function()
								S.setStateVal(resourceDeltas[resource] > 0 and 1 or -1, "roundState", "boardTokens", "momentum", resource)
								return U.RunSequence({
									function()
										resourceTokens[resource].flip()
										DIR.UpdateTokenLight(resource, tokenMomentums[resource])
										return resourceTokens[resource]
									end
								})
							end
						else
							-- Token moved in same direction to momentum: bump by momentum, bump stability, set momentum to 2
							return function()
								return U.RunSequence({
									function()
										local tokenMomentum = resourceDeltas[resource] > 0 and 2 or -2
										S.setStateVal(tokenMomentum, "roundState", "boardTokens", "momentum", resource)
										return {
											DIR.BumpToken("Stability", stabilityBumps[resource]),
											DIR.BumpToken(resource, resourceBumps[resource]),
											DIR.UpdateTokenLight(resource, tokenMomentum),
											DIR.UpdateTokenLight("Stability")
										}
									end,
									-- function()
									-- 	S.setStateVal(resourceDeltas[resource] > 0 and 2 or -2, "roundState", "boardTokens", "momentum", resource)
									-- 	return {
									-- 		DIR.UpdateTokenLight(resource),
									-- 		DIR.UpdateTokenLight("Stability")
									-- 	}
									-- end
								})
							end
						end
					end))
				end,
				DIR.ADVANCE
			}
		end,
		StickerCheck = function() return {
			function()
				MSG.Splash("Checking for Chronicle Stickers")
				queryResponse = {Yes = "true", No = "false"}
				return MSG.SplashQuery(
					"Unlock a Chronicle Sticker?",
					P.GetLeaderName(),
					queryResponse,
					P.GetLeader()
				)
			end,
			function()
				if queryResponse.response == "true" then
					return DIR.PromptForSticker(P.GetLeader())
				end
				return DIR.ADVANCE()
			end
		} end,
		EnvelopeCheck = function() return {
			function()
				MSG.Splash("Checking for Chronicle Envelopes")
				queryResponse = {Yes = "true", No = "false"}
				return MSG.SplashQuery(
					"Unlock a Chronicle Envelope?",
					P.GetLeaderName(),
					queryResponse,
					P.GetLeader()
				)
			end,
			function()
				if queryResponse.response == "true" then
					return DIR.PromptForEnvelope(P.GetLeader())
				end
				return DIR.ADVANCE()
			end
		} end,
		EndRound = function()
			return {
				function()

					displayCard = getObjectsWithTag("OnDisplay")[1]
					if displayCard == nil then return U.AlertGM("No Card Displayed!") end

					L.SetLightMode("lightDilemmaMain", "off", nil, 2)
					L.SetLightMode("lightLectern", "ambient")

					displayCard.removeTag("OnDisplay")
					displayCard.addTag("Played")

					if S.getStateVal("roundState", "displayedCardType") == "dilemma" then
						U.Assert("Displayed Card is a Dilemma?", displayCard.hasTag("Dilemma"))
						DIR.AddToDilemmaDeck()

						local voteResult = S.getStateVal("roundState", "voteResult")
						local playedDilemmas = getObjectsWithAllTags({ "Dilemma", "Played" })
						local dilemmaTransform = C.Spots.Main.Dilemma["board" .. voteResult][#playedDilemmas]

						return U.RunSequence({
							function()
									displayCard.setLock(false)
								return {
										U.setPositionSlow(displayCard, Vector(dilemmaTransform.position):add(Vector(-3, 0, 0)), 2),
										U.setRotationSlow(displayCard, dilemmaTransform.rotation, 2),
										U.setScaleSlow(displayCard, dilemmaTransform.scale, 1),
										displayCard
								}
							end,
							function()
									displayCard.setLock(true)
									return U.setPositionSlow(displayCard, Vector(dilemmaTransform.position):setAt("y", C.TableHeight), 1)
							end,
							function()
								-- Check Abdication
								local stabilityToken = getObjectsWithTag("StabilityMarker")[1]
								local stabilityZPos = stabilityToken.getPosition().z
								if stabilityZPos > 9 or stabilityZPos < -15 then
									return DIR.EndGame("Abdication")
								end

								-- Check King Death
								local playedDilemmas = getObjectsWithAllTags({ "Dilemma", "Played" })
									if #playedDilemmas == 11 then
									return DIR.EndGame("Death")
								elseif #playedDilemmas > 6 then
									local queryResponse = {Yes = "true", No = "false"}
									return U.RunSequence({
										function()
											return MSG.SplashQuery(
												"Does the dilemma bear a skull icon?",
												P.GetLeaderName(),
												queryResponse,
												P.GetLeader()
											)
										end,
										function()
											if queryResponse.response == "true" then
												return DIR.EndGame("Death")
											end
												return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.StartRound)
										end
									})
								else
										return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.StartRound)
									end
								end
							})
					elseif S.getStateVal("roundState", "displayedCardType") == "trigger" then
						U.Assert("Displayed Card is a Trigger Card?", displayCard.hasTag("TriggerCard"))

						return U.RunSequence({
							function()
								displayCard.setLock(false)
								return {
									U.setPositionSlow(displayCard, C.Spots.Main.Trigger.aboveDeck.position, 1),
									U.setRotationSlow(displayCard, C.Spots.Main.Trigger.aboveDeck.rotation, 1),
									U.setScaleSlow(displayCard, C.Spots.Main.Trigger.aboveDeck.scale, 1),
									displayCard
								}
							end,
							DIR.AddToDilemmaDeck,
							function()
								return DIR.JumpToStatePhase(C.Modes.PLAY, C.Phases.PLAY.StartRound)
						end
					})
					end
				end
			}
		end
	},
	END = {
		Score = function()
			local scoreData, tokenData
			return {
				function()
					tokenData = DIR.GetTokenPositionsFromBoard()
					local stabilityPos = tokenData.Stability
					local kingName = S.getStateVal("gameState", "kingName")

					if stabilityPos == 19 then
						S.setStateVal("AbdicatedTop", "gameState", "endState")
						return MSG.Splash("A Treasonous Plot Forces King " .. kingName .. " to Abdicate!", "AllMid", 3, {offsetXY = "0 -200"})
					elseif stabilityPos == 1 then
						S.setStateVal("AbdicatedBottom", "gameState", "endState")
						return MSG.Splash("Popular Unrest Forces the King " .. kingName .. " to Abdicate!", "AllMid", 3, {offsetXY = "0 -200"})
					else
						S.setStateVal("Death", "gameState", "endState")
						return MSG.Splash("King " .. kingName .. "  Is Dead!", "AllMid", 3, {offsetXY = "0 -200"})
					end

				end,
				function()
					scoreData = DIR.GetFinalStandings()
					S.RecordFinishedGame(scoreData, tokenData)
					UI.show("scoringSplashScreen")
					return 5
				end,
				function()
					DIR.InitScoringHUD(scoreData)
				end
			}
		end,
		Realm = function()
			return {
				function()
					UI.hide("scoringHUD")
					return 4
				end,
				function()
					UI.setAttributes("scoringHUD", {
						active = "false",
						scale = "0.4 0.4 0.4",
						color = "Clear",
						offsetXY = "300 450"
					})
					UI.show("scoringHUD")
					return 1
				end,
				function()
					MSG.Splash("Record Earned Prestige & Crave on Your House Card", nil, 5)
					local query = {Yes = "true"}
					return MSG.SplashQuery(
						"Proceed to Achievements?",
						"Host",
						query,
						U.getHost()
					)
				end,
				DIR.ADVANCE
			}
		end,
		Achievements = function()
			return {
				function()
					local query = {Yes = "true"}
					MSG.Splash("Tick Boxes for Any Earned Achievements", nil, 5)
					return MSG.SplashQuery(
						"Proceed to Alignment?",
						"Host",
						query,
						U.getHost()
					)
				end,
				DIR.ADVANCE
			}
		end,
		Alignments = function()
			return {
				function()
					local query = {Yes = "true"}
					MSG.Splash("Tick the Box for the Secret Agenda You Played", nil, 5)
					return MSG.SplashQuery(
						"Proceed to Cleanup?",
						"Host",
						query,
						U.getHost()
					)
				end,
				DIR.ADVANCE
			}
		end,
		Cleanup = function() return {
			S.LogGameEndTime,
			function()
				local tokenData = DIR.GetTokenPositionsFromBoard()
				local scoreData = DIR.GetFinalStandings()
				S.RecordFinishedGame(scoreData, tokenData)
				return 1
			end,
			function()
				local playedDilemmaCards = getObjectsWithAllTags({"Dilemma", "Played"})
				local numPlayedDilemmas = #playedDilemmaCards
				table.sort(playedDilemmaCards, function(a, b) return a.getPosition().z < b.getPosition().z end)
				local tempStagingPos = Vector(C.Spots.Main.CoverCard.Closed.position):add(Vector(-10, -3, 0))

				return {
					U.sequence(U.iMap(playedDilemmaCards, function(card, i) return function()
						DIR.SpawnDilemmaForCapture(card, numPlayedDilemmas + 1 - i)
						tempStagingPos:add(Vector(0, 0.2, 0))
						if Vector(card.alt_view_angle).y > 90 then
							card.setDescription("Vote: NAY")
						else
							card.setDescription("Vote: AYE")
						end
						card.setPosition(tempStagingPos)
						card.setRotation(Vector(0, 180, 180))
						card.setTags({"DilemmaOld"})
						card.setLock(false)
					end end), 0.15),
					function() return #getObjectsWithTag("DilemmaOld") == 1 end
					-- unpack(playedDilemmaCards)
				}
			end,
			function()
				local oldDilemmaDeck = getObjectsWithTag("DilemmaOld")[1]
				oldDilemmaDeck.setName("Game " .. S.getStateVal("gameState", "gameCount") .. " Dilemmas")
				O.MainStorage().putObject(oldDilemmaDeck)
				local tokens = getBoardTokens()
				tokens.Stability.destruct()
				U.forEach(tokens.resource, function(token) token.destruct() end)
				U.forEach(U.filter(getObjects(), function(obj)
					return U.hasAnyTag(obj, {"PowerToken", "CoinToken", "ResourceMarker", "StabilityMarker"}) and not obj.hasTag("SourceObj")
				end), function(token) token.destruct() end)
				U.forEach({"Stability", unpack(C.Resources)}, function(lightRef) L.SetLightMode("light" .. lightRef, "off", nil, 0.5) end)
				V.LowerBalance()
				U.setPositionSlow(O.Leader.Figure(), C.Spots.Storage.LeaderFigure.position, 1)
				U.setRotationSlow(O.Leader.Figure(), C.Spots.Storage.LeaderFigure.rotation, 1)
				U.setPositionSlow(O.Moderator.Figure(), C.Spots.Storage.ModeratorFigure.position, 1)
				U.setRotationSlow(O.Moderator.Figure(), C.Spots.Storage.ModeratorFigure.rotation, 1)
				U.setPositionSlow(O.Leader.Light(), C.Spots.Storage.LeaderLight.position, 1)
				U.setRotationSlow(O.Leader.Light(), C.Spots.Storage.LeaderLight.rotation, 1)
				U.setPositionSlow(O.Moderator.Light(), C.Spots.Storage.ModeratorLight.position, 1)
				U.setRotationSlow(O.Moderator.Light(), C.Spots.Storage.ModeratorLight.rotation, 1)
				L.SetLightMode({"lightLeader", "lightModerator"}, "off", nil, 1)
				S.setStateVal(nil, "gameState", "leader")
				S.setStateVal(nil, "gameState", "moderator")
			end,
			function()
				local secretAgendas = getObjectsWithTag("SecretAgenda")
				U.Assert("Six secret agendas found?", #secretAgendas == 6)
				local stagingPos = Vector(C.Spots.Storage.SecretAgenda.position)
				return U.sequence(U.map(secretAgendas, function(sA)
					return function()
						local sATag = U.findTag(sA, {"SA_Opportunist", "SA_Opulent", "SA_Rebel", "SA_Extremist", "SA_Moderate", "SA_Greedy"})
						sA.setTags({"SecretAgenda", sATag})
						stagingPos:add(Vector(0, 0.2, 0))
						sA.setPositionSmooth(stagingPos)
						sA.setRotationSmooth(C.Spots.Storage.SecretAgenda.rotation)
						sA.setInvisibleTo()
						sA.setLock(false)
						sA.use_hands = true
					end
				end))
			end
		} end,
		NextKing = function() return {
			DIR.PromptForKingName
		} end,
		SecretAgendas = function() return {
			function()
				-- NOTE: Need to RECORD this stuff in state, so they can be dealt out during next game's first SA phase
				-- because want to be able to clear board fully, including any Secret AGendas you might staple onto their screens
				local secretAgendas = getObjectsWithAllTags("SecretAgenda")
				U.Assert("END.SecretAgendas: 6 Secret Agendas found?", #secretAgendas == 6)
				U.iForEach(secretAgendas, function(sAg, i) U.RunSequence({
					function()
						sAg.use_hands = true
						sAg.setInvisibleTo({})
						sAg.setTags({"SecretAgenda", U.findTag(sAg, U.map(C.SecretAgendas, function(sa) return "SA_" .. sa end))})
						return {
							U.setPositionSlow(sAg, Vector(C.Spots.Storage.SecretAgenda.position):setAt("y", 5 + i * 0.5)),
							U.setRotationSlow(sAg, C.Spots.Storage.SecretAgenda.rotation)
						}
					end,
					function()
						sAg.setLock(false)
					end
				}) end)
				return function() return #getObjectsWithTag("SecretAgenda") == 1 end
			end,
			function()
				agendaDeck = getObjectsWithTag("SecretAgenda")[1]
				U.Val("SecretAgendas", agendaDeck, U.isGameObject(agendaDeck) and agendaDeck.type == "Deck")
				P.SetCamera("Lectern")
				return MSG.Splash("Secret Agendas")
			end,
			function()
				agendaDeck.setLock(true)
				L.SetLightMode("lightLectern", "spotlightDilemmaDeck", nil, 1)
			return {
					U.setPositionSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.High.position), 1),
					U.setRotationSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.High.rotation), 1)
				}
			end,
			function()
				U.setPositionSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.Low.position), 0.5)
				U.setRotationSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.Low.rotation), 0.5)
				return 0.25
			end,
				function()
				agendaDeck.shuffle()
				return 0.5
			end,
				function()
				local isSpawned = false
				agendaCard = agendaDeck.takeObject({
					position = Vector({ -0.01, 6.95, 24.41 }),
					rotation = Vector({ 0, 0, 180 }),
					callback_function = function(obj)
						obj.setLock(true)
						isSpawned = true
				end
				})
				return function() return isSpawned == true end
			end,
			function()
				return {
					U.setRotationSlow(agendaCard, Vector(C.Spots.Staging.SecretAgenda.Burnt.rotation), 2),
					U.setPositionSlow(agendaCard, Vector(C.Spots.Staging.SecretAgenda.Burnt.position), 2, "speedUp")
			}
			end,
			function()
				P.SetCamera("BehindScreen")
				return P.DealAll(agendaDeck, P.GetLeastPrestigious())
			end,
			function()
				L.SetLightMode("lightLectern", "off")
				L.SetLightMode("lightPlayerSpotlight", "player" .. S.getPlayerNum(P.GetLeastPrestigious()))
				L.SetLightMode("lightFront", "dim")
				return MSG.Splash("Choose Your Secret Agenda", P.GetLeastPrestigious())
			end
		} end,
		SignOff = function() return {
				-- clear player screens and all their stuff
				-- reset state for next game
				-- move to NONE
		} end
	}
}
-- #endregion

-- #region Session Setup & Phase Control~
function DIR.InitPreflight()
	UI.hide("sessionPreflightDisplay")
	UI.show("sessionInitDisplay")

	Global.call("UpdatePhaseDisplay")
	U.forEach(getObjectsWithTag("Private"), function(obj)
		local color = U.findColorTag(obj)
		if color then
			obj.setInvisibleTo(S.getOtherColors(color))
		end
	end)
	L.PrimeLights()
	U.forEach(O.UninteractableObjs, function(oFunc)
		oFunc().interactable = false
		oFunc().gizmo_selectable = false
	end)

	-- #region DEBUG
	Global.call("InitTestFuncButtons") -- Assign names to test function buttons
	if ISDEBUGGING then
		console.load()
	end
	-- #endregion

	UI.setValue("gameNumText", "~ the Reign of King " .. S.getStateVal("gameState", "kingName") .. " ~")

	-- if S.isInMode(C.Modes.NONE) then
	-- 	UI.setValue("gameNumText", "Game " .. S.getStateVal("gameState", "gameCount") + 1)
	-- else
	-- 	UI.setValue("gameNumText", "Game " .. S.getStateVal("gameState", "gameCount"))
	-- end
end

function DIR.InitSession(isNotShuffling)
	UI.hide("sessionInitDisplay")
	UI.show("gameStatusDisplay")
	return U.RunSequence({
		function()
			UI.hide("splashScreen")
			MSG.Splash("Seating Players", nil, 3)
			return P.AssignPlayerColors(isNotShuffling)
		end,
		function()
			P.InitializeSeatHandZones()
			local players = S.getPlayers()
			return {
				function() return #U.filter(players, function(pl) return pl.getHandCount() == 0 end) == 0 end
			}
		end,
		function()
			DIR.InitCountZones()
			return P.SetCamera("BehindScreen")
		end,
		function()
			if S.isInMode(C.Modes.NONE) then
				return DIR.ADVANCE()
			end
			return DIR.JumpToStatePhase()
		end
	})
end

function DIR.InitCountZones()
	U.forEach(S.getPlayers(), function(player)
		-- Player Private Power
		local powerZone = P.GetPlayerZone(player, "Power")
		if powerZone then
			powerZone.call("SetCountTag", "PowerToken")
			powerZone.call("SetColor", Color.Yellow)
			powerZone.call("SetIcon", "powerIcon")
			powerZone.call("SetIconColor", Color(C.RootColors.Amber):setAt("a", 0.6))
			powerZone.call("Activate")
		end

		-- Player Private Coin
		local coinZone = P.GetPlayerZone(player, "Coin")
		if coinZone then
			coinZone.call("SetCountTag", "CoinToken")
			coinZone.call("SetColor", Color.Yellow)
			coinZone.call("SetIcon", "coinIcon")
			coinZone.call("SetIconColor", Color(C.RootColors.Amber):setAt("a", 0.6))
			coinZone.call("Activate")
		end

		V.InitCountZones(player)
	end)

	-- Balance Plinth
	local balanceZone = getObjectsWithTag("zoneBalance")[1]
	if balanceZone then
		balanceZone.call("SetCountTag", "PowerToken")
		balanceZone.call("SetColor", Color.Yellow)
		balanceZone.call("SetIcon", "powerIcon")
		balanceZone.call("SetIconColor", Color(C.RootColors.Amber):setAt("a", 0.6))
		balanceZone.call("Activate")
	end
end

function DIR.ADVANCE(waitFunc)
	local mode, phase = S.getNextPhase()
	local function startPhase()
		S.setStateVal(mode, "gameState", "gameMode")
		S.setStateVal(phase, "gameState", "gamePhase")
		DIR.InitializePhase()
	end

	if waitFunc then
		U.waitUntil(startPhase, waitFunc, false)
	else
		startPhase()
	end
end

function DIR.InitializePhase()
	Global.call("UpdatePhaseDisplay")
	local mode = S.getStateVal("gameState", "gameMode")
	local phase = S.getStateVal("gameState", "gamePhase")
	local seqFuncs = INITFUNCS[mode]
	if U.Type(seqFuncs) == "table" then
		seqFuncs = seqFuncs[phase]
	end
	if U.Type(seqFuncs) == "function" then
		seqFuncs = seqFuncs()
	end
	U.RunSequence(seqFuncs)
end

function DIR.JumpToStatePhase(mode, phase, isInitializing)
	if isInitializing == nil and (mode ~= nil or phase ~= nil) then
		isInitializing = true
	end
	if mode ~= nil then
		S.setStateVal(mode, "gameState", "gameMode")
		S.setStateVal(mode, "gameState", "gamePhase")
	end
	if phase ~= nil then
		S.setStateVal(phase, "gameState", "gamePhase")
	end

	if isInitializing == true then return DIR.InitializePhase() end
	if isInitializing == false then return 0 end

	if S.isInPhase({C.Phases.PLAY.DrawDilemma, C.Phases.PLAY.Discussion, C.Phases.PLAY.Vote}) then
		DIR.InitConsequencesQuery()
	end
	if S.isInMode({C.Modes.CHRONSETUP, C.Modes.GAMESETUP, C.Modes.PLAY, C.Modes.END}) then
		UI.show("refHUDControls")
	end

	-- ... further logic to resync game environment to whatever point in the game we're at.
	P.ActivatePlayerScreenHUD()
	return L.InitLights()
end
-- #endregion

-- #region House Selection ~

function DIR.GetUnselectedPlayers()
	return U.filter(S.getPlayers(), function(player)
		return not HOUSE_SELECTION[player.color] and not S.getPlayerVal(player, "house")
	end)
end

local function isHouseClaimed(houseName) return S.getPlayerOfHouse(houseName) ~= false end
local function getSelectingPlayer(houseName) return U.findIndex(HOUSE_SELECTION, function(hName) return houseName == hName end) end

function DIR.InitHouseSelectionHUD()

	if #DIR.GetUnselectedPlayers() == 0 then
		HOUSE_SELECTION.isComplete = true
		else
		U.forEach(C.Houses, function(houseName)
			if isHouseClaimed(houseName) then
				local claimColor = S.getPlayerOfHouse(houseName)
				if U.isIn(claimColor, Player.getAvailableColors()) then
					claimColor = Color[claimColor]
					UI.setAttribute("houseHUD_Dark_" .. houseName, "color", U.GetHex(Color(claimColor):lerp(Color(C.RootColors.PureBlack):setAt("a", 1), 0.5)))
					UI.setAttribute("houseHUD_Dark_" .. houseName, "active", "true")
				else
					claimColor = Color.Black
					UI.setAttribute("houseHUD_Dark_" .. houseName, "color", U.GetHex(Color(C.RootColors.PureBlack):setAt("a", 0.85)))
					UI.setAttribute("houseHUD_Dark_" .. houseName, "active", "true")
				end
				UI.setAttribute("houseHUD_BannerBW_" .. houseName, "color", U.GetHex(claimColor))
			end
		end)
		UI.show("houseSelectionHUD")
	end

end

function DIR.UnselectHouse(houseName)
	HOUSE_SELECTION[U.findIndex(HOUSE_SELECTION, function(hName) return houseName == hName end)] = nil
	UI.setAttribute("houseHUD_BannerBW_" .. houseName, "color", U.GetHex(Color.White))
	UI.setAttribute("houseHUD_Overlay_" .. houseName, "color", U.GetHex(Color.White))
	UI.setAttribute("houseHUD_Dark_" .. houseName, "active", "false")
	UI.setAttribute("houseHUD_Overlay_" .. houseName, "active", "false")
end

function DIR.SelectHouse(player, houseName)
	HOUSE_SELECTION[player.color] = houseName
	UI.setAttribute("houseHUD_BannerBW_" .. houseName, "color", U.GetHex(Color[player.color]))
	UI.setAttribute("houseHUD_Overlay_" .. houseName, "color", U.GetHex(Color[player.color]:setAt("a", 0.5)))
	UI.setAttribute("houseHUD_Dark_" .. houseName, "color", U.GetHex(Color[player.color]:setAt("a", 0.5)))
	UI.setAttribute("houseHUD_Dark_" .. houseName, "active", "true")
	UI.setAttribute("houseHUD_Overlay_" .. houseName, "active", "true")
	if #DIR.GetUnselectedPlayers() == 0 then
		Wait.time(function() HOUSE_SELECTION.isComplete = true end, 1.5)
		end
end

function DIR.HouseHUDClick(player, houseName)
	if isHouseClaimed(houseName) then return end
	if S.getPlayerHouse(player) then return end
	if not U.isIn(houseName, C.Houses) then return end
	local curSelection = getSelectingPlayer(houseName)
	if curSelection ~= nil and curSelection ~= player.color then return end
	local curHouse = HOUSE_SELECTION[player.color]
	if curHouse ~= nil then DIR.UnselectHouse(curHouse) end
	if curHouse ~= houseName then DIR.SelectHouse(player, houseName) end
end

function DIR.HouseHUDHoverOn(player, houseName)
	UI.setAttribute("houseHUD_Bright_" .. houseName .. "_" .. player.color, "active", "false")
	UI.setAttribute("houseHUD_Info_" .. houseName .. "_" .. player.color, "active", "false")
	UI.show("houseHUD_Bright_" .. houseName .. "_" .. player.color)
	UI.show("houseHUD_Info_" .. houseName .. "_" .. player.color)
end

function DIR.HouseHUDHoverOff(player, houseName)
	UI.setAttribute("houseHUD_Bright_" .. houseName .. "_" .. player.color, "active", "true")
	UI.setAttribute("houseHUD_Info_" .. houseName .. "_" .. player.color, "active", "true")
	UI.hide("houseHUD_Bright_" .. houseName .. "_" .. player.color)
	UI.hide("houseHUD_Info_" .. houseName .. "_" .. player.color)
end

-- #endregion

-- #region Game Setup~
function DIR.SpawnBoardTokens()
	local seqFuncs = {}

	table.insert(seqFuncs, function()
		Wait.time(function() L.SetLightMode("lightStability", "on") end, 1)
		return OU.SpawnFromSourceObj(O.SpawnSources.stabilityToken(), { "StabilityMarker" }, C.Spots.Board.StabilityToken.center, Vector(0, 1, 0))
	end)

	U.iForEach(C.Resources, function(resName)
		table.insert(seqFuncs, function()
			return U.RunSequence({
				function()
					return OU.SpawnFromSourceObj(
						O.SpawnSources[string.lower(resName) .. "Token"](),
						{ "ResourceMarker", resName },
						C.Spots.Board.ResourceTokens[resName].center,
						Vector(0, 1, 0)
					)
				end,
				function()
					local tk = getBoardTokens().resource[resName]
					tk.setRotation(Vector(0, 180, U.randBetween(0, 1, true) * 180))
					tk.addForce(Vector(-0.07, 30, 0), 3)
					tk.addTorque(Vector(0, 0, 1.9), 3)
					U.waitUntil(function() DIR.UpdateTokenLight(resName) end, {0.5, tk})
					return tk
				end
			})
		end)
	end)

	return U.RunSequence(seqFuncs, 1000, 1)
end

function DIR.EndSecretAgendas()
	L.SetLightMode("lightLectern", "ambient")
	L.SetLightMode("lightFront", "ambient")
	L.SetLightMode("lightPlayerSpotlight", "off")

	local heldAgendas = {}

	U.forEach(S.getPlayers(), function(player)
		heldAgendas = U.concat(heldAgendas, U.filter(player.getHandObjects(), function(obj) return obj.hasTag("SecretAgenda") end))
	end)

	U.forEach(heldAgendas, function(obj)
		obj.use_hands = false
		obj.setLock(true)
		obj.setPositionSmooth(C.Spots.Staging.SecretAgenda.Burnt.position)
		obj.setRotationSmooth(C.Spots.Staging.SecretAgenda.Burnt.rotation)
		Wait.time(function() obj.use_hands = true end, 0.5)
	end)
	U.AlertGM("Secret Agendas Dealt!")
end

function DIR.SpawnStartingPlayerPower()
	return U.RunSequence(U.map(S.getPlayers(), function(player)
		local numPower = 8 + (S.getPlayerVal(player, "startingPowerBonus") or 0)
		return function()
			L.PulseLight("lightFront", player)
			return { 1, P.SpawnPower(player, numPower) }
		end
	end))
end

function DIR.SpawnStartingPlayerCoins()
	return U.RunSequence(U.map(S.getPlayers(), function(player)
		local numCoins = 10 + (S.getPlayerVal(player, "startingCoinsBonus") or 0)
		return function() return { 1, P.SpawnCoins(player, numCoins) } end
	end))
end
-- #endregion

-- #region Game Round~

-- #region Player Prompting: Stickers, Envelopes, King Name~
function DIR.PromptForSticker(player)
	UI.setAttribute("stickerQuery_" .. player.color, "active", "false")
	UI.show("stickerQuery_" .. player.color)
	UI.setAttribute("stickerQuery_" .. player.color, "text", " ")
end

function DIR.ConfirmFetchSticker(player, stickerKey)
	U.forEach(S.getPlayers(), function(ply) UI.hide("stickerQuery_" .. ply.color) end)
	local query = {Yes = "true", No = "false"}
	return U.RunSequence({
		function()
			return MSG.SplashQuery(
				"Confirm Sticker Key '" .. stickerKey .. "'",
				P.GetPlayerName(player),
				query,
				player
			)
		end,
		function()
			if query.response == "true" then
				return DIR.FetchSticker(stickerKey)
			else
				return DIR.PromptForSticker(player)
			end
		end
	})
end

function DIR.PromptForEnvelope(player)
	UI.setAttribute("envelopeQuery_" .. player.color, "active", "false")
	UI.show("envelopeQuery_" .. player.color)
	UI.setAttribute("envelopeQuery_" .. player.color, "text", " ")
end

function DIR.ConfirmFetchEnvelope(player, envKey)
	U.forEach(S.getPlayers(), function(ply) UI.hide("envelopeQuery_" .. ply.color) end)
	local query = {Yes = "true", No = "false"}
	return U.RunSequence({
		function()
			return MSG.SplashQuery(
				"Confirm Envelope Key '" .. envKey .. "'",
				P.GetPlayerName(player),
				query,
				player
			)
		end,
		function()
			if query.response == "true" then
				return DIR.FetchEnvelope(envKey, false)
			else
				return DIR.PromptForEnvelope(player)
			end
		end
	})
end

function DIR.PromptForKingName()
	local otherPlayers = DIR.GetWinners()
	local player = U.shift(otherPlayers)
	U.forEach(otherPlayers, function(ply)
		MSG.Splash("Consult with " .. P.GetPlayerName(player) .. " on the Name of the Next King", ply, 4)
	end)

	UI.setAttribute("kingQuery_" .. player.color, "active", "false")
	UI.show("kingQuery_" .. player.color)
	UI.setAttribute("kingQuery_" .. player.color, "text", " ")
end

function DIR.ConfirmKingName(player, kingName)
	U.forEach(S.getPlayers(), function(ply) UI.hide("kingQuery_" .. ply.color) end)
	local query = {Yes = "true", No = "false"}
	return U.RunSequence({
		function()
			return MSG.SplashQuery(
				"Confirm Name 'King " .. kingName .. "'",
				P.GetPlayerName(player),
				query,
				player
			)
		end,
		function()
			if query.response == "true" then
				S.setStateVal(kingName, "gameState", "kingName")
				return MSG.Splash(S.getStateVal("gameState", "kingName") .. "Inherits the Throne")
			else
				return DIR.PromptForKingName(player)
			end
		end
	})
end
-- #endregion


-- #region Fetching: Stickers, Envelopes~
function DIR.FetchSticker(stickerKey)
	local stickerContainer = O.SecretContainers.Stickers()
	local stickerGUID = OU.FindContainedObjGUID(stickerContainer, function(objData)
		return string.lower(objData.name) == string.lower(stickerKey)
	end)

	if not stickerGUID then
		U.Alert("Sticker '" .. stickerKey .. "' Not Found! Check Case & Spelling", Color(1, 0, 0))
		return
	end

	local sticker
	local displayedDilemma = getObjectsWithAllTags({"Dilemma", "OnDisplay"})[1]

	return U.RunSequence({
		function()
			P.SetCamera("Lectern")
			if displayedDilemma ~= nil then
				local yRot = displayedDilemma.getRotation().y
				local outcome = yRot > 170 and "Nay" or "Aye"
				return {
					U.setPositionSlow(displayedDilemma, C.Spots.Main.Dilemma["faceUp" .. outcome .. "Shrink"].position, 0.5),
					U.setScaleSlow(displayedDilemma, C.Spots.Main.Dilemma["faceUp" .. outcome .. "Shrink"].scale, 0.5),
					L.SetLightMode("lightLectern", "spotlightSticker", nil, 0.25)
				}
			else
				return L.SetLightMode("lightLectern", "spotlightSticker", nil, 0.25)
			end
		end,
		function()
			U.setPositionSlow(stickerContainer, C.Spots.Staging.Lectern.Stickers.position)
			U.setRotationSlow(stickerContainer, C.Spots.Staging.Lectern.Stickers.rotation)
			return { stickerContainer, L.SetLightMode("lightLectern", "spotlightPlinth", nil, 0.1) }
		end,
		function()
			stickerContainer.takeObject({
				position = C.Spots.Staging.Lectern.Display.position,
				rotation = C.Spots.Staging.Lectern.Display.rotation,
				guid = stickerGUID,
				callback_function = function(obj)
					sticker = obj
					sticker.addTag("ChronicleSticker")
					sticker.setLock(true)
				end
			})
			return function() return sticker ~= nil end
		end,
		function()
			U.setPositionSlow(stickerContainer, C.Spots.Storage.Stickers.position)
			U.setRotationSlow(stickerContainer, C.Spots.Storage.Stickers.rotation)
			return 0.3
		end,
		function() return L.SetLightMode("lightLectern", "spotlightTransit", nil, 0.3) end,
		function()
			sticker.setPositionSmooth(Vector(C.Spots.Staging.Sticker.Display.position):add(Vector(0, 5, 0)))
			sticker.setRotationSmooth(Vector(C.Spots.Staging.Sticker.Display.rotation))
			return {
				sticker,
				L.SetLightMode("lightLectern", "spotlightDilemmaDeck")
			}
		end,
		function()
			sticker.setLock(false)
			return {
				sticker,
				1.5
			}
		end,
		function()
			P.SetCamera("Stickers")
			return function()
				return not Vector.equals(sticker.getPosition(),
					Vector(C.Spots.Staging.Sticker.Display.position), 1)
			end
		end,
		function() return L.SetLightMode({ "lightLectern" }, "ambient", nil, 0.5) end
	})
end

function DIR.FetchEnvelope(envKey)
	U.Assert("DIR.FetchEnvelope", envKey, "string")
	local envContainer = O.SecretContainers.Envelopes()
	U.Assert("DIR.FetchEnvelope", envContainer, "Object")

	local envGUID = OU.FindContainedObjGUID(envContainer, function(objData)
		return string.lower(objData.name) == string.lower(envKey)
	end)

	if not envGUID then return U.Alert("Envelope '" .. envKey .. "' Not Found! Check Case & Spelling", Color(1, 0, 0)) end

	local displayCard = getObjectsWithTag("OnDisplay")[1]

	local envDeck, storyCard

	return U.RunSequence({
		function()
				P.SetCamera("Lectern")
				if displayCard ~= nil then
					if displayCard.hasTag("Dilemma") then
						local yRot = displayCard.getRotation().y
					local outcome = yRot > 170 and "Nay" or "Aye"
					return {
							U.setPositionSlow(displayCard, C.Spots.Main.Dilemma["faceUp" .. outcome .. "Shrink"].position, 0.5),
							U.setScaleSlow(displayCard, C.Spots.Main.Dilemma["faceUp" .. outcome .. "Shrink"].scale, 0.5),
						L.SetLightMode("lightLectern", "spotlightEnvelope", nil, 0.25)
					}
					elseif displayCard.hasTag("Trigger") then
						return {
							U.setPositionSlow(displayCard, C.Spots.Main.Trigger.faceUpShrink.position, 0.5),
							U.setScaleSlow(displayCard, C.Spots.Main.Trigger.faceUpShrink.scale, 0.5),
							L.SetLightMode("lightLectern", "spotlightEnvelope", nil, 0.25)
						}
					end
				else
					return L.SetLightMode("lightLectern", "spotlightEnvelope", nil, 0.25)
				end
		end,
		function()
			U.setPositionSlow(envContainer, C.Spots.Staging.Lectern.Envelopes.position)
			U.setRotationSlow(envContainer, C.Spots.Staging.Lectern.Envelopes.rotation)
			return { envContainer, L.SetLightMode("lightLectern", "spotlightPlinth", nil, 0.1) }
		end,
		function()
			envContainer.takeObject({
				position = C.Spots.Staging.Lectern.Display.position,
				rotation = C.Spots.Staging.Lectern.Display.rotation,
				guid = envGUID,
				callback_function = function(obj)
					envDeck = obj
					envDeck.setLock(true)
				end
			})
			return function() return envDeck ~= nil end
		end,
		function()
			U.setPositionSlow(envContainer, C.Spots.Storage.Envelopes.position)
			U.setRotationSlow(envContainer, C.Spots.Storage.Envelopes.rotation)
			return 0.3
		end,
		function()
			envDeck.takeObject({
				position = C.Spots.Staging.Lectern.TopCard.position,
				rotation = C.Spots.Staging.Lectern.TopCard.rotation,
				-- smooth = false,
				callback_function = function(obj)
					storyCard = obj
					storyCard.setTags({ "StoryCard" })
					storyCard.setLock(true)
					storyCard.use_hands = false
					storyCard.use_snap_points = true
				end
			})
			return function() return storyCard ~= nil end
		end,
		function()
			return L.SetLightMode("lightLectern", "spotlightTransit", nil, 0.3)
		end,
		function()
			storyCard.setPositionSmooth(Vector(C.Spots.Staging.StoryCard.Display.position):add(Vector(0, 5, 0)))
			storyCard.setRotationSmooth(Vector(C.Spots.Staging.StoryCard.Display.rotation))
			return {
				storyCard,
				L.SetLightMode("lightLectern", "storyCard")
			}
		end,
		function()
			storyCard.setLock(false)
			return {
				storyCard,
				1.5
			}
		end,
		function()
			MSG.Splash(P.GetLeaderName() .. ", the Story Card is Yours", P.GetLeader())
			return P.SetCamera("Stickers")
		end,
		function()
			L.SetLightMode({ "lightMainTop", "lightMainBottom" }, "ambient", nil, 2)
			return function()
				return not Vector.equals(storyCard.getPosition(),
					Vector(C.Spots.Staging.StoryCard.Display.position), 1)
			end
		end,
		function()
			local coverCard = O.Pieces.CoverCard()
			coverCard.setLock(true)
			coverCard.setPositionSmooth(coverCard.getPosition():add(Vector(0, 1, 0)))
			U.setPositionSlow(envDeck, C.Spots.Main.Dilemma.aboveDeck.position)
			U.setRotationSlow(envDeck, C.Spots.Main.Dilemma.aboveDeck.rotation)
			envDeck.setLock(false)
			-- DIR.PromptLeaderToHandleEnvelope(envDeck)
			return L.SetLightMode({ "lightLectern" }, "ambient", nil, 0.5)
		end
	})
end
-- #endregion

-- #region Dilemma Cards & Consequences Query~
local function getDilemmaDeck()
	local coverCard = O.Pieces.CoverCard()
	return U.findBelowObject(coverCard, function(obj) return obj.type == "Card" or obj.type == "Deck" end)[1]
end

function DIR.DrawDilemmaCard()
	local coverCard = O.Pieces.CoverCard()
	local dilemmaSource = U.findBelowObject(coverCard, function(obj) return obj.type == "Card" or obj.type == "Deck" end)
	U.Val("DIR.DrawDilemmaCard", dilemmaSource, #dilemmaSource == 1)
	dilemmaSource = dilemmaSource[1]
	local drawnCard
	if dilemmaSource.type == "Deck" then
		dilemmaSource.takeObject({
			position = C.Spots.Staging.DilemmaDraw.position,
			rotation = C.Spots.Staging.DilemmaDraw.rotation,
			top = false,
			callback_function = function(obj)
				obj.use_hands = false
				obj.use_snap_points = true
				obj.addTag("OnDisplay")
				obj.setLock(true)
				if obj.hasTag("TriggerCard") then
					S.setStateVal("trigger", "roundState", "displayedCardType")
				else
					S.setStateVal("dilemma", "roundState", "displayedCardType")
				end
				drawnCard = obj
			end
		})
		return function() return drawnCard ~= nil end
	elseif dilemmaSource.type == "Card" then
		drawnCard = dilemmaSource
		drawnCard.use_hands = false
		drawnCard.use_snap_points = true
		drawnCard.setLock(true)
		drawnCard.addTag("OnDisplay")
		if drawnCard.hasTag("TriggerCard") then
			S.setStateVal("trigger", "roundState", "displayedCardType")
		else
			S.setStateVal("dilemma", "roundState", "displayedCardType")
		end
		return {
			U.setPositionSlow(drawnCard, C.Spots.Staging.DilemmaDraw.position),
			U.setRotationSlow(drawnCard, C.Spots.Staging.DilemmaDraw.rotation)
		}
	end
end

function DIR.SpawnReferenceDilemmas(dilemmaCard)
	U.forEach(S.getPlayers(), function(player)
		local angle = S.getPlayerAngle(player)
		local targetTransform = OU.RotateByAngle(C.Spots.Player.DilemmaSpot, angle)
		local tags = {"RefDilemma"}
		OU.SpawnFromSourceObj(dilemmaCard, tags, targetTransform, nil, nil, true)

	end)
end

function DIR.AddToDilemmaDeck(dilemmas)
	local coverCard = O.Pieces.CoverCard()
	U.Assert("DIR.AddToDilemmaDeck", coverCard, "Object")

	local seqFuncs = {}

	if dilemmas == nil then
		dilemmas = U.findAboveObject(coverCard, function(obj) return obj.type == "Deck" or obj.type == "Card" end, {box = true})
		U.Val("DIR.AddToDilemmaDeck", dilemmas, #dilemmas <= 1, "Multiple sources of dilemmas found above Cover Card. Consolidate them into a deck." )
		dilemmas = dilemmas[1]
		if dilemmas == nil then return 0 end
		table.insert(seqFuncs, function()
			return {
				U.setPositionSlow(dilemmas, dilemmas.getPosition():add(Vector(0, 4, 4))),
				U.setRotationSlow(dilemmas, coverCard.getRotation())
			}
		end)
	end

	U.Assert("DIR.AddToDilemmaDeck: Object Test", dilemmas, "Object")
	U.Assert("DIR.AddToDilemmaDeck: Deck or Card Test", U.isIn(dilemmas.type, { "Card", "Deck" }))

	coverCard.setLock(true)
	dilemmas.setLock(true)

	table.insert(seqFuncs, function()
		return {
			U.setPositionSlow(coverCard, coverCard.getPosition():add(Vector(0, 2, -3))),
			U.setRotationSlow(coverCard, coverCard.getRotation():add(Vector(0, 0, 70)))
		}
	end)

	local dilemmaCardDestPos = coverCard.getPosition():add(Vector(0, 4, 0))
	local dilemmaCardDestRot = coverCard.getRotation()

	local function addNextDilemma()
		dilemmaCardDestPos:add(Vector(0, 0.4, 0))
		if dilemmas.type == "Deck" then
			dilemmas.takeObject({
				position = dilemmaCardDestPos,
				rotation = dilemmaCardDestRot,
				callback_function = function(obj)
					obj.use_hands = false
					if obj.hasTag("TriggerCard") then
						obj.setTags({"TriggerCard"})
					else
					obj.setTags({ "Dilemma" })
					end
					obj.setLock(false)
				end
			})
			if dilemmas.remainder ~= nil then
				dilemmas = dilemmas.remainder
			end
			return 0.3
		elseif dilemmas.type == "Card" then
			U.RunSequence({
				function()
			dilemmas.use_hands = false
					if dilemmas.hasTag("TriggerCard") then
						dilemmas.setTags({"TriggerCard"})
					else
			dilemmas.setTags({ "Dilemma" })
					end
			dilemmas.setPositionSmooth(dilemmaCardDestPos)
			dilemmas.setRotationSmooth(dilemmaCardDestRot)
					return dilemmas
				end,
				function()
					dilemmas.setLock(false)
				end
			})
			return 0.3
		end
	end

	if dilemmas.type == "Deck" then
		for i = 1, #dilemmas.getObjects() do
			table.insert(seqFuncs, addNextDilemma)
		end
	else
		table.insert(seqFuncs, addNextDilemma)
	end

	table.insert(seqFuncs, function()
		return {
			U.setPositionSlow(coverCard, C.Spots.Main.CoverCard.Closed.position),
			U.setRotationSlow(coverCard, C.Spots.Main.CoverCard.Closed.rotation)
		}
	end)
	table.insert(seqFuncs, function()
		coverCard.setLock(false)
		return { coverCard, 0.1 }
	end)
	table.insert(seqFuncs, function()
		getDilemmaDeck().shuffle()
	end)

	return U.RunSequence(seqFuncs)
end

function DIR.InitConsequencesQuery(playerRef)
	local player = playerRef == nil and P.GetLeader() or S.getPlayer(playerRef)
	U.forEach({"Sticker", unpack(C.Resources)}, function(resource)
		U.forEach({"P", "N"}, function(outcome)
			local stateVal = S.getStateVal("roundState", "consequences", outcome, resource) or "O"
			U.forEach({"O", "P", "N"}, function(conType)
				if conType == "O" then
					UI.setAttribute("consequence_" .. outcome .. "_" .. conType .. "_" .. resource .. "_" .. player.color, "active", tostring(conType == stateVal))
				else
					UI.setAttribute("consequence_" .. outcome .. "_" .. conType .. "_" .. resource .. "_" .. player.color, "active", tostring(conType == stateVal))
					UI.setAttribute("conDisplay_" .. outcome .. "_" .. conType .. "_" .. resource, "active", tostring(conType == stateVal))
				end
			end)
		end)
	end)
	if S.isInPhase(C.Phases.PLAY.DrawDilemma) then
		UI.show("consequencesQuery_" .. player.color)
	end
	UI.show("consequencesSidebar")
	return 0.5
end
-- #endregion

-- #region Vote Turn Control~
function DIR.DisplayPassHUD(playerRef)
	local player = S.getPlayer(playerRef)
	return U.RunSequence({
		function()
			UI.setAttribute("turnHUD_" .. player.color, "active", "false")
			V.UpdateHUD(player, true)
			return 0.5
		end,
		function()
			UI.show("turnHUD_" .. player.color)
			return 0.5
		end
	})
end
function DIR.TurnHUDClick(action, color)
	U.RunSequence({
		function()
			UI.hide("turnHUD_" .. color)
			return V.EndTurn(action == "passMod") end,
		function()
			local activePlayers = U.filter(Player.getAvailableColors(), function(pColor)
				return pColor == S.getStateVal("roundState", "currentTurn") or U.isIn(S.getStateVal("turnState", pColor, "vote"), {false, "Aye", "Nay"})
			end)
			local playerIndex = U.findIndex(activePlayers, function(pColor) return pColor == S.getStateVal("roundState", "currentTurn") end)
			local nextPlayer
			if playerIndex == #activePlayers then
				nextPlayer = activePlayers[1]
			else
				nextPlayer = activePlayers[playerIndex + 1]
			end
			-- log({activePlayers = activePlayers, playerIndex = playerIndex, nextPlayer = nextPlayer})
			if P.GetLeader().color == nextPlayer or not U.isIn(S.getPlayerVoteStatus(nextPlayer), {false, "Aye", "Nay"}) then
				return DIR.ADVANCE()
				-- return 0
			end
			return U.RunSequence({
				function()
					DIR.DisplayPassHUD(nextPlayer)
					return V.StartTurn(nextPlayer)
				end
			})
		end
	})
end
-- #endregion

-- #region Momentum & Stability~
function DIR.UpdateTokenLight(resource, momentum)
	if resource == nil then return U.iMap(U.concat({"Stability"}, C.Resources), DIR.UpdateTokenLight) end
	if resource == "Stability" then
		return L.SetLightMode("lightStability", "on", nil, 0.5)
	end
	if momentum == nil then momentum = getTokenMomentums()[resource] end
	local dir = momentum < 0 and "Down" or "Up"
	momentum = math.abs(momentum)
	return L.SetLightMode("light" .. resource, "momentum" .. dir .. momentum, nil, 0.5)
end

function DIR.GetStabilityBump()
	local stabilityPos = S.getStateVal("roundState", "boardTokens", "positions", "Stability")
	local curPositions = DIR.GetTokenPositionsFromBoard()
	U.forEach(C.Resources, function(resource)
		local prevPos = S.getStateVal("roundState", "boardTokens", "positions", resource)
		local curPos = curPositions[resource]
		local deltaPos = curPos - prevPos
		stabilityPos = math.max(math.min(stabilityPos + deltaPos, 19), 1)
	end)
	local boardStabilityPos = curPositions.Stability
	return stabilityPos - boardStabilityPos
end

function DIR.BumpToken(tokenName, count)

	local boardTokens = getBoardTokens()

	local function bumpToken(token, unitForceVector, count, lightName)
		local forceVector = Vector(unitForceVector):scale(count > 0 and Vector(1, 1, 1) or Vector(1, 1, -1))
		local absCount = math.abs(count)
		if absCount <= 3 then
			if lightName then
				Wait.time(function() DIR.UpdateTokenLight(lightName) end, 0.6)
			end
			return token.addForce(Vector(forceVector):scale(Vector(1, 1, math.abs(count))), 3)
		else
			local seqFuncs = {}
			while absCount >= 3 do
				absCount = absCount - 3
				table.insert(seqFuncs, function() bumpToken(token, forceVector, 3, lightName) end)
			end
			while absCount >= 2 do
				absCount = absCount - 2
				table.insert(seqFuncs, function() bumpToken(token, forceVector, 2, lightName) end)
			end
			while absCount >= 1 do
				absCount = absCount - 1
				table.insert(seqFuncs, function() bumpToken(token, forceVector, 1, lightName) end)
			end
			return U.sequence(seqFuncs, 0.5)
		end
	end

	local tokenPos = DIR.GetTokenPositionsFromBoard()
	local min, max = 1, tokenName == "Stability" and 19 or 17
	if tokenName == "Stability" and (tokenPos.Stability == 19 or tokenPos.Stability == 1) then
		return 0
	end
	count = math.max(math.min(count, max - tokenPos[tokenName]), min - tokenPos[tokenName])

	return bumpToken(
		tokenName == "Stability" and boardTokens.Stability or boardTokens.resource[tokenName],
		Vector(0, 15, 3.5),
		count,
		tokenName
	)
end
-- #endregion

-- #endregion

-- #region End of Game~
function DIR.EndGame() return DIR.JumpToStatePhase(C.Modes.END, C.Phases.END.Score) end

function DIR.GetSecretAgenda(playerRef)
	local player = S.getPlayer(playerRef)
	local secretAgendaCard = getObjectsWithAllTags({player.color, "SecretAgenda"})
	U.Val("DIR.GetSecretAgenda", secretAgendaCard, #secretAgendaCard == 1, "Unable to find " .. player.color .. "'s Secret Agenda!")
	secretAgendaCard = secretAgendaCard[1]
	local secretAgendaTag = U.find(secretAgendaCard.getTags(), function(tag) return string.match(tag, "^SA_") end)
	U.Val("DIR.GetSecretAgenda", secretAgendaTag, U.Type(secretAgendaTag) == "string", "Unable to find " .. player.color .. "'s Secret Agenda type!")
	return string.gsub(secretAgendaTag, "^SA_", "")
end

function DIR.GetCoinStandings()
	local coinTotals = U.map(S.getPlayers(), function(player)
		return {
			color = player.color,
			total = OU.GetTotalValue(P.GetPlayerZone(player, "Coin"), "CoinToken"),
			placement = nil
		}
	end)
	table.sort(coinTotals, function(a, b) return a.total > b.total end)
	local placement, lastTotal = 1, coinTotals[1].total
	U.iForEach(coinTotals, function(cData)
		if cData.total < lastTotal then
			placement = placement + 1
		end
		cData.placement = placement
		lastTotal = cData.total
	end)

	local results = {}

	U.forEach(S.getPlayers(), function(player)
		results[player.color] = U.find(coinTotals, function(cData) return cData.color == player.color end)
	end)

	return results
end

function DIR.GetSecretAgendaScore(playerRef, tokenPositions, coinStandings)
	local player = S.getPlayer(playerRef)
	local secretAgendaData = C.SecretAgendaData[DIR.GetSecretAgenda(playerRef)]
	local scoreReport = {}
	if U.isIn("resPoints", secretAgendaData) then
		-- resFunc is a filter function that will return number of qualifying tokens
		local numTokens = #U.filter(U.getValues(tokenPositions), secretAgendaData.resFunc)
		scoreReport.resources = secretAgendaData.resPoints[numTokens + 1]
	else
		-- resFunc takes all data and returns final score
		scoreReport.resources = secretAgendaData.resFunc(nil, tokenPositions)
	end

	scoreReport.coinTotal = coinStandings.total
	scoreReport.coinPlacement = coinStandings.placement
	if coinStandings.placement <= 3 then
		scoreReport.coin = secretAgendaData.coinPoints[coinStandings.placement]
	else
		scoreReport.coin = 0
	end

	return scoreReport
end

function DIR.GetSecretAgendaScores()
	local results = {}
	local tokenPositions = DIR.GetTokenPositionsFromBoard()
	tokenPositions.Stability = nil
	local coinStandings = DIR.GetCoinStandings()
	U.forEach(S.getPlayers(), function(player)
		results[player.color] = DIR.GetSecretAgendaScore(player, tokenPositions, coinStandings[player.color])
	end)
	return results
end

function DIR.GetOpenAgendaScore(playerRef, tokenPositions)
	local posOpenAgendas = S.getPlayerVal(playerRef, "openAgendas", "positive") or {}
	local negOpenAgendas = S.getPlayerVal(playerRef, "openAgendas", "negative") or {}
	local scoreReport = {positive = {}, negative = {}}
	local resPositions = U.getValues(tokenPositions)
	table.sort(resPositions, function(a, b) return a.slot > b.slot end)
	-- log({tokenPositions = tokenPositions})
	local topResources, secondResources = {}, {}
	table.insert(topResources, U.shift(resPositions))
	while (#resPositions > 0 and resPositions[1].slot == topResources[1].slot) do
		table.insert(topResources, U.shift(resPositions))
	end
	if #resPositions > 0 then
		table.insert(secondResources, U.shift(resPositions))
		while (#resPositions > 0 and resPositions[1].slot == secondResources[1].slot) do
			table.insert(secondResources, U.shift(resPositions))
		end
	end

	resPositions = U.getValues(tokenPositions)

	table.sort(resPositions, function(a, b) return a.slot < b.slot end)
	local botResources, secBotResources = {}, {}
	table.insert(botResources, U.shift(resPositions))
	while (#resPositions > 0 and resPositions[1].slot == botResources[1].slot) do
		table.insert(botResources, U.shift(resPositions))
	end
	if #resPositions > 0 then
		table.insert(secBotResources, U.shift(resPositions))
		while (#resPositions > 0 and resPositions[1].slot == secBotResources[1].slot) do
			table.insert(secBotResources, U.shift(resPositions))
		end
	end

	-- log({topResources = topResources, secondResources = secondResources, botResources = botResources, secBotResources = secBotResources})

	scoreReport.openAgendaTotal = 0
	U.iForEach(posOpenAgendas, function(res)
		if U.find(topResources, function(rData) return rData.resource == res end) then
			scoreReport.openAgendaTotal = scoreReport.openAgendaTotal + 3
			scoreReport.positive[res] = 3
		elseif U.find(secondResources, function(rData) return rData.resource == res end) then
			scoreReport.openAgendaTotal = scoreReport.openAgendaTotal + 1
			scoreReport.positive[res] = 1
		end
	end)

	U.iForEach(negOpenAgendas, function(res)
		if U.find(botResources, function(rData) return rData.resource == res end) then
			scoreReport.openAgendaTotal = scoreReport.openAgendaTotal - 3
			scoreReport.negative[res] = -3
		elseif U.find(secBotResources, function(rData) return rData.resource == res end) then
			scoreReport.openAgendaTotal = scoreReport.openAgendaTotal - 1
			scoreReport.negative[res] = -1
		end
	end)

	return scoreReport
end

function DIR.GetOpenAgendaScores()
	local results = {}
	local resourcePositions = DIR.GetTokenPositionsFromBoard()
	resourcePositions.Stability = nil
	local tokenPositions = U.map(resourcePositions, function(slot, res)
		return {resource = res, slot = slot}
	end)
	U.forEach(S.getPlayers(), function(player)
		results[player.color] = DIR.GetOpenAgendaScore(player, tokenPositions)
	end)
	return results
end

function DIR.GetPowerBonus()
	local powerTotals = U.map(S.getPlayers(), function(player)
		return {
			color = player.color,
			total = OU.GetTotalValue(P.GetPlayerZone(player, "Power"), "PowerToken"),
			placement = nil
		}
	end)
	table.sort(powerTotals, function(a, b) return a.total > b.total end)
	local placement, lastTotal = 1, powerTotals[1].total
	U.iForEach(powerTotals, function(pData)
		if pData.total < lastTotal then
			placement = placement + 1
		end
		pData.placement = placement
		lastTotal = pData.total
	end)

	local results = {}

	U.forEach(S.getPlayers(), function(player)
		results[player.color] = U.find(powerTotals, function(pData) return pData.color == player.color end)
		if results[player.color].placement == 1 then
			results[player.color].points = 2
		elseif results[player.color].placement == 2 then
			results[player.color].points = 1
		else
			results[player.color].points = 0
		end
	end)

	return results
end

function DIR.GetFinalScores()
	local results = {
		SecretAgenda = DIR.GetSecretAgendaScores(),
		OpenAgenda = DIR.GetOpenAgendaScores(),
		PowerBonus = DIR.GetPowerBonus()
	}
	local byPlayer = {}
	U.forEach(S.getPlayers(), function(player)
		byPlayer[player.color] = {
			name = S.getPlayerHouseName(player),
			color = player.color,
			secretAgenda = DIR.GetSecretAgenda(player),
			resources = results.SecretAgenda[player.color].resources,
			openAgendas = results.OpenAgenda[player.color],
			openAgendasTotal = results.OpenAgenda[player.color].openAgendaTotal,
			coin = results.SecretAgenda[player.color].coin,
			coinTotal = results.SecretAgenda[player.color].coinTotal,
			coinPlacement = results.SecretAgenda[player.color].coinPlacement,
			power = results.PowerBonus[player.color].points,
			powerTotal = results.PowerBonus[player.color].total,
			powerPlacement = results.PowerBonus[player.color].placement
		}
		byPlayer[player.color].total = byPlayer[player.color].resources
			+ byPlayer[player.color].coin
			+ byPlayer[player.color].power
			+ U.sumVals(U.getValues(byPlayer[player.color].openAgendas.positive))
			+ U.sumVals(U.getValues(byPlayer[player.color].openAgendas.negative))
	end)
	return byPlayer
end

function DIR.GetFinalStandings()
	local scoring = C.FinalScoring[S.getStateVal("gameState", "endState")]
	local scores = U.getValues(DIR.GetFinalScores())
	-- log({scores = scores})
	table.sort(scores, function(a, b) return a.total > b.total end)
	for i = 1, #scores do
		scores[i].row = i
	end
	local lastPlace = scores[#scores].total
	for i = #scores, 1, -1 do
		if scores[i].total == lastPlace then
			scores[i].placement = "LAST"
			scores[i].prestige = scoring[5].prestige
			scores[i].crave = scoring[5].crave
		else
			break
		end
	end

	if scores[1].placement ~= "LAST" then
		local placement = 1
		scores[1].placement = placement
		scores[1].prestige = scoring[placement].prestige
		scores[1].crave = scoring[placement].crave
		for i = 2, #scores do
			if scores[i].placement == "LAST" then
				break
			elseif scores[i].total == scores[i - 1].total then
				scores[i].placement = placement
			else
				placement = placement + 1
				scores[i].placement = placement
			end
			scores[i].prestige = scoring[placement].prestige
			scores[i].crave = scoring[placement].crave
		end
	end

	if S.getStateVal("gameState", "endState") ~= "Death" then
		for i = 1, #scores do
			if scores[i].secretAgenda == "Rebel" then
				scores[i].crave = scores[i].crave + 1
			end
		end
	end
	return scores
end



function DIR.InitScoringHUD(scores)
	if scores == nil then scores = DIR.GetFinalStandings() end

	local function signNum(num)
		if num == 0 then return "-" end
		if num > 0 then return "+" .. tostring(num) end
		return tostring(num)
	end
	-- initialize all scoring elements with data from scoresData

	local lastPlacement
	local imageRefs = {}
	U.iForEach(scores, function(sData, index)
		local prefix = "scoringHUD_" .. index .. "_"
		if lastPlacement ~= sData.placement then
			lastPlacement = sData.placement
			UI.setValue(prefix .. "Placement", ({
				[1] = "1st", [2] = "2nd", [3] = "3rd", [4] = "4th", LAST = "LAST"
			})[sData.placement])
		else
			UI.setValue(prefix .. "Placement", "")
		end
		UI.setAttribute("scoringHUD_" .. index, "offsetXY", "0 -" .. tostring(50 + (index - 1) * (100 + 5)))
		U.forEach({"Name", "SecretAgenda", "OpenAgendas", "Coin", "Power", "Total"}, function(ref)
			UI.setAttribute(prefix .. ref, "color", U.GetHex(Color[sData.color]))
		end)
		UI.setValue(prefix .. "Name", sData.name)
		UI.setValue(prefix .. "SecretAgenda", signNum(sData.resources))
		UI.setValue(prefix .. "OpenAgendas", signNum(sData.openAgendasTotal))
		UI.setValue(prefix .. "Coin", signNum(sData.coin))
		UI.setValue(prefix .. "Power", signNum(sData.power))
		UI.setValue(prefix .. "Total", tostring(sData.total))

		local imageRef = ""
		if sData.prestige > 0 then
			imageRef = imageRef .. tostring(sData.prestige) .. "p"
		end
		if sData.crave > 0 then
			imageRef = imageRef .. tostring(sData.crave) .. "c"
		end
		table.insert(imageRefs, imageRef)
	end)

	local validPlacements = U.filter({"LAST", 4, 3}, function(p) return U.find(scores, function(sData) return sData.placement == p end) end)

	local seqFuncs = {
		function()
			UI.hide("scoringSplashScreen")
			UI.show("scoringHUD")
			return 3
		end
	}

	U.iForEach(validPlacements, function(placement)
		table.insert(seqFuncs, function()
			U.forEach(
				U.filter(scores, function(sData) return sData.placement == placement end),
				function(sData) UI.show("scoringHUD_" .. sData.row) end
			)
			return 4
		end)
	end)

	table.insert(seqFuncs, function()
		U.forEach(
			U.filter(scores, function(sData) return sData.placement == 1 end),
			function(sData) UI.show("scoringHUD_" .. sData.row) end
		)
		return 1
	end)

	table.insert(seqFuncs, function()
		U.forEach(
			U.filter(scores, function(sData) return sData.placement == 2 end),
			function(sData) UI.show("scoringHUD_" .. sData.row) end
		)
		return 3
	end)

	table.insert(seqFuncs, function()
		return U.sequence(U.iMap({1, 2, 3, 4, 5}, function(row) return function()
			local id = "scoringHUD_" .. row .. "_Reward_" .. imageRefs[row]
			UI.show(id)
			-- log("Showing '" .. id .. '". = 1_Reward_)
			-- log("Setting 'scoringHUD_" .. row .. "_Reward' to '" .. imageRefs[row] .. "'")
			-- Wait.time(function() UI.setAttribute("scoringHUD_" .. row .. "_Reward", "image", imageRefs[row]) end, 1)
		end end), 0.5)
	end)

	return U.RunSequence(seqFuncs)
end

function DIR.GetWinners() return U.iMap(U.filter(DIR.GetFinalStandings(), function(sData) return sData.placement == 1 end), function(sData) return S.getPlayer(sData.color) end) end
-- #endregion

function DIR.SpawnDilemmaForCapture(dilemmaCard, index)

	local row = math.ceil(index / C.CaptureCoords.Dilemma.numColumns)
	local col = index % C.CaptureCoords.Dilemma.numColumns
	if col == 0 then col = C.CaptureCoords.Dilemma.numColumns end

	-- get position of FRONT side, rotated according to vote outcome
	local frontPos = Vector(C.CaptureCoords.cameraPos)
	frontPos:setAt("y", C.TableHeight)
	frontPos:add(Vector(
		C.CaptureCoords.Dilemma.startXDelta + (col - 1) * C.CaptureCoords.columnXShift,
		0,
		C.CaptureCoords.Dilemma.startZDelta + (row - 1) * (C.CaptureCoords.Dilemma.fullZShift + C.CaptureCoords.Dilemma.halfZShift)
	))

	-- get position of BACK side, from front side pos
	local backPos = Vector(frontPos)
	backPos:add(Vector(
		0,
		C.CaptureCoords.stackYShift,
		C.CaptureCoords.Dilemma.halfZShift
	))

	-- construct front and back transforms
	local transformFront = {
		position = frontPos,
		rotation = Vector(dilemmaCard.alt_view_angle).y > 90 and C.CaptureCoords.Dilemma.frontRotationNay or C.CaptureCoords.Dilemma.frontRotationAye,
		scale = C.CaptureCoords.Dilemma.scale
	}
	local transformBack = {
		position = backPos,
		rotation = Vector(C.CaptureCoords.Dilemma.backRotation),
		scale = C.CaptureCoords.Dilemma.scale
	}

	-- spawn front and back sides, tagging so they can be deleted easily
	OU.SpawnFromSourceObj(dilemmaCard, {"CaptureDilemma"}, transformFront, nil, nil, true)
	OU.SpawnFromSourceObj(dilemmaCard, {"CaptureDilemma"}, transformBack, nil, nil, true)

end

function DIR.RESET()
	-- S.setStateVal("NONE", "gameState", "gameMode")
	-- S.setStateVal("NONE", "gameState", "gamePhase")
	-- HOUSE_SELECTION, newPlayerColors = {}, {}

	U.RunSequence({
		-- stow played Dilemma cards, maintaining order, setting Description to record vote result.
		function()
			local playedDilemmaCards = getObjectsWithAllTags({"Dilemma", "Played"})
			table.sort(playedDilemmaCards, function(a, b) return a.getPosition().z < b.getPosition().z end)
			local tempStagingPos = Vector(C.Spots.Main.CoverCard.Closed.position):add(Vector(-10, -3, 0))
			return {
				U.sequence(U.iMap(playedDilemmaCards, function(card, i) return function()
					tempStagingPos:add(Vector(0, 0.2, 0))
					if Vector(card.alt_view_angle).y > 90 then
						card.setDescription("Vote: NAY")
					else
						card.setDescription("Vote: AYE")
					end
					card.setPosition(tempStagingPos)
					card.setRotation(Vector(0, 180, 180))
					card.setTags({"DilemmaOld"})
					card.setLock(false)
				end end), 0.15),
				unpack(playedDilemmaCards)
			}
		end,

		function() return U.AlertGM("All set!") end
	})
end



return DIR