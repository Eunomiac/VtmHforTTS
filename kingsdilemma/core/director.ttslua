local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
local C = require("kingsdilemma.lib.constants")
local P = require("kingsdilemma.core.players")
local O = require("kingsdilemma.lib.objects")
local OU = require("kingsdilemma.objects.objUtilities")
local V = require("kingsdilemma.core.voting")
local L = require("kingsdilemma.core.lighting")
local MSG = require("kingsdilemma.core.messaging")
local HouseScreen = require("kingsdilemma.objs.p3screen")

local DIR = {}
local HOUSE_SELECTION = {}

function DIR.EndSecretAgendas()
	L.SetLightMode("lightLectern", "ambient")
	L.SetLightMode("lightFront", "ambient")
	L.SetLightMode("lightPlayerSpotlight", "off")
	U.AlertGM("Secret Agendas Dealt!")
end

function DIR.ADVANCE(waitFunc)
	local mode, phase = S.getNextPhase()
	local function startPhase()
		S.setStateVal(mode, "gameMode")
		S.setStateVal(phase, "gamePhase")
		DIR.InitializePhase()
	end

	if waitFunc then
		U.waitUntil(startPhase, waitFunc, true)
	else
		startPhase()
	end
end

function DIR.RESET()
	S.setStateVal("NONE", "gameMode")
	S.setStateVal("NONE", "gamePhase")
	HOUSE_SELECTION = {}
	P.InitializeSeats()
	DIR.InitializePhase()
end

INITFUNCS = {
	NONE = function()
		return {
			function()
				OU.SetGlobalSnapPoints()
				S.setStateVal(false, "isMidGame")
				S.setStateVal({}, "playerData")
				P.ClearSeats()

				S.UpdateSeatedPlayers()
				MSG.Enqueue("Resetting Table", "ALL")
				return MSG.RunQueue("ALL")
			end
		}
	end,
	SESSIONINIT = {
		SeatPlayers = function()
			return {
				function()
					P.InitializeSeats()
					local players = S.getPlayers()
					MSG.Enqueue("Seating Players", "ALL")
					return {
						MSG.RunQueue("ALL", true),
						function() return #U.filter(players, function(pl) return pl.getHandCount() == 0 end) == 0 end
					}
				end,
				function() DIR.ADVANCE() end
			}
		end,
		HouseSelection = function()
			return {
				function()
					DIR.InitHouseSelection()
				end
			}
		end
	},
	CAMPAIGNSETUP = function()
		return {
			DIR.SetChronicleType,
			function() return P.SetCamera("ChronicleCard") end,
			function()
				L.LoadLights({"lightLectern"}, "default")
				return MSG.Splash("Chronicle Setup")
			end,
			DIR.StartChronicle
		}
	end,
	GAMESETUP = {
		MainBoard = function()
			return {
				function()
					P.SetCamera("BehindScreen")
					return MSG.Splash("Board Setup")
				end,
				DIR.SpawnBoardTokens,
				function()
					L.SetLightMode("lightStability", "on")
					local rTokens = getObjectsWithTag("ResourceMarker")
					table.sort(rTokens, function(a, b) return a.getPosition().x < b.getPosition().x end)
					return U.RunSequence(U.iMap(rTokens, function(tk)
						return function()
							tk.setRotation(Vector(0, 180, U.randBetween(0, 1, true) * 180))
							tk.addForce(Vector(0, 40, 0), 3)
							tk.addTorque(Vector(0, 0, 2), 3)
							return tk
						end
					end))
				end,
				function() return 1 end,
				function()
					return {
						DIR.UpdateMomentum("Influence"),
						DIR.UpdateMomentum("Wealth"),
						DIR.UpdateMomentum("Morale"),
						DIR.UpdateMomentum("Welfare"),
						DIR.UpdateMomentum("Knowledge")
					}
				end,
				function()
					V.ElevateBalance()
					return L.SetLightMode("lightBalance", "bright", nil, 0.5)
				end,
				function()
					V.SpawnBalanceTokens(3)
					L.SetLightMode("lightBalance", "on", nil, 3)
					return 1.5
				end,
				function()
					MSG.Splash("Distributing Power & Coin")
					return {
						DIR.SpawnStartingPlayerPower(),
						DIR.SpawnStartingPlayerCoins()
					}
				end,
				DIR.ADVANCE
			}
		end,
		LeaderModerator = function()
			local leader, moderator
			return {
				function()
					leader = P.GetMostPrestigious()
					local leaderName
					if S.getPlayerVal(leader, "houseName") then
						leaderName = "House " .. S.getPlayerVal(leader, "houseName")
					else
						leaderName = S.getPlayerVal(leader, "house")
					end
					MSG.Splash(leaderName .. " Is Most Prestigious")
					return L.SetLightMode("lightLeader", "on", nil, 1)
				end,
				function()
					return {1, P.AssignLeader(leader)}
				end,
				function()
					moderator = P.GetLeastPrestigious()
					local moderatorName
					if S.getPlayerVal(moderator, "houseName") then
						moderatorName = "House " .. S.getPlayerVal(moderator, "houseName")
					else
						moderatorName = S.getPlayerVal(moderator, "house")
					end

					MSG.Splash(moderatorName .. " Is Least Prestigious", "ALL")
					return L.SetLightMode("lightModerator", "on", nil, 1)
				end,
				function()
					return {1, P.AssignModerator(moderator)}
				end,
				DIR.ADVANCE
			}
		end,
		LegacySetup = function()
			return {
				function()
					return MSG.Splash("Applying Legacy Effects")
				end,
				function()
					return MSG.Splash("Assigning Open Agendas")
				end,
				DIR.ADVANCE
				-- LEGACY EFFECTS
				-- Apply 'em
				-- Open Agendas too!
			}
		end,
		SecretAgendas = function()
			local agendaDeck, agendaCard
			return {
				function()
					agendaDeck = getObjectsWithTag("SecretAgenda")[1]
					U.Val("SecretAgendas", agendaDeck, U.isGameObject(agendaDeck) and agendaDeck.type == "Deck")
					P.SetCamera("ChronicleCard")
					return MSG.Splash("Assigning Secret Agendas")
				end,
				function()
					agendaDeck.setLock(true)
					L.SetLightMode("lightLectern", "spotlightDilemmaDeck", nil, 1)
					return {
						U.setPositionSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.High.position), 1),
						U.setRotationSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.High.rotation), 1)
					}
				end,
				function()
					U.setPositionSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.High.position), 1)
					U.setRotationSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.High.rotation), 1)
					return 0.75
				end,
				function()
					U.setPositionSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.Low.position), 0.5)
					U.setRotationSlow(agendaDeck, Vector(C.Spots.Staging.SecretAgenda.Low.rotation), 0.5)
					return 0.25
				end,
				function()
					agendaDeck.shuffle()
					return 0.5
				end,
				function()
					local isSpawned = false
					agendaCard = agendaDeck.takeObject({
						position = Vector({-0.01, 6.95, 24.41}),
						rotation = Vector({0, 0, 180}),
						callback_function = function(obj)
							obj.setLock(true)
							isSpawned = true
						end
					})
					return function() return isSpawned == true end
				end,
				function()
					U.setRotationSlow(agendaCard, Vector(C.Spots.Staging.SecretAgenda.Burnt.rotation), 2)
					return U.setPositionSlow(agendaCard, Vector(C.Spots.Staging.SecretAgenda.Burnt.position), 2, "speedUp")
				end,
				function()
					local leastPrestigious = P.GetLeastPrestigious()
					return P.DealAll(agendaDeck, leastPrestigious)
				end,
				function() return P.SetCamera("BehindScreen") end,
				function()
					local leastPrestigious = P.GetLeastPrestigious()
					local pNum = S.getPlayerNum(leastPrestigious)
					return {
						L.SetLightMode("lightLectern", "off"),
						L.SetLightMode("lightPlayerSpotlight", "player" .. pNum),
						L.SetLightMode("lightFront", "dim")
					}
				end,
				function()
					return MSG.Splash("Choose Your Secret Agenda", P.GetLeastPrestigious().color)
				end
			}
		end
	},
	PLAY = {
		Draw = function()
			return {


			}
		end,
		Balance = function()
			return {


			}
		end,
		Vote = function()
			return {


			}
		end,
		Result = function()
			return {
				-- set alt_view_angle to ...
				-- AYE vote = Vector(0,0,0)
				-- NAY vote = Vector(0,180,180)
				-- Automatically place Dilemma card in proper board snap point, checking for king death here


			}
		end,
		Resolution = function()
			return {


			}
		end
	},
	END = {
		Score = function()
			return {


			}
		end,
		Realm = function()
			return {


			}
		end,
		Achievements = function()
			return {


			}
		end,
		Alignments = function()
			return {


			}
		end,
		Cleanup = function()
			return {


			}
		end
	}
}

function DIR.InitializePhase()
	Global.call("UpdatePhaseDisplay")
	local mode = S.getStateVal("gameMode")
	local phase = S.getStateVal("gamePhase")
	local seqFuncs = INITFUNCS[mode]
	if type(seqFuncs) == "table" then
		seqFuncs = seqFuncs[phase]
	end
	if type(seqFuncs) == "function" then
		seqFuncs = seqFuncs()
	end
	U.RunSequence(seqFuncs)
end

function DIR.JumpToStatePhase()
	local mode = S.getStateVal("gameMode")
	local phase = S.getStateVal("gamePhase")

	-- ... further logic to resync game environment to whatever point in the game we're at.
end

function DIR.InitSession()
	UI.hide("sessionInitDisplay")
	UI.show("gameStatusDisplay")
	return U.RunSequence({
		function()
			UI.hide("splashScreen")
			return 0.75
		end,
		-- function()
		-- 	L.LoadLights({"lightLectern", "lightMainTop", "lightMainBottom", "lightLeader", "lightModerator"}, "default")
		-- 	return 3
		-- end,
		function()
			if S.isInMode(C.Modes.NONE) then
				DIR.ADVANCE()
			else
				DIR.JumpToStatePhase()
			end
			return 1
		end
	})
end

function DIR.SetChronicleType(isForcing)
	U.Assert("DIR.ADVANCE", S.getStateVal("gameCount") == 1)
	if S.getStateVal("chronicleType") ~= "" and not isForcing then return 0.25 end
	S.setStateVal(nil, "chronicleType")
	local host = S.getPlayer("Host")
	host.showOptionsDialog(
		"How do you want to start your Chronicle of A King's Dilemma?",
		{ "Prologue", "Main" },
		"Prologue",
		function(response) S.setStateVal(response, "chronicleType") end
	)
	return function() return S.getStateVal("chronicleType") ~= nil end
end

-- #region House Selection ~

local function getUnselectedPlayers()
	return U.filter(S.getPlayers(), function(player)
		if S.getPlayerVal(player, "house") ~= nil then return false end
		if U.isIn(player.color, U.getValues(HOUSE_SELECTION)) then return false end
		return true
	end)
end

local function getHouseStatus(houseName, player)
	local playerOfHouseData = U.find(S.getStateVal("playerStorage"), function(pData) return pData.house == houseName end)
	if playerOfHouseData then
		local playerID = playerOfHouseData.id
		local seatedPlayerOfHouse = U.find(S.getStateVal("playerData"), function(pData) return pData.id == playerID end)
		if seatedPlayerOfHouse then
			if seatedPlayerOfHouse.color == player.color then
				return "Claimed", "BySelf", Color[player.color]
			else
				return "Claimed", "ByOther", Color[seatedPlayerOfHouse.color]
			end
		end
		return "Claimed", "ByAbsent"
	elseif HOUSE_SELECTION[houseName] then
		if HOUSE_SELECTION[houseName] == player.color then
			return "Selected", "BySelf", Color[player.color]
		else
			return "Selected", "ByOther", Color[HOUSE_SELECTION[houseName]]
		end
	else
		return "Available"
	end
end

function DIR.InitHouseSelection()
	HOUSE_SELECTION = {}
	if #getUnselectedPlayers() == 0 then
		DIR.AssignSelectedHouses()
	else
		U.forEach(S.getPlayers(), function(player)
			UI.show("houseSelection_" .. player.color)
		end)
		DIR.RefreshHouseHUD()
	end
end

local function getPlayerSelectedHouse(player)
	return U.findIndex(HOUSE_SELECTION, function(color) return color == player.color end)
end

local flagColors = {
	Available = function() return Color.Grey end,
	Hovered = function() return Color.White end,
	ClaimedByOther = function(playerColor) return playerColor:setAt("a", 0.5) end,
	ClaimedBySelf = function(playerColor) return playerColor end,
	ClaimedByAbsent = function() return Color.Grey:setAt("a", 0.1) end,
	SelectedByOther = function(playerColor) return playerColor:lerp(Color.Black, 0.5) end,
	SelectedBySelf = function(playerColor) return playerColor:lerp(Color.White, 0.5) end,
	SelectedByOtherHover = function(playerColor) return playerColor end,
	SelectedBySelfHover = function() return Color.White end,
	Invisible = function() return Color.Black:setAt("a", 0) end
}

function DIR.RefreshHouseHUD(houseName, player)
	if houseName == nil then return U.forEach(C.Houses, function(house) DIR.RefreshHouseHUD(house, player) end) end
	if player == nil then return U.forEach(S.getPlayers(), function(pl) DIR.RefreshHouseHUD(houseName, pl) end) end

	local houseStatus, statusDetail, statusColor = getHouseStatus(houseName, player)
	-- log({houseName = houseName, player = player.color, houseStatus = houseStatus, statusDetail = statusDetail, statusColor = statusColor})

	local flagID = "houseFlag_" .. houseName .. "_" .. player.color
	local hoverID = "houseHover_" .. houseName .. "_" .. player.color

	local flagAttrs = {
		color = U.GetHex(flagColors.Available()),
		image = C.Images.Flags.Base[houseName]
	}
	local hoverAttrs = {
		color = U.GetHex(flagColors.Invisible()),
		raycastTarget = "true",
		onMouseDown = "HUD_Click",
		onMouseEnter = "HUD_HoverOn",
		onMouseExit = "HUD_HoverOff"
	}

	if houseStatus == "Claimed" then
		-- log({ Claimed = houseName, statusDetail = statusDetail, statusColor = statusColor })
		flagAttrs.image = C.Images.Flags.Claimed[houseName]
		hoverAttrs.onMouseDown = ""
		hoverAttrs.color = U.GetHex(flagColors.Invisible())
		if statusDetail == "ByOther" then
			flagAttrs.color = U.GetHex(flagColors.ClaimedByOther(statusColor))
		elseif statusDetail == "BySelf" then
			flagAttrs.color = U.GetHex(flagColors.ClaimedBySelf(statusColor))
			hoverAttrs.color = U.GetHex(Color.White)
		elseif statusDetail == "ByAbsent" then
			flagAttrs.color = U.GetHex(flagColors.ClaimedByAbsent())
		end
	elseif houseStatus == "Selected" then
		flagAttrs.image = C.Images.Flags.Claimed[houseName]
		if statusDetail == "ByOther" then
			flagAttrs.color = U.GetHex(flagColors.SelectedByOther(statusColor))
			hoverAttrs.color = U.GetHex(flagColors.SelectedByOtherHover(statusColor))
			hoverAttrs.onMouseDown = ""
		elseif statusDetail == "BySelf" then
			flagAttrs.color = U.GetHex(flagColors.SelectedBySelf(statusColor))
			hoverAttrs.color = U.GetHex(flagColors.SelectedBySelfHover())
		end
	end

	UI.setAttributes(flagID, flagAttrs)
	UI.setAttributes(hoverID, hoverAttrs)
end

function DIR.HouseHUDClick(player, houseName)
	local houseStatus = getHouseStatus(houseName, player)
	-- log({ HOUSES_START = HOUSE_SELECTION, houseStatus = houseStatus, numUnselected = #getUnselectedPlayers() })
	if houseStatus == "Selected" then
		HOUSE_SELECTION[houseName] = false
	elseif houseStatus == "Available" then
		local curHouse = getPlayerSelectedHouse(player)
		if curHouse then
			HOUSE_SELECTION[curHouse] = false
			DIR.RefreshHouseHUD(curHouse)
		end
		HOUSE_SELECTION[houseName] = player.color
	end
	-- log({ HOUSES_END = HOUSE_SELECTION, numUnselected = #getUnselectedPlayers() })
	if #getUnselectedPlayers() == 0 then
		U.RunSequence({
			function()
				DIR.RefreshHouseHUD(houseName)
				return 2
			end,
			function()
				U.forEach(C.SeatColors, function(col) UI.hide("houseSelection_" .. col) end)
				return 2
			end,
			function()
				return DIR.AssignSelectedHouses()
			end
		})
	else
		DIR.RefreshHouseHUD(houseName)
	end
end

function DIR.HouseHUDHoverOn(player, houseName)
	local houseStatus = getHouseStatus(houseName, player)
	local curHouse = getPlayerSelectedHouse(player)
	if curHouse ~= nil then
		UI.setAttribute("houseInfo_" .. curHouse .. "_" .. player.color, "active", "false")
	end
	UI.show("houseInfo_" .. houseName .. "_" .. player.color)

	if houseStatus == "Available" then
		UI.setAttributes("houseFlag_" .. houseName .. "_" .. player.color, {
			color = U.GetHex(flagColors.Hovered())
		})
		UI.setAttributes("houseHover_" .. houseName .. "_" .. player.color, {
			color = U.GetHex(flagColors.Hovered())
		})
	end
end

function DIR.HouseHUDHoverOff(player, houseName)
	local houseStatus, statusDetail, statusColor = getHouseStatus(houseName, player)
	local curHouse = getPlayerSelectedHouse(player)
	if curHouse == houseName then return end
	if curHouse ~= nil then
		UI.setAttribute("houseInfo_" .. curHouse .. "_" .. player.color, "active", "true")
	end
	UI.hide("houseInfo_" .. houseName .. "_" .. player.color)

	if houseStatus == "Available" then
		UI.setAttributes("houseFlag_" .. houseName .. "_" .. player.color, {
			color = U.GetHex(flagColors.Available())
		})
		UI.setAttributes("houseHover_" .. houseName .. "_" .. player.color, {
			color = U.GetHex(flagColors.Invisible())
		})
	end
end

function DIR.AssignSelectedHouses()
	local newPlayerColors = {}
	if HOUSE_SELECTION ~= nil then
		U.forEach(HOUSE_SELECTION, function(color, houseName)
			if not color or not houseName then return end
			local player = S.getPlayer(color)
			table.insert(newPlayerColors, color)
			S.setPlayerVal(houseName, player, "house")
			S.setPlayerVal(nil, player, "houseName")
		end)
	end
	return U.RunSequence(U.concat({
			function()
				MSG.Splash("Setting Up Play Spaces", "ALL", 5)
				return 3
			end
		},
		U.map(S.getPlayers(), function(player)
			return function()
				local house = S.getPlayerVal(player, "house")
				return HouseScreen.Spawn(player, house, U.isIn(player.color, newPlayerColors))
			end
		end),
		{
			function() return 2 end,
			function()
				return L.LoadLights({"lightFront", "lightBehind", "lightVote"}, "ambient")
			end,
			function()
				U.AlertGM("All Done!")
				return 1
			end
		}
	))
end

-- #endregion

local function getContainedGUID(container, targetName)
	if not U.isGameObject(container) or type(targetName) ~= "string" then return end
	local targetObjData = U.find(container.getObjects(), function(objData)
		return string.lower(objData.name) == string.lower(targetName)
	end)
	if targetObjData == nil then
		broadcastToAll("Target '" .. tostring(targetName) .. "' not found. Check letters and cases.", { 1, 0, 0 })
		return nil
	end
	return targetObjData.guid
end

local function getUpdatedChronicleCardState(cScriptState)
	local scriptState = JSON.decode(cScriptState)
	local playerKeys = { "1", "8", "15", "22", "29" }
	U.forEach(S.getPlayers(), function(player, i)
		local houseName = S.getPlayerVal(player, "houseName") or ""
		scriptState[playerKeys[i]] = houseName
	end)
	return JSON.encode(scriptState)
end

function DIR.PlaceChronicleCard(kingName)
	local sourceObj = O.SpawnSources.chronicleCard()
	local spawnData = sourceObj.getData()
	local cCard
	spawnData.Nickname = kingName
	spawnData.Description = os.date("%b ") .. os.date("*t").day .. " '" .. os.date("*t").year - 2000
	spawnData.Transform = OU.unfoldTransform(C.Spots.Main.ChronicleCard)
	spawnData.Tags = { "ChronicleCard", "ChronicleCardActive" }
	spawnData.LuaScriptState = getUpdatedChronicleCardState(spawnData.LuaScriptState)
	spawnObjectData({
		data = spawnData,
		callback_function = function(obj) cCard = obj end
	})
	return function()
		-- log({ cCard = cCard })
		return cCard ~= nil
	end
end

function DIR.UpdateChronicleCardNames()
	local cCard = getObjectsWithTag("ChronicleCardActive")[1]
	if cCard == nil then return end
	local cData = cCard.getData()
	cCard.setCustomObject({ LuaScriptState = getUpdatedChronicleCardState(cData.LuaScriptState) })
	cCard.reload()
end

function DIR.PresentStoryCard(storyCard)
	U.Assert("DIR.PresentStoryCard", storyCard, "Object")
	return U.RunSequence({
		function()
			storyCard.setPositionSmooth(Vector(C.Spots.Staging.StoryCard.Display.position):add(Vector(0, 5, 0)))
			storyCard.setRotationSmooth(Vector(C.Spots.Staging.StoryCard.Display.rotation))
			return {
				storyCard,
				L.SetLightMode("lightLectern", "storyCard")
			}
		end,
		function()
			storyCard.setLock(false)
			return {
				storyCard,
				1.5
			}
		end,
		function()
			P.SetCamera("DilemmaPlinth")
			return function() return not Vector.equals(storyCard.getPosition(),
				Vector(C.Spots.Staging.StoryCard.Display.position), 1) end
		end,
		function()
			return L.SetLightMode("lightLectern", "ambient")
		end
	})
end

function DIR.AddToDilemmaDeck(dilemmas)
	U.Assert("DIR.AddUnhandledCardsToDilemmaDeck: Object Test", dilemmas, "Object")
	U.Assert("DIR.AddUnhandledCardsToDilemmaDeck: Deck or Card Test", U.isIn(dilemmas.type, { "Card", "Deck" }))
	local coverCard = O.Pieces.CoverCard()
	U.Assert("DIR.AddUnhandledCardsToDilemmaDeck", coverCard, "Object")
	coverCard.setLock(true)
	local coverCardRaisedPos = coverCard.getPosition():add(Vector(0, 5, 0))
	local dilemmaDestPos = Vector(coverCardRaisedPos):add(Vector(0, -3, 0))

	local function addNextDilemma()
		dilemmaDestPos = dilemmaDestPos:add(Vector(0, 0.4, 0))
		if dilemmas.type == "Deck" then
			dilemmas.takeObject({
				position = dilemmaDestPos,
				rotation = coverCard.getRotation(),
				callback_function = function(obj)
					obj.setTags({ "Dilemma" })
					obj.setLock(false)
				end
			})
			if dilemmas.remainder ~= nil then
				dilemmas = dilemmas.remainder
			end
		elseif dilemmas.type == "Card" then
			dilemmas.setTags({ "Dilemma" })
			dilemmas.setLock(false)
			dilemmas.setPositionSmooth(dilemmaDestPos)
			dilemmas.setRotationSmooth(coverCard.getRotation())
		end
		return 0.3
	end

	local seqFuncs = {
		function()
			return U.setPositionSlow(coverCard, coverCardRaisedPos)
		end,
		addNextDilemma
	}

	if dilemmas.type == "Deck" then
		for i = 2, #dilemmas.getObjects() do
			table.insert(seqFuncs, addNextDilemma)
		end
	end

	table.insert(seqFuncs, function()
		return
				function()
					local dilemmaObjs = getObjectsWithTag("Dilemma")
					if #dilemmaObjs ~= 1 then return false end
					if dilemmaObjs[1].type ~= "Deck" then return false end
					dilemmas = dilemmaObjs[1]
					return true
				end
	end)
	table.insert(seqFuncs, function()
		dilemmas.shuffle()
		return 1
	end)
	table.insert(seqFuncs, function()
		coverCard.setLock(false)
		return { coverCard, 0.1 }
	end)

	return U.RunSequence(seqFuncs)
end

function DIR.OpenEnvelope(envKey, isStandard)
	U.Assert("DIR.OpenEnvelope", envKey, "string")
	local envContainer = O.SecretContainers.Envelopes()
	U.Assert("DIR.OpenEnvelope", envContainer, "Object")

	local envGUID = getContainedGUID(envContainer, envKey)
	if envGUID == nil then
		U.Alert("Envelope '" .. envKey .. "' Not Found! Check Case & Spelling", Color(1, 0, 0))
		return
	end

	local envDeck, storyCard

	local seqFuncs = {
		function() return { L.SetLightMode("lightLectern", "spotlightEnvelope", nil, 0.25) } end,
		function()
			U.setPositionSlow(envContainer, C.Spots.Staging.Lectern.Envelopes.position)
			U.setRotationSlow(envContainer, C.Spots.Staging.Lectern.Envelopes.rotation)
			return { envContainer, L.SetLightMode("lightLectern", "spotlightPlinth", nil, 0.1) }
		end,
		function()
			envContainer.takeObject({
				position = C.Spots.Staging.Lectern.Display.position,
				rotation = C.Spots.Staging.Lectern.Display.rotation,
				guid = envGUID,
				callback_function = function(obj)
					envDeck = obj
					envDeck.setLock(true)
				end
			})
			return function() return envDeck ~= nil end
		end,
		function()
			U.setPositionSlow(envContainer, C.Spots.Storage.Envelopes.position)
			U.setRotationSlow(envContainer, C.Spots.Storage.Envelopes.rotation)
			return 0.3
		end,
		function()
			envDeck.takeObject({
				position = C.Spots.Staging.Lectern.TopCard.position,
				rotation = C.Spots.Staging.Lectern.TopCard.rotation,
				callback_function = function(obj)
					storyCard = obj
					storyCard.setTags({ "StoryCard" })
					storyCard.setLock(true)
				end
			})
			return function() return storyCard ~= nil end
		end,
		function()
			L.SetLightMode({"lightMainTop", "lightMainBottom"}, "ambient", nil, 3)
			return L.SetLightMode("lightLectern", "spotlightTransit", nil, 0.3)
		end
	}

	if isStandard == true then
		table.insert(seqFuncs, function() return DIR.AddToDilemmaDeck(envDeck) end)
	end

	table.insert(seqFuncs, function() return DIR.PresentStoryCard(storyCard) end)

	if isStandard ~= true then
		local leaderInstructions
		table.insert(seqFuncs, function()
			DIR.PromptLeaderToHandleEnvelope(envDeck)
			return function() return leaderInstructions ~= nil end
		end)
		table.insert(seqFuncs, function()
			return DIR.HandleLeaderEnvelopeInstructions(leaderInstructions)
		end)
	end

	return U.RunSequence(seqFuncs)
end

function DIR.StartChronicle()
	U.Assert("DIR.StartChronicle", U.isIn(S.getStateVal("chronicleType"), { "Main", "Prologue" }))
	local startingEnvelope = ({ Prologue = "D1", Main = "0" })[S.getStateVal("chronicleType")]
	local kingName = ({ Prologue = "Harald IV", Main = "Harald V" })[S.getStateVal("chronicleType")]

	return U.RunSequence({
		-- function() return L.SetLightMode("lightLectern", "spotlightChronicleCard") end,
		-- function() return DIR.PlaceChronicleCard(kingName) end,
		function() return P.SetCamera("ChronicleCard") end,
		function()
			-- P.SetCamera("DilemmaPlinth")
			return DIR.OpenEnvelope(startingEnvelope, true)
		end
	})
end

local function spawnToken(sourceObj, tags, transformData)
	local spawnData = sourceObj.getData()
	local token
	spawnData.Transform = OU.unfoldTransform(transformData)
	spawnData.Tags = tags
	spawnObjectData({
		data = spawnData,
		callback_function = function(obj)
			obj.setLock(false)
			token = obj
		end
	})
	return { 1, function() return token ~= nil end }
end

function DIR.SpawnBoardTokens()
	return {
		spawnToken(O.SpawnSources.stabilityToken(), { "StabilityMarker" }, C.Spots.Board.StabilityToken.center),
		spawnToken(O.SpawnSources.influenceToken(), { "ResourceMarker", "Influence" },
		C.Spots.Board.ResourceTokens.Influence.center),
		spawnToken(O.SpawnSources.wealthToken(), { "ResourceMarker", "Wealth" }, C.Spots.Board.ResourceTokens.Wealth.center),
		spawnToken(O.SpawnSources.moraleToken(), { "ResourceMarker", "Morale" }, C.Spots.Board.ResourceTokens.Morale.center),
		spawnToken(O.SpawnSources.welfareToken(), { "ResourceMarker", "Welfare" },
		C.Spots.Board.ResourceTokens.Welfare.center),
		spawnToken(O.SpawnSources.knowledgeToken(), { "ResourceMarker", "Knowledge" },
		C.Spots.Board.ResourceTokens.Knowledge.center)
	}
end

local function getTokenMomentum(token, resource)
	local lastTurnPos = Vector(S.getStateVal("lastTurn", "tokenPos" .. resource))
	local thisTurnPos = token.getPosition()
	S.setStateVal(thisTurnPos, "lastTurn", "tokenPos" .. resource)
	if U.isFlipped(token) then
		if math.abs(tonumber(thisTurnPos.z) - tonumber(lastTurnPos.z)) < 1 then
			return "Down", 1
		elseif tonumber(thisTurnPos.z) > tonumber(lastTurnPos.z) then
			return "Up", 1
		else
			return "Down", 2
		end
	else
		if math.abs(tonumber(thisTurnPos.z) - tonumber(lastTurnPos.z)) < 1 then
			return "Up", 1
		elseif tonumber(thisTurnPos.z) < tonumber(lastTurnPos.z) then
			return "Down", 1
		else
			return "Up", 2
		end
	end
end

function DIR.UpdateMomentum(resource)
	local token = getObjectsWithAllTags({ "ResourceMarker", resource })[1]
	U.Assert("DIR.UpdateMomentum", token, "Object")
	local momentumDir, momentumVal = getTokenMomentum(token, resource)
	local seqFuncs = {}
	if U.isFlipped(token) then
		if momentumDir == "Up" then
			table.insert(seqFuncs, function()
				token.flip()
				return token
			end)
		end
	else
		if momentumDir == "Down" then
			table.insert(seqFuncs, function()
				token.flip()
				return token
			end)
		end
	end
	table.insert(seqFuncs, function()
		L.SetLightMode("light" .. resource, "momentum" .. momentumDir .. momentumVal)
	end)
	return U.RunSequence(seqFuncs)
end

function DIR.SpawnStartingPlayerPower()
	return U.RunSequence(U.map(S.getPlayers(), function(player)
		local numPower = 8 + (S.getPlayerVal(player, "startingPowerBonus") or 0)
		return function() return {1, P.SpawnPower(player, numPower)} end
	end))
end

function DIR.SpawnStartingPlayerCoins()
	return U.RunSequence(U.map(S.getPlayers(), function(player)
		local numCoins = 10 + (S.getPlayerVal(player, "startingCoinsBonus") or 0)
		return function() return {1, P.SpawnCoins(player, numCoins)} end
	end))
end

function DIR.DrawDilemmaCard()
	local coverCard = O.Pieces.CoverCard()
	local dilemmaSource = U.findBelowObject(coverCard, function(obj) return obj.type == "Card" or obj.type == "Deck" end)
	U.Val("DIR.DrawDilemmaCard", dilemmaSource, #dilemmaSource == 1)
	dilemmaSource = dilemmaSource[1]
	local dilemmaCard
	local seqFuncs = {}
	table.insert(seqFuncs, function() return {
		P.SetCamera("DilemmaPlinth"),
		MSG.Splash("Drawing Dilemma Card")
	} end)
	if dilemmaSource.type == "Deck" then
		table.insert(seqFuncs, function()
			L.SetLightMode("lightLectern", "spotlightDilemmaDeck")
			dilemmaSource.takeObject({
				position = C.Spots.Staging.DilemmaDraw.position,
				rotation = C.Spots.Staging.DilemmaDraw.rotation,
				top = false,
				callback_function = function(obj)
					obj.setLock(true)
					dilemmaCard = obj
				end
			})
			return function() return dilemmaCard ~= nil end
		end)
	else
		table.insert(seqFuncs, function()
			L.SetLightMode("lightLectern", "spotlightDilemmaDeck")
			dilemmaCard.setLock(true)
			return {
				U.setPositionSlow(dilemmaCard, C.Spots.Staging.DilemmaDraw.position),
				U.setRotationSlow(dilemmaCard, C.Spots.Staging.DilemmaDraw.rotation)
			}
		end)
	end
	table.insert(seqFuncs, function()
		L.SetLightMode("lightLectern", "off", nil, 0.5)
		L.SetLightMode("lightDilemmaMain", "on", nil, 2)
		dilemmaCard.addTag("OnDisplay")
		return {
			U.setPositionSlow(dilemmaCard, C.Spots.Main.DilemmaDisplay.faceDown.position, 2, "speedUp"),
			U.setRotationSlow(dilemmaCard, C.Spots.Main.DilemmaDisplay.faceDown.rotation, 2, "speedUp"),
			U.setScaleSlow(dilemmaCard, C.Spots.Main.DilemmaDisplay.faceDown.scale, 2, "speedUp")
		}
	end)
	table.insert(seqFuncs, function()
		return {
			L.SetLightMode("lightDilemmaAye", "on", nil, 1),
			L.SetLightMode("lightDilemmaNay", "on", nil, 1)
		}
	end)
	return U.RunSequence(seqFuncs)
end

function DIR.ReleaseDilemmaCard(voteResult)
	local dilemmaCard = getObjectsWithAllTags({"Dilemma", "OnDisplay"})[1]
	if dilemmaCard == nil then return U.AlertGM("No Dilemma Card Displayed!") end
	L.SetLightMode("lightDilemmaAye", "off", nil, 0.5)
	L.SetLightMode("lightDilemmaNay", "off", nil, 0.5)
	L.SetLightMode("lightDilemmaMain", "off", nil, 2)
	L.SetLightMode("lightLectern", "storyCard")
	if voteResult == "Nay" then
		dilemmaCard.alt_view_angle = Vector(0, 180, 180)
	else
		dilemmaCard.alt_view_angle = Vector(0, 0, 0)
	end
	dilemmaCard.setLock(false)
	dilemmaCard.removeTag("OnDisplay")
	local dCardPos
	return U.RunSequence({
		function()
			return {
				U.setPositionSlow(dilemmaCard, C.Spots.Main.DilemmaDisplay.faceUp.position, 2),
				U.setRotationSlow(dilemmaCard, C.Spots.Main.DilemmaDisplay.faceUp.rotation, 2),
				U.setScaleSlow(dilemmaCard, C.Spots.Staging.StoryCard.Display.scale, 2),
				dilemmaCard
			}
		end,
		function()
			dCardPos = dilemmaCard.getPosition()
			return function() return not dilemmaCard.getPosition():equals(dCardPos, 1) end
		end,
		function()
			return L.SetLightMode("lightLectern", "ambient")
		end
	})
end

return DIR
