local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
local C = require("kingsdilemma.lib.constants")
local P = require("kingsdilemma.core.players")
local O = require("kingsdilemma.lib.objects")
local OU = require("kingsdilemma.objects.objUtilities")
local V = require("kingsdilemma.core.voting")
local L = require("kingsdilemma.core.lighting")
local MSG = require("kingsdilemma.core.messaging")
local HouseScreen = require("kingsdilemma.objs.p3screen")

local DIR = {}
local HOUSE_SELECTION = {}

function DIR.ADVANCE(waitFunc)
	local mode, phase = S.getNextPhase()
	local function startPhase()
		S.setStateVal(mode, "gameMode")
		S.setStateVal(phase, "gamePhase")
		DIR.InitializePhase()
	end

	if waitFunc then
		U.waitUntil(startPhase, waitFunc, true)
	else
		startPhase()
	end
end

function DIR.RESET()
	S.setStateVal("NONE", "gameMode")
	S.setStateVal("NONE", "gamePhase")
	HOUSE_SELECTION = {}
	S.UpdateSeatedPlayers()
	DIR.InitializePhase()
end

local startType
INITFUNCS = {
	NONE = function() return {
		function()
			OU.SetGlobalSnapPoints()
			S.setStateVal(false, "isMidGame")
			S.setStateVal({}, "playerData")
			P.ClearSeats()

			S.UpdateSeatedPlayers()
			MSG.Enqueue("Resetting Table", "ALL")
			return MSG.RunQueue("ALL")
		end
	} end,
	SESSIONINIT = {
		SeatPlayers = function() return {
			function()
				P.InitializeSeats()
				local players = S.getPlayers()
				MSG.Enqueue("Seating Players", "ALL")
				return {
					MSG.RunQueue("ALL", true),
					function() return #U.filter(players, function(pl) return pl.getHandCount() == 0 end) == 0 end
				}
			end,
			function() DIR.ADVANCE() end
		} end,
		HouseSelection = function() return {
			function()
				DIR.InitHouseSelection()
			end
		} end
	},
	CAMPAIGNSETUP = function() return {
		function()
			MSG.Enqueue("Chronicle Setup", "ALL")
			return MSG.RunQueue("ALL")
		end,
		function()
			U.Assert("DIR.ADVANCE", S.getStateVal("gameCount") == 1)
			local host = S.getPlayer("Host")
			host.showOptionsDialog(
				"How do you want to start your Chronicle of A King's Dilemma?",
				{"Prologue", "Main"},
				"Prologue",
				function(response) startType = response end
			)
			return function() return startType ~= nil end
		end,
		DIR.StartChronicle
	}
	end,
	GAMESETUP = {
		MainBoard = function() return {
			function()
				local rTokens = getObjectsWithTag("ResourceMarker")
				table.sort(rTokens, function(a, b) return a.getPosition().x < b.getPosition().x end)
				return U.RunSequence(U.iMap(rTokens, function(tk)
					return function()
						tk.setRotation(Vector(0, 180, U.randBetween(0,1,true) * 180))
						tk.addForce(Vector(0,40,0),3)
						tk.addTorque(Vector(0,0,2),3)
						return tk
					end
				end))
			end,
			function() U.alertGM("All done!") end
			-- MAIN BOARD SETUP
				-- Randomly shuffle sides of Resource Tokens
				-- Stability token spawned at center
				-- 3x Power to middle of balance
				-- 8x Power and 10x Coins to each player
		} end,
		LeaderModerator = function() return {
			-- LEADER & MODERATOR
				-- Assign Leader token to player with HIGHEST prestige
				-- Assign Moderator token to player with LOWEST prestige
		} end,
		LegacySetup = function() return {
			-- LEGACY EFFECTS
				-- Apply 'em
				-- Open Agendas too!
		} end,
		SecretAgendas = function() return {
			-- SECRET AGENDAS
				-- Shuffle Secret Agendas, Randomly Remove One
				-- sort a table of playerData by prestige, with lowest first
					-- FOR EACH:
					-- get CurrentPlayer = prestigeTable.shift()
					-- "Deal" all SecretAgenda cards in DECKS or in HAND ZONES (but NOT in PLAY) to CurrentPlayer
					-- They choose by dropping from hand onto mat
						-- onObjectDrop() listener for CurrentPlayer dropping SecretAgenda
						-- loop back, dealing all cards to next player
						-- when all players have a SecretAgenda, END START SESSION!
		} end
	},
	PLAY = {
		Draw = function() return {


		} end,
		Balance = function() return {


		} end,
		Vote = function() return {


		} end,
		Result = function() return {
			-- set alt_view_angle to ...
				-- AYE vote = Vector(0,0,0)
				-- NAY vote = Vector(0,180,180)


		} end,
		Resolution = function() return {


		} end
	},
	END = {
		Score = function() return {


		} end,
		Realm = function() return {


		} end,
		Achievements = function() return {


		} end,
		Alignments = function() return {


		} end,
		Cleanup = function() return {


		} end
	}
}

function DIR.InitializePhase()
	Global.call("UpdatePhaseDisplay")
	local mode = S.getStateVal("gameMode")
	local phase = S.getStateVal("gamePhase")
	local seqFuncs = INITFUNCS[mode]
	if type(seqFuncs) == "table" then
		seqFuncs = seqFuncs[phase]
	end
	if type(seqFuncs) == "function" then
		seqFuncs = seqFuncs()
	end
	U.RunSequence(seqFuncs)
end

function DIR.JumpToStatePhase()
	local mode = S.getStateVal("gameMode")
	local phase = S.getStateVal("gamePhase")

	-- ... further logic to resync game environment to whatever point in the game we're at.
end

function DIR.InitSession()
	UI.hide("sessionInitDisplay")
	UI.show("gameStatusDisplay")
	if not S.isInMode(C.Modes.NONE) then
		UI.hide("splashScreen")
		L.LoadLights()
		-- We're in the middle of a running game: jump to that phase.
		return DIR.JumpToStatePhase()
	else
		-- UI.hide("splashScreen")
		-- L.LoadLights()
		-- Wait.time(function() DIR.ADVANCE() end, 2)
		U.RunSequence({
			function()
				UI.hide("splashScreen")
				return 0.5
			end,
			function()
				L.LoadLights()
				return 1
			end,
			function()
				DIR.ADVANCE()
				return 1
			end
		})
	end
end

-- #region House Selection ~

local function getUnselectedPlayers()
	return U.filter(S.getPlayers(), function(player)
		if S.getPlayerVal(player, "house") ~= nil then return false end
		if U.isIn(player.color, U.getValues(HOUSE_SELECTION)) then return false end
		return true
	end)
end

local function getHouseStatus(houseName, player)
	local playerOfHouseData = U.find(S.getStateVal("playerStorage"), function(pData) return pData.house == houseName end)
	if playerOfHouseData then
		local playerID = playerOfHouseData.id
		local seatedPlayerOfHouse = U.find(S.getStateVal("playerData"), function(pData) return pData.id == playerID end)
		if seatedPlayerOfHouse then
			if seatedPlayerOfHouse.color == player.color then
				return "Claimed", "BySelf", Color[player.color]
			else
				return "Claimed", "ByOther", Color[seatedPlayerOfHouse.color]
			end
		end
		return "Claimed", "ByAbsent"
	elseif HOUSE_SELECTION[houseName] then
		if HOUSE_SELECTION[houseName] == player.color then
			return "Selected", "BySelf", Color[player.color]
		else
			return "Selected", "ByOther", Color[HOUSE_SELECTION[houseName]]
		end
	else
		return "Available"
	end
end

function DIR.InitHouseSelection()
	HOUSE_SELECTION = {}
	if #getUnselectedPlayers() == 0 then
		DIR.AssignSelectedHouses()
	else
		U.forEach(S.getPlayers(), function(player)
			UI.show("houseSelection_" .. player.color)
		end)
		DIR.RefreshHouseHUD()
	end
end

local function getPlayerSelectedHouse(player)
	return U.findIndex(HOUSE_SELECTION, function(color) return color == player.color end)
end

local flagColors = {
	Available = function() return Color.Grey end,
	Hovered = function() return Color.White end,
	ClaimedByOther = function(playerColor) return playerColor:lerp(Color.Black, 0.5):setAt("a", 0.1) end,
	ClaimedBySelf = function(playerColor) return playerColor:lerp(Color.White, 0.5):setAt("a", 0.25) end,
	ClaimedByAbsent = function() return Color.Grey:setAt("a", 0.25) end,
	SelectedByOther = function(playerColor) return playerColor:lerp(Color.Black, 0.5) end,
	SelectedBySelf = function(playerColor) return playerColor:lerp(Color.White, 0.5) end,
	SelectedByOtherHover = function(playerColor) return playerColor end,
	SelectedBySelfHover = function() return Color.White end,
	Invisible = function() return Color.Black:setAt("a", 0) end
}
local function getHex(color) return "#" .. color:toHex(true) end

function DIR.RefreshHouseHUD(houseName, player)
	if houseName == nil then return U.forEach(C.Houses, function(house) DIR.RefreshHouseHUD(house, player) end) end
	if player == nil then return U.forEach(S.getPlayers(), function(pl) DIR.RefreshHouseHUD(houseName, pl) end) end

	local houseStatus, statusDetail, statusColor = getHouseStatus(houseName, player)
	-- log({houseName = houseName, player = player.color, houseStatus = houseStatus, statusDetail = statusDetail, statusColor = statusColor})

	local flagID = "houseFlag_" .. houseName .. "_" .. player.color
	local hoverID = "houseHover_" .. houseName .. "_" .. player.color

	local flagAttrs = {
		color = getHex(flagColors.Available()),
		image = C.Images.Flags.Base[houseName]
	}
	local hoverAttrs = {
		color = getHex(flagColors.Invisible()),
		raycastTarget = "true",
		onMouseDown = "HUD_Click",
		onMouseEnter = "HUD_HoverOn",
		onMouseExit = "HUD_HoverOff"
	}

	if houseStatus == "Claimed" then
		log({Claimed = houseName, statusDetail = statusDetail, statusColor = statusColor})
		flagAttrs.image = C.Images.Flags.Claimed[houseName]
		hoverAttrs.onMouseDown = ""
		hoverAttrs.color = getHex(flagColors.Invisible())
		if statusDetail == "ByOther" then
			flagAttrs.color = getHex(flagColors.ClaimedByOther(statusColor))
		elseif statusDetail == "BySelf" then
			flagAttrs.color = getHex(flagColors.ClaimedBySelf(statusColor))
			hoverAttrs.color = getHex(Color.White)
		elseif statusDetail == "ByAbsent" then
			flagAttrs.color = getHex(flagColors.ClaimedByAbsent())
		end
	elseif houseStatus == "Selected" then
		flagAttrs.image = C.Images.Flags.Claimed[houseName]
		if statusDetail == "ByOther" then
			flagAttrs.color = getHex(flagColors.SelectedByOther(statusColor))
			hoverAttrs.color = getHex(flagColors.SelectedByOtherHover(statusColor))
			hoverAttrs.onMouseDown = ""
		elseif statusDetail == "BySelf" then
			flagAttrs.color = getHex(flagColors.SelectedBySelf(statusColor))
			hoverAttrs.color = getHex(flagColors.SelectedBySelfHover(statusColor))
		end
	end

	UI.setAttributes(flagID, flagAttrs)
	UI.setAttributes(hoverID, hoverAttrs)
end



function DIR.HouseHUDClick(player, houseName)
	local houseStatus = getHouseStatus(houseName, player)
	log({HOUSES_START = HOUSE_SELECTION, houseStatus = houseStatus, numUnselected = #getUnselectedPlayers()})
	if houseStatus == "Selected" then
		HOUSE_SELECTION[houseName] = false
	elseif houseStatus == "Available" then
		local curHouse = getPlayerSelectedHouse(player)
		if curHouse then
			HOUSE_SELECTION[curHouse] = false
			DIR.RefreshHouseHUD(curHouse)
		end
		HOUSE_SELECTION[houseName] = player.color
	end
	log({HOUSES_END = HOUSE_SELECTION, numUnselected = #getUnselectedPlayers()})
	if #getUnselectedPlayers() == 0 then
		U.RunSequence({
			function()
				DIR.RefreshHouseHUD(houseName)
				return 2
			end,
			function()
				U.forEach(C.SeatColors, function(col) UI.hide("houseSelection_" .. col) end)
				return 2
			end,
			function()
				MSG.Splash("Assigning Houses", "ALL", 5)
				return 1
			end,
			function()
				return DIR.AssignSelectedHouses()
			end
		})
	else
		DIR.RefreshHouseHUD(houseName)
	end
end

function DIR.HouseHUDHoverOn(player, houseName)
	local houseStatus = getHouseStatus(houseName, player)
	local curHouse = getPlayerSelectedHouse(player)
	if curHouse ~= nil then
		UI.setAttribute("houseInfo_" .. curHouse .. "_" .. player.color, "active", "false")
	end
	UI.show("houseInfo_" .. houseName .. "_" .. player.color)

	if houseStatus == "Available" then
		UI.setAttributes("houseFlag_" .. houseName .. "_" .. player.color, {
			color = getHex(flagColors.Hovered())
		})
		UI.setAttributes("houseHover_" .. houseName .. "_" .. player.color, {
			color = getHex(flagColors.Hovered())
		})
	end
end

function DIR.HouseHUDHoverOff(player, houseName)
	local houseStatus, statusDetail, statusColor = getHouseStatus(houseName, player)
	local curHouse = getPlayerSelectedHouse(player)
	if curHouse == houseName then return end
	if curHouse ~= nil then
		UI.setAttribute("houseInfo_" .. curHouse .. "_" .. player.color, "active", "true")
	end
	UI.hide("houseInfo_" .. houseName .. "_" .. player.color)

	if houseStatus == "Available" then
		UI.setAttributes("houseFlag_" .. houseName .. "_" .. player.color, {
			color = getHex(flagColors.Available())
		})
		UI.setAttributes("houseHover_" .. houseName .. "_" .. player.color, {
			color = getHex(flagColors.Invisible())
		})
	end
end

function DIR.AssignSelectedHouses()
	local newPlayerColors = {}
	if HOUSE_SELECTION ~= nil then
		U.forEach(HOUSE_SELECTION, function(color, houseName)
			if not color or not houseName then return end
			local player = S.getPlayer(color)
			table.insert(newPlayerColors, color)
			S.setPlayerVal(houseName, player, "house")
			S.setPlayerVal(nil, player, "houseName")
		end)
	end
	return U.map(S.getPlayers(), function(player)
		local house = S.getPlayerVal(player, "house")
		return HouseScreen.Spawn(player, house, U.isIn(player.color, newPlayerColors))
	end)
end
-- #endregion

local function getContainedGUID(container, targetName)
	if not U.isGameObject(container) or type(targetName) ~= "string" then return end
	local targetObjData = U.find(container.getObjects(), function(objData)
		return string.lower(objData.name) == string.lower(targetName)
	end)
	if targetObjData == nil then
		broadcastToAll("Target '" .. tostring(targetName) .. "' not found. Check letters and cases.", {1,0,0})
		return nil
	end
	return targetObjData.guid
end

local function getUpdatedChronicleCardState(cScriptState)
	local scriptState = JSON.decode(cScriptState)
	local playerKeys = {"1", "8", "15", "22", "29"}
	U.forEach(S.getPlayers(), function(player, i)
		local houseName = S.getPlayerVal(player, "houseName") or ""
		scriptState[playerKeys[i]] = houseName
	end)
	return JSON.encode(scriptState)
end

function DIR.PlaceChronicleCard(kingName)
	local sourceObj = O.SpawnSources.chronicleCard()
	local spawnData = sourceObj.getData()
	spawnData.Nickname = kingName
	spawnData.Description = os.date("%b ") .. os.date("*t").day .. " '" .. os.date("*t").year - 2000
	spawnData.Transform = OU.unfoldTransform(C.Spots.Main.ChronicleCard)
	spawnData.Tags = {"ChronicleCard", "ChronicleCardActive"}
	spawnData.LuaScriptState = getUpdatedChronicleCardState(spawnData.LuaScriptState)
	return spawnObjectData({data = spawnData})
end

function DIR.UpdateChronicleCardNames()
	local cCard = getObjectsWithTag("ChronicleCardActive")[1]
	if cCard == nil then return end
	local cData = cCard.getData()
	cCard.setCustomObject({LuaScriptState = getUpdatedChronicleCardState(cData.LuaScriptState)})
	cCard.reload()
end

function DIR.StartChronicle()
	local startingEnvelope = ({Prologue = "D1", Main = "0"})[startType]
	local envContainer = O.SecretContainers.Envelopes()
	local coverCard = O.Pieces.CoverCard()
	coverCard.setLock(true)
	local coverCardRaisedPos = coverCard.getPosition():add(Vector(0, 5, 0))
	local newCardDestPos = coverCard.getPosition():add(Vector(0, 0.2, 0))
	local envGUID = getContainedGUID(envContainer, startingEnvelope)
	if envGUID == nil then return end

	local envContents, storyCard, dilemmaDeck, remainder

	local function grabNextCard()
		newCardDestPos = newCardDestPos:add(Vector(0, 0.1, 0))
		if remainder ~= nil then
			remainder.setTags({"Dilemma"})
			remainder.setLock(false)
			remainder.setPositionSmooth(newCardDestPos)
			remainder.setRotationSmooth(coverCard.getRotation())
		else
			envContents.takeObject({
				position = newCardDestPos,
				rotation = coverCard.getRotation(),
				callback_function = function(obj)
					obj.setTags({"Dilemma"})
					obj.setLock(false)
				end
			})
			if envContents.remainder ~= nil then
				remainder = envContents.remainder
				return 1
			end
		end
		return 0.3
	end

	U.RunSequence({
		function() return {L.SetLightMode("lightLectern", "spotlightChronicleCard")} end,
		function() return DIR.PlaceChronicleCard("Harald V") end,
		function() return {L.SetLightMode("lightLectern", "spotlightEnvelope", nil, 0.25)} end,
		function()
			U.setPositionSlow(envContainer, C.Spots.Staging.Lectern.Envelopes.position)
			U.setRotationSlow(envContainer, C.Spots.Staging.Lectern.Envelopes.rotation)
			return {envContainer, L.SetLightMode("lightLectern", "spotlightPlinth", nil, 0.1)}
		end,
		function()
			envContainer.takeObject({
				position = C.Spots.Staging.Lectern.Display.position,
				rotation = C.Spots.Staging.Lectern.Display.rotation,
				guid = envGUID,
				callback_function = function(obj)
					envContents = obj
					envContents.setLock(true)
				end
				})
			return function() return envContents ~= nil end
		end,
		function()
			U.setPositionSlow(coverCard, coverCardRaisedPos)
			U.setPositionSlow(envContainer, C.Spots.Storage.Envelopes.position)
			U.setRotationSlow(envContainer, C.Spots.Storage.Envelopes.rotation)
			return {coverCard, envContainer, L.SetLightMode("lightLectern", "spotlightTransit")}
		end,
		function()
			envContents.takeObject({
				position = C.Spots.Staging.Lectern.TopCard.position,
				rotation = C.Spots.Staging.Lectern.TopCard.rotation,
				callback_function = function(obj)
					storyCard = obj
					storyCard.setTags({"StoryCard"})
					storyCard.setLock(true)
				end
			})
			return function() return storyCard ~= nil end
		end,
		grabNextCard,
		grabNextCard,
		grabNextCard,
		function()
			return
				function()
					local dilemmaObjs = getObjectsWithTag("Dilemma")
					if #dilemmaObjs ~= 1 then return false end
					if dilemmaObjs[1].type ~= "Deck" then return false end
					dilemmaDeck = dilemmaObjs[1]
					return dilemmaDeck
				end
		end,
		function()
			dilemmaDeck.shuffle()
			return 1
		end,
		function()
			coverCard.setLock(false)
			-- storyCard.setLock(false)
			storyCard.setPositionSmooth(Vector({0.00, 7, 16.52}))
			storyCard.setRotationSmooth(Vector({0.00, 180.00, 0.00}))
			return {
				coverCard,
				storyCard,
				L.SetLightMode("lightLectern", "firstStoryCard")
			}
		end,
		function()
			storyCard.setLock(false)
			return {
				storyCard,
				3.5
			}
		end,
		function()
			return function() return not Vector.equals(storyCard.getPosition(), Vector({0.00, 1.94, 16.52}), 1) end
		end,
		function()
			return L.SetLightMode("lightLectern", "ambient")
		end
	})
end




return DIR