local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
local C = require("kingsdilemma.lib.constants")
local O = require("kingsdilemma.lib.objects")
local OU = require("kingsdilemma.objects.objUtilities")

local P = {}

function P.InitializeSeatHandZones()
	S.UpdatedSeatedPlayerData()

	local seats = U.slice(Player.getColors(), 2, 6)
	-- log({SeatColors = seats})
	local players = S.getPlayers()

	local function initSeat(color)
		local angle = S.getPlayerAngle(color)
		local handTransform = OU.RotateByAngle(U.clone(C.BaseHandTransform), angle)
		local hZone = U.getHandZone(color)
		if hZone == nil then
			U.RunSequence({
				function()
					return spawnObjectData({
						data = {
							Name = "HandTrigger",
							FogColor = color,
							Transform = OU.unfoldTransform(handTransform)
						}
					})
				end,
				function()
					Player[color].setHandTransform(handTransform)
				end
			})
		else
			Player[color].setHandTransform(handTransform)
		end

		P.SetCamera("BehindScreen", color)
	end

	seats = Player.getAvailableColors()
	U.Assert("P.UpdatePlayerSeats - #seats", #seats >= 3 and #seats <= 5)
	U.Assert("P.UpdatePlayerSeats - Requires between three and five seated players.", #players >= 3 and #players <= 5)

	if #players < #seats then
		local excessSeats = U.slice(seats, #players + 1, #seats)
		seats = U.slice(seats, 1, #players)
		U.forEach(excessSeats, function(sColor)
			U.getHandZone(sColor).destruct()
		end)
	end

	U.iForEach(seats, function(sColor) initSeat(sColor) end)
end

function P.ClearSeat(color)
	if color == nil then return U.forEach(Player.getAvailableColors(), P.ClearSeat) end
	local playerObjects = getObjectsWithTag(color)
	local playerZones = U.filter(getObjects(), function(obj) return obj.getGMNotes() == "ZonePlayer" .. color end)

	-- destroy POWER
	-- destroy COIN
	-- recover SECRET AGENDA
	-- unassign LEADER or MODERATOR


	U.forEach(U.concat(playerObjects, playerZones), function(obj)
		if obj.hasTag("HouseCard") then
			obj.setTags({"HouseCard"})
			obj.setPosition(C.Spots.Storage.HouseCard.position)
			obj.setRotation(C.Spots.Storage.HouseCard.rotation)
			obj.setScale(C.Spots.Storage.HouseCard.scale)
		else
			obj.destruct()
		end
	end)
end
function P.ClearSeats() U.forEach(Player.getAvailableColors(), P.ClearSeat); return 2 end

function P.getRotatedPlayerTransform(objOrTransform, player, fromAngle)
	objOrTransform = U.clone(objOrTransform, true)
	objOrTransform = OU.foldTransform(objOrTransform)
	if fromAngle == nil then
		fromAngle = OU.GetNearestAngle(objOrTransform, S.getSeatAngles())
	end
	local toAngle = S.getPlayerAngle(player)
	return OU.RotateByAngle(objOrTransform, toAngle - fromAngle)
end

function P.RotateToPlayer(objs, player, fromAngle, fromTransform, totalTime)
	if totalTime == nil then totalTime = 2 end
	if U.Type(objs) ~= "table" then objs = {objs} end

	return U.map(objs, function(obj)
		local startPos = obj.getPosition()
		local toData = P.getRotatedPlayerTransform(fromTransform or obj, player, fromAngle)
		local endPos, endRot = toData.position, toData.rotation
		local raiseTime, travelTime = totalTime / 4, totalTime / 2

		return U.RunSequence({
			function()
				U.setRotationSlow(obj, endRot, totalTime)
				return U.setPositionSlow(obj, Vector(startPos):add(Vector(0, 2, 0)), raiseTime)
			end,
			function()
				return U.setPositionSlow(obj, Vector(endPos):add(Vector(0, 2, 0)), travelTime)
			end,
			function()
				return U.setPositionSlow(obj, endPos, raiseTime)
			end
		})
	end)
end


function P.SetHouseCards(mode, playerRef)
	if playerRef == nil then U.forEach(S.getPlayers(), function(player) P.SetHouseCards(mode, player) end) end
	local player = S.getPlayer(playerRef)
	if player == nil then return end
	local HOUSECARDMODES = {
		UPRIGHT = {
			screenFlapLeft = {
				position = {9.10, 6.47, 41.09},
				rotation = {87.76, 180.00, 45.00},
				scale = {5, 1, 5}
			},
			screenFlapRight = {
				position = {-9.26, 6.47, 40.97},
				rotation = {87.76, 180.00, 135.00},
				scale = {5, 1, 5}
			},
			screenCenter = {
				position = {0.00, 6.51, 40.00},
				rotation = {87.76, 180.00, 0.00},
				scale = {5, 1, 5},
				uiPosition = "0 -100 -100",
				uiRotation = "12 0 180"
			},
			HouseCard = {
				position = {0.00, 7.52, 40.95},
				rotation = {83.90, 0.00, 0},
				scale = {3.75, 1.00, 3.75}
			},
			agendaCard = {
				tags = {"Private", "SecretAgenda"},
				position = Vector({10.00, 7.00, 42.50}),
				rotation = Vector({87.76, 0.00, 45.00}),
				scale = Vector({1.59, 1.00, 1.59})
			},
			RefDilemma = {
				position = Vector({0.00, 8.27, 41.20}),
				rotation = Vector({83.90, 0, 0}),
				scale = Vector({2, 1.00, 2})
			}
		},
		HIDDEN = {
			screenFlapLeft = {
				position = {9.10, 6.47, 41.09},
				rotation = {87.76, 180.00, 45.00},
				scale = {5, 1, 5}
			},
			screenFlapRight = {
				position = {-9.26, 6.47, 40.97},
				rotation = {87.76, 180.00, 135.00},
				scale = {5, 1, 5}
			},
			screenCenter = {
				position = {0.00, 6.51, 40.00},
				rotation = {87.76, 180.00, 0.00},
				scale = {5, 1, 5},
				uiPosition = "0 -100 -100",
				uiRotation = "12 0 180"
			},
			HouseCard = {
				position = {0.00, 7.52, 40.95},
				rotation = {83.90, 180, 0},
				scale = {3.75, 1.00, 3.75}
			},
			agendaCard = {
				tags = {"Private", "SecretAgenda"},
				position = Vector({10.00, -7.00, 42.50}),
				rotation = Vector({87.76, 0.00, 45.00}),
				scale = Vector({1.59, 1.00, 1.59})
			},
			RefDilemma = {
				position = Vector({0.00, 8.27, 41.20}),
				rotation = Vector({83.90, 0, 0}),
				scale = Vector({2, 1.00, 2})
			}
		},
		-- Position: (neg, ~, neg),
		-- Rotation: (~, +180, ~)
		CONCEALED = {
			screenFlapLeft = {
				position = {9.10, 6.47, 41.09},
				rotation = {87.76, 180.00, 45.00},
				scale = {5, 1, 5}
			},
			screenFlapRight = {
				position = {-9.26, 6.47, 40.97},
				rotation = {87.76, 180.00, 135.00},
				scale = {5, 1, 5}
			},
			screenCenter = {
				position = {0.00, 6.51, 40.00},
				rotation = {87.76, 180.00, 0.00},
				scale = {5, 1, 5},
				uiPosition = "0 -100 -100",
				uiRotation = "12 0 180"
			},
			houseCard = {
				position = {0.00, 3.7, 40.95},
				rotation = {83.90, 0.00, 80},
				scale = {3.75, 1.00, 3.75}
			},
			agendaCard = {
				position = Vector({10.00, -1, 42.50}),
				rotation = Vector({87.76, 0.00, 45.00}),
				scale = Vector({1.59, 1.00, 1.59})
			},
			referenceDilemma = {
				position = Vector({0.00, 8.27, 41.20}),
				rotation = Vector({83.90, 0, 0}),
				scale = Vector({2, 1.00, 2})
			}
		},
		-- Position: (neg, ~, neg),
		-- Rotation: (~, +180, ~)
		LOWERED = {
			screenFlapLeft = {
				position = {9.10, -0.77, 39.12},
				rotation = {87.76, 180.00, 45.00},
				scale = {5, 1, 5}
			},
			screenFlapRight = {
				position = {-9.26, -0.77, 39},
				rotation = {87.76, 180.00, 135.00},
				scale = {5, 1, 5}
			},
			screenCenter = {
				position = {0.00, -0.73, 38.03},
				rotation = {87.76, 180.00, 0.00},
				scale = {5, 1, 5},
				uiID = "rootPanel",
				uiPosition = "0 100 -100",
				uiRotation = "12 0 180"
			},
			houseCard = {
				position = {-16.00, 2.11, 46.94},
				rotation = {11.58, 55.80, 0.00},
				scale = {3.75, 1.00, 3.75}
			},
			agendaCard = {
				position = Vector({11.77, 2.95, 44.39}),
				rotation = Vector({47.90, 317.15, 0.49}),
				scale = Vector({1.59, 1.00, 1.59})
			},
			referenceDilemma = {
				position = Vector({0.00, 3.93, -38.84}),
				rotation = Vector({83.90, 0, 0}),
				scale = Vector({2, 1.00, 2})
			}
		}
	}
	if mode == nil or HOUSECARDMODES[mode] == nil then return end

	local objData = U.clone(HOUSECARDMODES[mode])
	local pColor = player.color

	U.forEach(objData, function(oData, oName)
		local tags = {pColor}
		if oData.tags then
			tags = U.concat(tags, oData.tags)
		else
			table.insert(tags, oName)
		end

		local objs = getObjectsWithAllTags(tags);
		if #objs == 0 then return nil end
		if #objs > 1 then return U.AlertGM("Too Many Objects found with tags " .. tags) end

		local obj = objs[1]

		local posData = P.getRotatedPlayerTransform({
			position = oData.position,
			rotation = oData.rotation,
			scale = oData.scale
		}, player, 0)

		if oData.position then U.setPositionSlow(obj, posData.position) end
		if oData.rotation then U.setRotationSlow(obj, posData.rotation) end
		if oData.scale then U.setScaleSlow(obj, posData.scale) end

		if oData.uiID then
			local attributes = {}
			if oData.uiPosition then
				attributes.position = oData.uiPosition
			end
			if oData.uiRotation then
				attributes.rotation = oData.uiRotation
			end
			if oData.uiScale then
				attributes.scale = oData.uiScale
			end
			obj.UI.setAttributes(oData.uiID, attributes)
		end
	end)





end

function P.AssignOpenSeat(player) player.changeColor(S.getOpenColors()[1]) end

function P.AssignPlayerColors(isNotShuffling)
	if S.isInMode(C.Modes.NONE) then
		U.forEach(U.getKeys(S.getStateVal("playerStorage")), function(pID) S.setStateVal(nil, "playerStorage", pID, "curColor") end)
		local players = U.slice(Player.getPlayers(), 1, 5)
		local seatColors = U.slice(Player.getColors(), 2, #players + 1)
		if isNotShuffling ~= true then
			U.shuffle(seatColors)
		end
		return U.RunSequence({
			function()
				return U.sequence(U.map(Player.getPlayers(), function(player) return function() player.changeColor("Grey") end end), 0.5)
			end,
			function()
				return U.sequence(U.map(players, function(player) return function()
					local pColor = U.shift(seatColors)
					S.setPlayerVal(pColor, player, "curColor")
					player.changeColor(pColor)
				end
			end), 0.75)
		end})
	else
		local players = Player.getPlayers()
		return U.RunSequence({
			function()
				return U.sequence(U.map(players, function(player) return function() player.changeColor("Grey") end end), 0.5)
			end,
			function()
				return U.sequence(U.map(players, function(player)
					local storedColor = S.getPlayerVal(player, "curColor")
					if storedColor == nil then
						return error("Colors must be stored in state before they can be reassigned mid-game!")
					end
					return function() player.changeColor(storedColor) end
				end), 0.75)
			end
		})
	end
end

function P.SetCamera(cameraMode, playerRef, playerCamRef)
	if playerRef == nil then return U.map(S.getPlayers(), function(player) return P.SetCamera(cameraMode, player) end) end

	local player = S.getPlayer(playerRef)
	local playerCam = player
	if playerCamRef then
		playerCam = S.getPlayer(playerCamRef)
	end
	local cameraData = U.clone(C.CameraAngles[cameraMode])

	U.Val("P.SetCamera", cameraMode, cameraData ~= nil, "Not a valid camera mode")

	if cameraData.isPlayerAngle and S.getPlayerAngle(player) then
		cameraData.position = Vector(cameraData.position):rotateOver("y", S.getPlayerAngle(player))
		cameraData.yaw = S.getPlayerAngle(player) + cameraData.yaw
		cameraData.isPlayerAngle = nil
	end

	-- log(cameraData)
	playerCam.setCameraMode("ThirdPerson")
	playerCam.lookAt(cameraData)
	playerCam.setCameraMode("ThirdPerson")
	return 0.5
end

function P.DealAll(cards, playerRef)
	local player = S.getPlayer(playerRef)
	U.Val("P.DealAll", cards, U.Type(cards) == "table" or (U.Type(cards) == "userdata" and (cards.type == "Deck" or cards.type == "Card")))

	local function dealNextCard()
		if U.Type(cards) == "table" then
			if #cards > 0 then
				local card = U.shift(cards)
				card.deal(1, player.color)
			end
		elseif cards.type == "Deck" then
			cards.deal(1, player.color)
			if cards.remainder ~= nil then
				cards = {cards.remainder}
			end
		end
		return 0.5
	end

	local numCards
	if U.Type(cards) == "table" then numCards = #cards
	elseif cards.type == "Deck" then numCards = #cards.getObjects()
	else return error("P.DealAll: Must submit a deck, a card, or a table of cards.") end

	-- log({cards, player.color, numCards})

	local seqFuncs = {}

	for i = 1, numCards do
		table.insert(seqFuncs, dealNextCard)
	end

	U.RunSequence(seqFuncs)

	return U.sequence(seqFuncs, 0.25)
end

function P.GetPlayerName(playerRef)
	if S.getPlayerVal(playerRef, "houseName") then
		return "House " .. S.getPlayerVal(playerRef, "houseName")
	else
		return S.getPlayerVal(playerRef, "house")
	end
end

function P.GetMostPrestigious()
	local prestigeData = U.map(S.getPlayers(), function(player)
		return {
			player = player,
			prestige = S.getPlayerVal(player, "prestige")
		}
	end)
	table.sort(prestigeData, function(a, b) return a.prestige > b.prestige end)
	return prestigeData[1].player
end

function P.GetLeastPrestigious()
	local prestigeData = U.map(S.getPlayers(), function(player)
		return {
			player = player,
			prestige = S.getPlayerVal(player, "prestige")
		}
	end)
	table.sort(prestigeData, function(a, b) return a.prestige < b.prestige end)
	return prestigeData[1].player
end

function P.GetNextLeastPrestigious(playerRef)
	local refPlayer = S.getPlayer(playerRef)
	local refPrestige = S.getPlayerVal(refPlayer, "prestige")
	local lesserPlayers = U.filter(S.getPlayers(), function(player) return S.getPlayerVal(player, "prestige") > refPrestige end)
	if #lesserPlayers == 0 then return false end
	local prestigeData = U.map(lesserPlayers, function(player)
		return {
			player = player,
			prestige = S.getPlayerVal(player, "prestige")
		}
	end)
	table.sort(prestigeData, function(a, b) return a.prestige < b.prestige end)
	return prestigeData[1].player
end

function P.AssignLeader(playerRef)
	if playerRef == nil then return P.AssignLeader(P.GetMostPrestigious()) end
	local player = S.getPlayer(playerRef)
	S.setStateVal(player.color, "gameState", "leader")
	return {
		P.RotateToPlayer(O.Leader.Figure(), player, 0, C.Spots.Storage.LeaderFigure, 1),
		P.RotateToPlayer(O.Leader.Light(), player, 0, C.Spots.Storage.LeaderLight, 1)
	}
end

function P.AssignModerator(playerRef)
	if playerRef == nil then return P.AssignModerator(P.GetLeastPrestigious()) end
	local player = S.getPlayer(playerRef)
	S.setStateVal(player.color, "gameState", "moderator")
	return {
		P.RotateToPlayer(O.Moderator.Figure(), player, 0, C.Spots.Storage.ModeratorFigure, 1),
		P.RotateToPlayer(O.Moderator.Light(), player, 0, C.Spots.Storage.ModeratorLight, 1)
	}
end

function P.GetLeader() return S.getPlayer(S.getStateVal("gameState", "leader")) or P.GetMostPrestigious() end
function P.GetModerator() return S.getPlayer(S.getStateVal("gameState", "moderator")) or P.GetLeastPrestigious() end
function P.GetLeaderName() return P.GetPlayerName(P.GetLeader()) end
function P.GetModeratorName() return P.GetPlayerName(P.GetModerator()) end


function P.GetPlayerZone(playerRef, zoneRef)
	local playerColor = S.getPlayer(playerRef).color
	if zoneRef == "Aye" then
		return getObjectsWithAllTags({playerColor, "Zone_VoteAye"})[1]
	elseif zoneRef == "Nay" then
		return getObjectsWithAllTags({playerColor, "Zone_VoteNay"})[1]
	elseif zoneRef == "Pass" then
		return getObjectsWithAllTags({playerColor, "Zone_VotePass"})[1]
	elseif zoneRef == "Power" then
		return getObjectsWithAllTags({playerColor, "zonePrivatePower"})[1]
	elseif zoneRef == "Coin" then
		return getObjectsWithAllTags({playerColor, "zonePrivateCoin"})[1]
	elseif zoneRef == "Public" then
		return getObjectsWithAllTags({playerColor, "Zone_PublicUI"})[1]
	end
end

function P.GetPlayerCard(playerRef)
	local player = S.getPlayer(playerRef)
	U.Val("P.GetPlayerCard()", playerRef, U.isPlayer(player), "Not a player")
	return getObjectsWithAllTags({"HouseCard", player.color})[1]
end

function P.GetPlayerScreen(playerRef)
	local player = S.getPlayer(playerRef)
	U.Val("P.GetPlayerScreen()", playerRef, U.isPlayer(player), "Not a player")
	return getObjectsWithAllTags({"screenCenter", player.color})[1]
end

function P.ActivatePlayerScreenHUD(playerRef)
	if playerRef == nil then return U.map(S.getPlayers(), P.ActivatePlayerScreenHUD) end
	local houseScreen = P.GetPlayerScreen(playerRef)
	if houseScreen == nil then return 0 end
	houseScreen.call("Activate")
	return 0.5
end

function P.RefreshPlayerScreenHUD(playerRef)
	if playerRef == nil then return U.map(S.getPlayers(), P.RefreshPlayerScreenHUD) end
	local houseScreen = P.GetPlayerScreen(playerRef)
	if houseScreen == nil then return 0 end
	return U.RunSequence({
		function()
			houseScreen.call("Update")
			return 1
		end,
		function()
			houseScreen.call("Refresh")
			return 0.5
		end
	})
end

function P.InitPlayerHouseCards(playerRef)
	if playerRef == nil then return U.map(S.getPlayers(), P.InitPlayerHouseCards) end
	local houseCard = P.GetPlayerCard(playerRef)
	if houseCard == nil then return 0 end
	Wait.time(function() houseCard.call("Initialize") end, 2)
	-- houseCard.call("Initialize")
	return 0.5
end

function P.GetOpenAgendas(playerRef)
	local openAgendas = S.getPlayerVal(playerRef, "openAgendas")
	local oData = {}
	U.forEach(openAgendas.positive, function(resource)
		table.insert(oData, {resource = resource, status = "Pos"})
	end)
	U.forEach(openAgendas.negative, function(resource)
		table.insert(oData, {resource = resource, status = "Neg"})
	end)
	return oData
end

function P.SpawnPower(playerRef, numPower) return OU.SpawnValue(P.GetPlayerZone(playerRef, "Power"), numPower * 1, "PowerToken") end
function P.TakePower(playerRef, numPower) return OU.TakeValue(P.GetPlayerZone(playerRef, "Power"), numPower * 1, "PowerToken") end
function P.SpawnCoins(playerRef, numCoins) return OU.SpawnValue(P.GetPlayerZone(playerRef, "Coin"), numCoins * 1, "CoinToken") end
function P.TakeCoins(playerRef, numCoins) return OU.TakeValue(P.GetPlayerZone(playerRef, "Coin"), numCoins * 1, "CoinToken") end
function P.TransferPower(fromPlayerRef, toPlayerRef, numPower)
	return OU.TransferValue(
		P.GetPlayerZone(fromPlayerRef, "Power"),
		P.GetPlayerZone(toPlayerRef, "Power"),
		numPower,
		"PowerToken"
	)
end
function P.TransferCoins(fromPlayerRef, toPlayerRef, numCoins)
	return OU.TransferValue(
		P.GetPlayerZone(fromPlayerRef, "Coin"),
		P.GetPlayerZone(toPlayerRef, "Coin"),
		numCoins,
		"CoinToken"
	)
end

function P.InitOfferZones(playerRef)
	-- spawn in offer zones and lights
	-- offer zones:
	--	- when coin put in, light brightens, and ReceiveZone spawned in for receiving player, with copy of offer, including display
	-- 	- any number of players can do this
	-- receive zone:
	--  - when any amount is removed from a zone, the deal is over
	--			- splash message: "House X accepts House Y's Proposal for Z Coin"
	--  - all coins in other receive zones for that player are returned to their owners



end

function P.PromptOffer(playerRef)

end

function P.AcceptOffer(playerRef)


end

return P