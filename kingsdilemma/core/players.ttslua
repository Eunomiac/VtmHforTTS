local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
local C = require("kingsdilemma.lib.constants")
local O = require("kingsdilemma.lib.objects")
local OU = require("kingsdilemma.objects.objUtilities")

local P = {}

function P.InitializeSeats()
	S.UpdateSeatedPlayers()

	local seats = U.slice(Player.getColors(), 2, 6)
	log({SeatColors = seats})
	local players = S.getPlayers()

	local function initSeat(color)
		local angle = S.getPlayerAngle(color)
		local handTransform = OU.RotateByAngle(U.clone(C.BaseHandTransform), angle)
		local hZone = U.getHandZone(color)
		if hZone == nil then
			U.RunSequence({
				function()
					return spawnObjectData({
						data = {
							Name = "HandTrigger",
							FogColor = color,
							Transform = OU.unfoldTransform(handTransform)
						}
					})
				end,
				function()
					Player[color].setHandTransform(handTransform)
				end
			})
		else
			Player[color].setHandTransform(handTransform)
		end
	end

	seats = Player.getAvailableColors()
	U.Assert("P.UpdatePlayerSeats - #seats", #seats >= 3 and #seats <= 5)
	U.Assert("P.UpdatePlayerSeats - Requires between three and five seated players.", #players >= 3 and #players <= 5)

	if #players < #seats then
		local excessSeats = U.slice(seats, #players + 1, #seats)
		U.forEach(excessSeats, function(sColor)
			U.getHandZone(sColor).destruct()
		end)
	end

	U.iForEach(seats, function(sColor) initSeat(sColor) end)
end

function P.ClearSeat(color)
	if color == nil then return U.forEach(C.SeatColors, P.ClearSeat) end
	local playerObjects = getObjectsWithTag(color)
	local playerZones = U.filter(getObjects(), function(obj) return obj.getGMNotes() == "ZonePlayer" .. color end)

	U.forEach(U.concat(playerObjects, playerZones), function(obj)
		if obj.hasTag("HouseCard") then
			obj.setTags({"HouseCard"})
			obj.setPosition(C.Spots.Storage.HouseCard.position)
			obj.setRotation(C.Spots.Storage.HouseCard.rotation)
			obj.setScale(C.Spots.Storage.HouseCard.scale)
		else
			obj.destruct()
		end
	end)
end
function P.ClearSeats() return U.forEach(C.SeatColors, P.ClearSeat) end

function P.getRotatedPlayerTransform(objOrTransform, player, fromAngle)
	objOrTransform = OU.foldTransform(objOrTransform)
	if fromAngle == nil then
		fromAngle = OU.GetNearestPlayerAngle(objOrTransform)
	end
	local toAngle = S.getPlayerAngle(player)
	return OU.RotateByAngle(objOrTransform, toAngle - fromAngle)
end

function P.RotateToPlayer(objs, player)
	if type(objs) ~= "table" then objs = {objs} end

	U.forEach(objs, function(obj)
		local startPos = obj.getPosition()
		local toData = P.getRotatedPlayerTransform(obj, player)
		local endPos, endRot = toData.position, toData.rotation

		U.RunSequence({
			function()
				obj.setPositionSmooth(Vector(startPos):add(Vector(0, 2, 0)))
				return obj
			end,
			function()
				obj.setPositionSmooth(Vector(endPos):add(Vector(0, 2, 0)), false, false)
				obj.setRotationSmooth(endRot, false, false)
				return obj
			end,
			function()
				obj.setPositionSmooth(endPos)
				return obj
			end
		})
	end)
end

function P.AssignTitle(playerNum, title)
	if playerNum == nil or playerNum < 1 or playerNum > 5 then return end
	if title == "Moderator" then


	elseif title == "Leader" then

	end
end



return P