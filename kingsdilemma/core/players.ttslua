local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
local C = require("kingsdilemma.lib.constants")
local O = require("kingsdilemma.lib.objects")
local OU = require("kingsdilemma.objects.objUtilities")

local P = {}

function P.InitializeSeatHandZones()
	S.UpdatedSeatedPlayerData()

	local seats = U.slice(Player.getColors(), 2, 6)
	-- log({SeatColors = seats})
	local players = S.getPlayers()

	local function initSeat(color)
		local angle = S.getPlayerAngle(color)
		local handTransform = OU.RotateByAngle(U.clone(C.BaseHandTransform), angle)
		local hZone = U.getHandZone(color)
		if hZone == nil then
			U.RunSequence({
				function()
					return spawnObjectData({
						data = {
							Name = "HandTrigger",
							FogColor = color,
							Transform = OU.unfoldTransform(handTransform)
						}
					})
				end,
				function()
					Player[color].setHandTransform(handTransform)
				end
			})
		else
			Player[color].setHandTransform(handTransform)
		end

		P.SetCamera("BehindScreen", color)
	end

	seats = Player.getAvailableColors()
	U.Assert("P.UpdatePlayerSeats - #seats", #seats >= 3 and #seats <= 5)
	U.Assert("P.UpdatePlayerSeats - Requires between three and five seated players.", #players >= 3 and #players <= 5)

	if #players < #seats then
		local excessSeats = U.slice(seats, #players + 1, #seats)
		seats = U.slice(seats, 1, #players)
		U.forEach(excessSeats, function(sColor)
			U.getHandZone(sColor).destruct()
		end)
	end

	U.iForEach(seats, function(sColor) initSeat(sColor) end)
end

function P.ClearSeat(color)
	if color == nil then return U.forEach(Player.getAvailableColors(), P.ClearSeat) end
	local playerObjects = getObjectsWithTag(color)
	local playerZones = U.filter(getObjects(), function(obj) return obj.getGMNotes() == "ZonePlayer" .. color end)

	-- destroy POWER
	-- destroy COIN
	-- recover SECRET AGENDA
	-- unassign LEADER or MODERATOR


	U.forEach(U.concat(playerObjects, playerZones), function(obj)
		if obj.hasTag("HouseCard") then
			obj.setTags({"HouseCard"})
			obj.setPosition(C.Spots.Storage.HouseCard.position)
			obj.setRotation(C.Spots.Storage.HouseCard.rotation)
			obj.setScale(C.Spots.Storage.HouseCard.scale)
		else
			obj.destruct()
		end
	end)
end
function P.ClearSeats() U.forEach(Player.getAvailableColors(), P.ClearSeat); return 2 end

function P.getRotatedPlayerTransform(objOrTransform, player, fromAngle)
	objOrTransform = U.clone(objOrTransform, true)
	objOrTransform = OU.foldTransform(objOrTransform)
	if fromAngle == nil then
		fromAngle = OU.GetNearestAngle(objOrTransform, S.getSeatAngles())
	end
	local toAngle = S.getPlayerAngle(player)
	return OU.RotateByAngle(objOrTransform, toAngle - fromAngle)
end

function P.RotateToPlayer(objs, player, fromAngle, fromTransform, totalTime)
	if totalTime == nil then totalTime = 2 end
	if U.Type(objs) ~= "table" then objs = {objs} end

	return U.map(objs, function(obj)
		local startPos = obj.getPosition()
		local toData = P.getRotatedPlayerTransform(fromTransform or obj, player, fromAngle)
		local endPos, endRot = toData.position, toData.rotation
		local raiseTime, travelTime = totalTime / 4, totalTime / 2

		return U.RunSequence({
			function()
				U.setRotationSlow(obj, endRot, totalTime)
				return U.setPositionSlow(obj, Vector(startPos):add(Vector(0, 2, 0)), raiseTime)
			end,
			function()
				return U.setPositionSlow(obj, Vector(endPos):add(Vector(0, 2, 0)), travelTime)
			end,
			function()
				return U.setPositionSlow(obj, endPos, raiseTime)
			end
		})
	end)
end

function P.AssignOpenSeat(player) player.changeColor(S.getOpenColors()[1]) end

function P.AssignPlayerColors(isNotShuffling)
	if S.isInMode(C.Modes.NONE) then
		U.forEach(U.getKeys(S.getStateVal("playerStorage")), function(pID) S.setStateVal(nil, "playerStorage", pID, "curColor") end)
		local players = U.slice(Player.getPlayers(), 1, 5)
		local seatColors = U.slice(Player.getColors(), 2, #players + 1)
		if isNotShuffling ~= true then
			U.shuffle(seatColors)
		end
		return U.RunSequence({
			function()
				return U.sequence(U.map(Player.getPlayers(), function(player) return function() player.changeColor("Grey") end end), 0.5)
			end,
			function()
				return U.sequence(U.map(players, function(player) return function()
					local pColor = U.shift(seatColors)
					S.setPlayerVal(pColor, player, "curColor")
					player.changeColor(pColor)
				end
			end), 0.75)
		end})
	else
		local players = Player.getPlayers()
		return U.RunSequence({
			function()
				return U.sequence(U.map(players, function(player) return function() player.changeColor("Grey") end end), 0.5)
			end,
			function()
				return U.sequence(U.map(players, function(player)
					local storedColor = S.getPlayerVal(player, "curColor")
					if storedColor == nil then
						return error("Colors must be stored in state before they can be reassigned mid-game!")
					end
					return function() player.changeColor(storedColor) end
				end), 0.75)
			end
		})
	end
end

function P.SetCamera(cameraMode, playerRef, playerCamRef)
	if playerRef == nil then return U.map(S.getPlayers(), function(player) return P.SetCamera(cameraMode, player) end) end

	local player = S.getPlayer(playerRef)
	local playerCam = player
	if playerCamRef then
		playerCam = S.getPlayer(playerCamRef)
	end
	local cameraData = U.clone(C.CameraAngles[cameraMode])

	U.Val("P.SetCamera", cameraMode, cameraData ~= nil, "Not a valid camera mode")

	if cameraData.isPlayerAngle and S.getPlayerAngle(player) then
		cameraData.position = Vector(cameraData.position):rotateOver("y", S.getPlayerAngle(player))
		cameraData.yaw = S.getPlayerAngle(player) + cameraData.yaw
		cameraData.isPlayerAngle = nil
	end

	-- log(cameraData)
	playerCam.setCameraMode("ThirdPerson")
	playerCam.lookAt(cameraData)
	playerCam.setCameraMode("ThirdPerson")
	return 0.5
end

function P.DealAll(cards, playerRef)
	local player = S.getPlayer(playerRef)
	U.Val("P.DealAll", cards, U.Type(cards) == "table" or (U.Type(cards) == "userdata" and (cards.type == "Deck" or cards.type == "Card")))

	local function dealNextCard()
		if U.Type(cards) == "table" then
			if #cards > 0 then
				local card = U.shift(cards)
				card.deal(1, player.color)
			end
		elseif cards.type == "Deck" then
			cards.deal(1, player.color)
			if cards.remainder ~= nil then
				cards = {cards.remainder}
			end
		end
		return 0.5
	end

	local numCards
	if U.Type(cards) == "table" then numCards = #cards
	elseif cards.type == "Deck" then numCards = #cards.getObjects()
	else return error("P.DealAll: Must submit a deck, a card, or a table of cards.") end

	-- log({cards, player.color, numCards})

	local seqFuncs = {}

	for i = 1, numCards do
		table.insert(seqFuncs, dealNextCard)
	end

	U.RunSequence(seqFuncs)

	return U.sequence(seqFuncs, 0.25)
end

function P.GetPlayerName(playerRef)
	if S.getPlayerVal(playerRef, "houseName") then
		return "House " .. S.getPlayerVal(playerRef, "houseName")
	else
		return S.getPlayerVal(playerRef, "house")
	end
end

function P.GetMostPrestigious()
	local prestigeData = U.map(S.getPlayers(), function(player)
		return {
			player = player,
			prestige = S.getPlayerVal(player, "prestige")
		}
	end)
	table.sort(prestigeData, function(a, b) return a.prestige > b.prestige end)
	return prestigeData[1].player
end

function P.GetLeastPrestigious()
	local prestigeData = U.map(S.getPlayers(), function(player)
		return {
			player = player,
			prestige = S.getPlayerVal(player, "prestige")
		}
	end)
	table.sort(prestigeData, function(a, b) return a.prestige < b.prestige end)
	return prestigeData[1].player
end

function P.GetNextLeastPrestigious(playerRef)
	local refPlayer = S.getPlayer(playerRef)
	local refPrestige = S.getPlayerVal(refPlayer, "prestige")
	local lesserPlayers = U.filter(S.getPlayers(), function(player) return S.getPlayerVal(player, "prestige") > refPrestige end)
	if #lesserPlayers == 0 then return false end
	local prestigeData = U.map(lesserPlayers, function(player)
		return {
			player = player,
			prestige = S.getPlayerVal(player, "prestige")
		}
	end)
	table.sort(prestigeData, function(a, b) return a.prestige < b.prestige end)
	return prestigeData[1].player
end

function P.AssignLeader(playerRef)
	if playerRef == nil then return P.AssignLeader(P.GetMostPrestigious()) end
	local player = S.getPlayer(playerRef)
	S.setStateVal(player.color, "gameState", "leader")
	return {
		P.RotateToPlayer(O.Leader.Figure(), player, 0, C.Spots.Storage.LeaderFigure, 1),
		P.RotateToPlayer(O.Leader.Light(), player, 0, C.Spots.Storage.LeaderLight, 1)
	}
end

function P.AssignModerator(playerRef)
	if playerRef == nil then return P.AssignModerator(P.GetLeastPrestigious()) end
	local player = S.getPlayer(playerRef)
	S.setStateVal(player.color, "gameState", "moderator")
	return {
		P.RotateToPlayer(O.Moderator.Figure(), player, 0, C.Spots.Storage.ModeratorFigure, 1),
		P.RotateToPlayer(O.Moderator.Light(), player, 0, C.Spots.Storage.ModeratorLight, 1)
	}
end

function P.GetLeader() return S.getPlayer(S.getStateVal("gameState", "leader")) or P.GetMostPrestigious() end
function P.GetModerator() return S.getPlayer(S.getStateVal("gameState", "moderator")) or P.GetLeastPrestigious() end
function P.GetLeaderName() return P.GetPlayerName(P.GetLeader()) end
function P.GetModeratorName() return P.GetPlayerName(P.GetModerator()) end


function P.GetPlayerZone(playerRef, zoneRef)
	local playerColor = S.getPlayer(playerRef).color
	if zoneRef == "Aye" then
		return getObjectsWithAllTags({playerColor, "Zone_VoteAye"})[1]
	elseif zoneRef == "Nay" then
		return getObjectsWithAllTags({playerColor, "Zone_VoteNay"})[1]
	elseif zoneRef == "Pass" then
		return getObjectsWithAllTags({playerColor, "Zone_VotePass"})[1]
	elseif zoneRef == "Power" then
		return getObjectsWithAllTags({playerColor, "zonePrivatePower"})[1]
	elseif zoneRef == "Coin" then
		return getObjectsWithAllTags({playerColor, "zonePrivateCoin"})[1]
	elseif zoneRef == "Public" then
		return getObjectsWithAllTags({playerColor, "Zone_PublicUI"})[1]
	end
end

function P.GetPlayerCard(playerRef)
	local player = S.getPlayer(playerRef)
	U.Val("P.GetPlayerCard()", playerRef, U.isPlayer(player), "Not a player")
	return getObjectsWithAllTags({"HouseCard", player.color})[1]
end

function P.GetPlayerScreen(playerRef)
	local player = S.getPlayer(playerRef)
	U.Val("P.GetPlayerScreen()", playerRef, U.isPlayer(player), "Not a player")
	return getObjectsWithAllTags({"screenCenter", player.color})[1]
end

function P.ActivatePlayerScreenHUD(playerRef)
	if playerRef == nil then return U.map(S.getPlayers(), P.ActivatePlayerScreenHUD) end
	local houseScreen = P.GetPlayerScreen(playerRef)
	if houseScreen == nil then return 0 end
	houseScreen.call("Activate")
	return 0.5
end

function P.RefreshPlayerScreenHUD(playerRef)
	if playerRef == nil then return U.map(S.getPlayers(), P.RefreshPlayerScreenHUD) end
	local houseScreen = P.GetPlayerScreen(playerRef)
	if houseScreen == nil then return 0 end
	return U.RunSequence({
		function()
			houseScreen.call("Update")
			return 1
		end,
		function()
			houseScreen.call("Activate")
			return 0.5
		end
	})
end

function P.InitPlayerHouseCards(playerRef)
	if playerRef == nil then return U.map(S.getPlayers(), P.InitPlayerHouseCards) end
	local houseCard = P.GetPlayerCard(playerRef)
	if houseCard == nil then return 0 end
	houseCard.call("Initialize")
	return 0.5
end

function P.GetOpenAgendas(playerRef)
	local openAgendas = S.getPlayerVal(playerRef, "openAgendas")
	local oData = {}
	U.forEach(openAgendas.positive, function(resource)
		table.insert(oData, {resource = resource, status = "Pos"})
	end)
	U.forEach(openAgendas.negative, function(resource)
		table.insert(oData, {resource = resource, status = "Neg"})
	end)
	return oData
end

function P.SpawnPower(playerRef, numPower) return OU.SpawnValue(P.GetPlayerZone(playerRef, "Power"), numPower, "PowerToken") end
function P.TakePower(playerRef, numPower) return OU.TakeValue(P.GetPlayerZone(playerRef, "Power"), numPower, "PowerToken") end
function P.SpawnCoins(playerRef, numCoins) return OU.SpawnValue(P.GetPlayerZone(playerRef, "Coin"), numCoins, "CoinToken") end
function P.TakeCoins(playerRef, numCoins) return OU.TakeValue(P.GetPlayerZone(playerRef, "Coin"), numCoins, "CoinToken") end
function P.TransferPower(fromPlayerRef, toPlayerRef, numPower)
	return OU.TransferValue(
		P.GetPlayerZone(fromPlayerRef, "Power"),
		P.GetPlayerZone(toPlayerRef, "Power"),
		numPower,
		"PowerToken"
	)
end
function P.TransferCoins(fromPlayerRef, toPlayerRef, numCoins)
	return OU.TransferValue(
		P.GetPlayerZone(fromPlayerRef, "Coin"),
		P.GetPlayerZone(toPlayerRef, "Coin"),
		numCoins,
		"CoinToken"
	)
end

return P