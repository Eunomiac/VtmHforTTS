local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
local C = require("kingsdilemma.lib.constants")
local O = require("kingsdilemma.lib.objects")
local OU = require("kingsdilemma.objects.objUtilities")

local P = {}

function P.InitializeSeats(isFullyRestoring, isFullyResetting)
	local seats = U.slice(Player.getColors(), 2, 6)
	local players = S.getPlayers()

	local function initSeat(color, countOverride)
		local count = countOverride or #players
		local playerNum = U.findIndex(Player.getColors(), function(col) return col == color end) - 1
		local angle = C.SeatAngles[count][playerNum]
		local handTransform = OU.RotateByAngle(U.clone(C.BaseHandTransform), angle)
		local hZone = U.getHandZone(color)
		if hZone == nil then
			spawnObjectData({
				data = {
					Name = "HandTrigger",
					FogColor = color,
					-- GMNotes = "ZonePlayer" .. C.SeatColors[i],
					Transform = OU.unfoldTransform(handTransform)
				},
				callback_function = function()
					U.waitUntil(function()
						Player[color].setHandTransform(handTransform)
					end, {
						function() return Player[color].getHandCount() > 0 end,
						3
					})
				end
			})
		else
			Player[color].setHandTransform(handTransform)
		end
	end

	if isFullyResetting then
		return U.sequence({
			function() U.forEach(Hands.getHands(), function(hZone) hZone.destruct() end) end,
			function() P.InitializeSeats(isFullyRestoring, false) end
		}, 1)
	end

	if isFullyRestoring then
		U.iForEach(seats, function(seat) initSeat(seat, 5) end)
		return
	end

	seats = Player.getAvailableColors()
	U.Assert("P.UpdatePlayerSeats - #seats", #seats >= 3 and #seats <= 5)
	U.Assert("P.UpdatePlayerSeats - Requires between three and five seated players.", #players >= 3 and #players <= 5)

	if #players < #seats then
		local excessSeats = U.slice(seats, #players + 1, #seats)
		seats = U.slice(seats, 1, #players)
		U.forEach(excessSeats, function(sColor)
			U.getHandZone(sColor).destruct()
		end)
	end

	U.iForEach(seats, function(sColor) initSeat(sColor) end)
end

function P.ClearSeat(color)
	if color == nil then return U.forEach(C.SeatColors, P.ClearSeat) end
	local playerObjects = getObjectsWithTag(color)
	local playerZones = U.filter(getObjects(), function(obj) return obj.getGMNotes() == "ZonePlayer" .. color end)

	log(JSON.encode_pretty(U.map(playerZones, function (pZone) return {
		guid = pZone.getGUID(),
		name = pZone.getName()
	} end)))

	U.forEach(U.concat(playerObjects, playerZones), function(obj)
		if obj.hasTag("HouseCard") then
			obj.setTags({"HouseCard"})
			obj.setPosition(C.Spots.Storage.HouseCard.position)
			obj.setRotation(C.Spots.Storage.HouseCard.rotation)
			obj.setScale(C.Spots.Storage.HouseCard.scale)
		else
			obj.destruct()
		end
	end)
end
function P.ClearSeats() return U.forEach(C.SeatColors, P.ClearSeat) end

function P.getRotatedPlayerTransform(objOrTransform, player, fromAngle)
	objOrTransform = OU.foldTransform(objOrTransform)
	if fromAngle == nil then
		fromAngle = OU.GetNearestPlayerAngle(objOrTransform)
	end
	local toAngle = S.getPlayerAngle(player)
	return OU.RotateByAngle(objOrTransform, toAngle - fromAngle)
end

function P.RotateToPlayer(objs, player)
	if type(objs) ~= "table" then objs = {objs} end

	U.forEach(objs, function(obj)
		local startPos = obj.getPosition()
		local toData = P.getRotatedPlayerTransform(obj, player)
		local endPos, endRot = toData.position, toData.rotation

		U.RunSequence({
			function()
				obj.setPositionSmooth(startPos:add(Vector(0, 2, 0)))
				return obj
			end,
			function()
				obj.setPositionSmooth(Vector(endPos):add(Vector(0, 2, 0)), false, false)
				obj.setRotationSmooth(endRot, false, false)
				return obj
			end,
			function()
				obj.setPositionSmooth(endPos)
				return obj
			end
		})
	end)
end

function P.AssignTitle(playerNum, title)
	if playerNum == nil or playerNum < 1 or playerNum > 5 then return end
	if title == "Moderator" then


	elseif title == "Leader" then

	end
end



return P