local U = require("lib.utilities")
local S = require("kingsdilemma.core.state")
local C = require("kingsdilemma.lib.constants")
local O = require("kingsdilemma.lib.objects")
local OU = require("kingsdilemma.objects.objUtilities")

local P = {}

function P.InitializeSeats()
	S.UpdateSeatedPlayers()

	local seats = U.slice(Player.getColors(), 2, 6)
	-- log({SeatColors = seats})
	local players = S.getPlayers()

	local function initSeat(color)
		local angle = S.getPlayerAngle(color)
		local handTransform = OU.RotateByAngle(U.clone(C.BaseHandTransform), angle)
		local hZone = U.getHandZone(color)
		if hZone == nil then
			U.RunSequence({
				function()
					return spawnObjectData({
						data = {
							Name = "HandTrigger",
							FogColor = color,
							Transform = OU.unfoldTransform(handTransform)
						}
					})
				end,
				function()
					Player[color].setHandTransform(handTransform)
				end
			})
		else
			Player[color].setHandTransform(handTransform)
		end

		P.SetCamera("BehindScreen", color)
	end

	seats = Player.getAvailableColors()
	U.Assert("P.UpdatePlayerSeats - #seats", #seats >= 3 and #seats <= 5)
	U.Assert("P.UpdatePlayerSeats - Requires between three and five seated players.", #players >= 3 and #players <= 5)

	if #players < #seats then
		local excessSeats = U.slice(seats, #players + 1, #seats)
		seats = U.slice(seats, 1, #players)
		U.forEach(excessSeats, function(sColor)
			U.getHandZone(sColor).destruct()
		end)
	end

	U.iForEach(seats, function(sColor) initSeat(sColor) end)
end

function P.ClearSeat(color)
	if color == nil then return U.forEach(Player.getAvailableColors(), P.ClearSeat) end
	local playerObjects = getObjectsWithTag(color)
	local playerZones = U.filter(getObjects(), function(obj) return obj.getGMNotes() == "ZonePlayer" .. color end)

	U.forEach(U.concat(playerObjects, playerZones), function(obj)
		if obj.hasTag("HouseCard") then
			obj.setTags({"HouseCard"})
			obj.setPosition(C.Spots.Storage.HouseCard.position)
			obj.setRotation(C.Spots.Storage.HouseCard.rotation)
			obj.setScale(C.Spots.Storage.HouseCard.scale)
		else
			obj.destruct()
		end
	end)
end
function P.ClearSeats() return U.forEach(Player.getAvailableColors(), P.ClearSeat) end

function P.getRotatedPlayerTransform(objOrTransform, player, fromAngle)
	objOrTransform = U.clone(objOrTransform, true)
	objOrTransform = OU.foldTransform(objOrTransform)
	if fromAngle == nil then
		fromAngle = OU.GetNearestAngle(objOrTransform, S.getSeatAngles())
	end
	local toAngle = S.getPlayerAngle(player)
	return OU.RotateByAngle(objOrTransform, toAngle - fromAngle)
end

function P.RotateToPlayer(objs, player, fromAngle, fromTransform)
	if U.Type(objs) ~= "table" then objs = {objs} end

	return U.map(objs, function(obj)
		local startPos = obj.getPosition()
		local toData = P.getRotatedPlayerTransform(fromTransform or obj, player, fromAngle)
		local endPos, endRot = toData.position, toData.rotation

		return U.RunSequence({
			function()
				return U.setPositionSlow(obj, Vector(startPos):add(Vector(0, 2, 0)), 0.5)
			end,
			function()
				return {
					U.setPositionSlow(obj, Vector(endPos):add(Vector(0, 2, 0)), 1.5),
					U.setRotationSlow(obj, endRot, 1.5)
				}
			end,
			function()
				return U.setPositionSlow(obj, endPos, 0.5)
			end
		})
	end)
end

function P.SetCamera(cameraMode, playerRef, playerCamRef)
	if playerRef == nil then return U.map(S.getPlayers(), function(player) return P.SetCamera(cameraMode, player) end) end

	local player = S.getPlayer(playerRef)
	local playerCam = player
	if playerCamRef then
		playerCam = S.getPlayer(playerCamRef)
	end
	local cameraData = U.clone(C.CameraAngles[cameraMode])

	if cameraData.isPlayerAngle and S.getPlayerAngle(player) then
		cameraData.position = Vector(cameraData.position):rotateOver("y", S.getPlayerAngle(player))
		cameraData.yaw = S.getPlayerAngle(player) + cameraData.yaw
		cameraData.isPlayerAngle = nil
	end

	-- log(cameraData)
	playerCam.lookAt(cameraData)
	return 1
end

function P.DealAll(cards, playerRef)
	local player = S.getPlayer(playerRef)
	U.Val("P.DealAll", cards, U.Type(cards) == "table" or (U.Type(cards) == "userdata" and (cards.type == "Deck" or cards.type == "Card")))

	local function dealNextCard()
		if U.Type(cards) == "table" then
			if #cards > 0 then
				U.shift(cards).deal(1, player.color)
			end
		elseif cards.type == "Deck" then
			cards.deal(1, player.color)
			if cards.remainder ~= nil then
				cards = {cards.remainder}
			end
		end
		return 0.25
	end



	local numCards
	if U.Type(cards) == "table" then numCards = #cards
	elseif cards.type == "Deck" then numCards = #cards.getObjects()
	else return error("P.DealAll: Must submit a deck, a card, or a table of cards.") end

	log({cards, player.color, numCards})

	local seqFuncs = {}

	for i = 1, numCards do
		table.insert(seqFuncs, dealNextCard)
	end

	U.RunSequence(seqFuncs)

	return U.sequence(seqFuncs, 0.25)
end

function P.GetPlayerName(playerRef)
	if S.getPlayerVal(playerRef, "houseName") then
		return "House " .. S.getPlayerVal(playerRef, "houseName")
	else
		return S.getPlayerVal(playerRef, "house")
	end
end

function P.GetMostPrestigious()
	local prestigeData = U.map(S.getPlayers(), function(player)
		return {
			player = player,
			prestige = S.getPlayerVal(player, "prestige")
		}
	end)
	table.sort(prestigeData, function(a, b) return a.prestige > b.prestige end)
	return prestigeData[1].player
end

function P.GetLeastPrestigious()
	local prestigeData = U.map(S.getPlayers(), function(player)
		return {
			player = player,
			prestige = S.getPlayerVal(player, "prestige")
		}
	end)
	table.sort(prestigeData, function(a, b) return a.prestige < b.prestige end)
	return prestigeData[1].player
end

function P.GetNextLeastPrestigious(playerRef)
	local refPlayer = S.getPlayer(playerRef)
	local refPrestige = S.getPlayerVal(refPlayer, "prestige")
	local lesserPlayers = U.filter(S.getPlayers(), function(player) return S.getPlayerVal(player, "prestige") > refPrestige end)
	if #lesserPlayers == 0 then return false end
	local prestigeData = U.map(lesserPlayers, function(player)
		return {
			player = player,
			prestige = S.getPlayerVal(player, "prestige")
		}
	end)
	table.sort(prestigeData, function(a, b) return a.prestige < b.prestige end)
	return prestigeData[1].player
end

function P.AssignLeader(playerRef)
	local player = S.getPlayer(playerRef)
	S.setStateVal(player.color, "gameState", "leader")
	return {
		P.RotateToPlayer(O.Leader.Figure(), player, 0, C.Spots.Storage.LeaderFigure),
		P.RotateToPlayer(O.Leader.Light(), player, 0, C.Spots.Storage.LeaderLight)
	}
end

function P.AssignModerator(playerRef)
	local player = S.getPlayer(playerRef)
	S.setStateVal(player.color, "gameState", "moderator")
	return {
		P.RotateToPlayer(O.Moderator.Figure(), player, 0, C.Spots.Storage.ModeratorFigure),
		P.RotateToPlayer(O.Moderator.Light(), player, 0, C.Spots.Storage.ModeratorLight)
	}
end

function P.GetLeader() return S.getPlayer(S.getStateVal("gameState", "leader")) or P.GetMostPrestigious() end
function P.GetModerator() return S.getPlayer(S.getStateVal("gameState", "moderator")) or P.GetLeastPrestigious() end
function P.GetLeaderName() return P.GetPlayerName(P.GetLeader()) end
function P.GetModeratorName() return P.GetPlayerName(P.GetModerator()) end

function P.GetPlayerZone(playerRef, zoneRef)
	local playerColor = S.getPlayer(playerRef).color
	if zoneRef == "Aye" then
		return getObjectsWithAllTags({playerColor, "Zone_VoteAye"})[1]
	elseif zoneRef == "Nay" then
		return getObjectsWithAllTags({playerColor, "Zone_VoteNay"})[1]
	elseif zoneRef == "Pass" then
		return getObjectsWithAllTags({playerColor, "Zone_VotePass"})[1]
	elseif zoneRef == "Power" then
		return getObjectsWithAllTags({playerColor, "zonePrivatePower"})[1]
	elseif zoneRef == "Coin" then
		return getObjectsWithAllTags({playerColor, "zonePrivateCoin"})[1]
	elseif zoneRef == "Public" then
		return getObjectsWithAllTags({playerColor, "Zone_PublicUI"})[1]
	end
end

function P.GetPlayerCard(playerRef)
	local player = S.getPlayer(playerRef)
	U.Val("P.GetPlayerCard()", playerRef, U.isPlayer(player), "Not a player")
	return getObjectsWithAllTags({"HouseCard", player.color})[1]
end

function P.GetPlayerScreen(playerRef)
	local player = S.getPlayer(playerRef)
	U.Val("P.GetPlayerScreen()", playerRef, U.isPlayer(player), "Not a player")
	return getObjectsWithAllTags({"screenCenter", player.color})[1]
end

function P.ActivatePlayerScreenHUD(playerRef)
	if playerRef == nil then return U.map(S.getPlayers(), P.ActivatePlayerScreenHUD) end
	local houseScreen = P.GetPlayerScreen(playerRef)
	if houseScreen == nil then return 0 end
	houseScreen.call("Activate")
	return 0.5
end

local function spawnToken(objOrBounds, tokenType, tokenValue, yShift)
	if yShift == nil then yShift = 3 end
	local sourceObj
	if tokenType == "Power" then
		sourceObj = O.SpawnSources["powerToken" .. tokenValue]()
	elseif tokenType == "Coin" then
		sourceObj = O.SpawnSources["coinToken" .. tokenValue]()
	end
	local spawnData = sourceObj.getData()
	spawnData.Value = tokenValue
	spawnData.Transform = OU.unfoldTransform({
		position = U.getScatterPosition(objOrBounds, yShift, 0.3),
		rotation = U.isGameObject(objOrBounds) and objOrBounds.getRotation() or Vector(0, 0, 0),
		scale = sourceObj.getScale()
	})
	spawnData.Tags = {tokenType .. "Token", "Value" .. tokenValue}
	spawnObjectData({
		data = spawnData,
		callback_function = function(obj)
			obj.setLock(false)
		end
	})
	return 0.1
end

local function splitToken(token)
	local tokenPos = token.getPosition()
	if tokenPos.y < C.TableHeight + 1 then
		tokenPos:add(Vector(0, 3, 0))
	end

	if token.value == 10 then
		for i = 1, 2 do
			spawnToken({
				center = tokenPos,
				size = Vector(2, 0, 2)
			}, "Power", 5)
		end
		token.destruct()
	elseif token.value == 5 then
		for i = 1, 5 do
			spawnToken({
				center = tokenPos,
				size = Vector(2, 0, 2)
			}, "Power", 1)
		end
		token.destruct()
	end
end

function P.SpawnPower(playerRef, numPower)
	local powerZone = P.GetPlayerZone(playerRef, "Power")
	local seqFuncs = {}

	while math.floor(numPower / 10) > 0 and numPower > 10 do
		numPower = numPower - 10
		table.insert(seqFuncs, 1, function() return spawnToken(powerZone, "Power", 10) end)
	end
	while math.floor(numPower / 5) > 0 and numPower > 5 do
		numPower = numPower - 5
		table.insert(seqFuncs, 1, function() return spawnToken(powerZone, "Power", 5) end)
	end
	while numPower > 0 do
		numPower = numPower - 1
		table.insert(seqFuncs, 1, function() return spawnToken(powerZone, "Power", 1) end)
	end

	return U.RunSequence(seqFuncs, nil, 1)
end

function P.SpawnCoins(playerRef, numCoins)
	local coinZone = P.GetPlayerZone(playerRef, "Coin")

	local seqFuncs = {}

	while math.floor(numCoins / 5) > 0 and numCoins > 5 do
		numCoins = numCoins - 5
		table.insert(seqFuncs, 1, function() return spawnToken(coinZone, "Coin", 5) end)
	end
	while numCoins > 0 do
		numCoins = numCoins - 1
		table.insert(seqFuncs, 1, function() return spawnToken(coinZone, "Coin", 1) end)
	end

	return U.RunSequence(seqFuncs, nil, 1)
end

return P