local S = require("kingsdilemma.core.state")
local U = require("lib.utilities")
local O = require("kingsdilemma.lib.objects")
local L = require("kingsdilemma.core.lighting")
local C = require("kingsdilemma.lib.constants")
local OU = require("kingsdilemma.objects.objUtilities")



local V = {}

function V.InitCountZones(player)
	local ayeZone = getObjectsWithAllTags({"zonePrivateAye", player.color})[1]
	local nayZone = getObjectsWithAllTags({"zonePrivateNay", player.color})[1]
	local publicZone = getObjectsWithAllTags({"zonePublic", player.color})[1]
	if ayeZone then
		ayeZone.call("SetCountTag", "PowerToken")
		ayeZone.call("SetColor", C.LightColors.Blue)
	end
	if nayZone then
		nayZone.call("SetCountTag", "PowerToken")
		nayZone.call("SetColor", C.LightColors.Red)
	end
	if publicZone then
		publicZone.call("SetCountTag", "PowerToken")
		publicZone.call("SetColor", Color.Black)
	end
	if ayeZone and nayZone then
		ayeZone.call("LinkToOpp", nayZone)
		nayZone.call("LinkToOpp", ayeZone)
	end
	if ayeZone and publicZone then
		ayeZone.call("LinkToPublic", publicZone)
	end
	if nayZone and publicZone then
		nayZone.call("LinkToPublic", publicZone)
	end

	if ayeZone then ayeZone.call("Activate") end
	if nayZone then nayZone.call("Activate") end
	if publicZone then publicZone.call("Activate") end
end

function V.ElevateRiser(player)
	local riser = getObjectsWithAllTags({player.color, "plinthRiser"})[1]
	local riserPos = riser.getPosition()
	riserPos.y = 3
	return U.Lerp(function(pos) riser.setPositionSmooth(pos) end, riser.getPosition(), riserPos, 3)
end

function V.LowerRiser(player)
	local riser = getObjectsWithAllTags({player.color, "plinthRiser"})[1]
	local riserPos = riser.getPosition()
	riserPos.y = 1.5
	return U.Lerp(function(pos) riser.setPositionSmooth(pos) end, riser.getPosition(), riserPos, 3)
end

function V.ElevateBalance()
	local plinth = O.Pieces.BalancePlinth()
	local plinthPos = plinth.getPosition()
	plinthPos.y = 3
	return U.Lerp(function(pos) plinth.setPositionSmooth(pos) end, plinth.getPosition(), plinthPos, 1)
end

function V.LowerBalance()
	local plinth = O.Pieces.BalancePlinth()
	local plinthPos = plinth.getPosition()
	plinthPos.y = 1.94
	L.SetLightMode("lightBalance", "off", nil, 3)
	return U.Lerp(function(pos) plinth.setPositionSmooth(pos) end, plinth.getPosition(), plinthPos, 1)
end

function V.SpawnBalanceTokens(numTokens)
	local plinth = O.Pieces.BalancePlinth()
	local seqFuncs = {}

	local function spawnToken(tokenSize)
		local sourceObj = O.SpawnSources["powerToken" .. tokenSize]()
		local spawnData = sourceObj.getData()
		spawnData.Value = tokenSize
		spawnData.Transform = OU.unfoldTransform({
			position = U.getScatterPosition(plinth, 3, 0.6),
			rotation = Vector({
				U.randBetween(-45, 45, true),
				U.randBetween(-45, 45, true),
				U.randBetween(-45, 45, true)
			}),
			scale = sourceObj.getScale()
		})
		spawnData.Tags = {"PowerToken", "Value" .. tokenSize}
		spawnObjectData({
			data = spawnData,
			callback_function = function(obj)
				obj.setLock(false)
				Wait.frames(function() obj.addForce(Vector(0, -1, 0), 3) end)
			end
		})
		return 0.1
	end

	while math.floor(numTokens / 10) > 0 do
		numTokens = numTokens - 10
		table.insert(seqFuncs, function() return spawnToken(10) end)
	end
	while math.floor(numTokens / 5) > 0 do
		numTokens = numTokens - 5
		table.insert(seqFuncs, function() return spawnToken(5) end)
	end
	while numTokens > 0 do
		numTokens = numTokens - 1
		table.insert(seqFuncs, function() return spawnToken(1) end)
	end

	return U.RunSequence(seqFuncs, nil, 1)
end

return V