local C = require("lib.constants")
local U = require("lib.utilities")
local G = require("lib.guids")
local S = require("core.state")
local Z = require("core.zones")

local M = {}

local function lockObjects(objGUIDs)
	for _, guid in pairs(objGUIDs) do
		 local obj = getObjectFromGUID(guid)
		 obj.interactable = false
	end
end
local function invisObjects(objGUIDs)
	for _, guid in pairs(objGUIDs) do
			local obj = getObjectFromGUID(guid)
			obj.setInvisibleTo({"Red","Blue","Yellow"})
	end
end

function M.getRandomCard(cardOrDeck, callback)
	if cardOrDeck == nil then return end
	if cardOrDeck.type == "Deck" then
		local deckObjData = cardOrDeck.getObjects()
		local cardGUID = deckObjData[math.random(#deckObjData)].guid
		cardOrDeck.takeObject({
			flip = true,
			guid = cardGUID,
			callback_function = callback
		})
	else
		cardOrDeck.flip()
		callback(cardOrDeck)
	end
end
function M.sequence(funcs, waitStep)
	if waitStep == nil then waitStep = 0.5 end
	local waitTime = 0
	for _, func in ipairs(funcs) do
		if type(func) == "number" then
			waitTime = waitTime + func
		else
			Wait.time(function() func() end, waitTime)
			waitTime = waitTime + waitStep
		end
	end
end
function M.translateObj(obj, translation)
	local pos = obj.getPosition()
	pos.x = pos.x + translation.x
	pos.y = pos.y + translation.y
	pos.z = pos.z + translation.z
	obj.setPositionSmooth(pos)
end


-- *** GAME STATE ***

function M.onLoad(script_state)
	local newState = JSON.decode(script_state)
	if newState then
		S.setGameState(newState)
	end

	local powerBox = getObjectFromGUID(G.tokenSources.power);
	local infamyBox = getObjectFromGUID(G.tokenSources.infamy);
	local exhaustionBox = getObjectFromGUID(G.tokenSources.exhaustion);
	local torporBox = getObjectFromGUID(G.tokenSources.torpor);

	addHotkey("Power Token", function(playerColor, hoverObj, pointerPos)
		pointerPos.y = pointerPos.y + 1
		powerBox.takeObject({
			index = 1,
			smooth = false,
			position = pointerPos
		})
	end)
	addHotkey("Infamy Token", function(playerColor, hoverObj, pointerPos)
		pointerPos.y = pointerPos.y + 1
		infamyBox.takeObject({
			index = 1,
			smooth = false,
			position = pointerPos
		})
	end)
	addHotkey("Exhaustion Token", function(playerColor, hoverObj, pointerPos)
		pointerPos.y = pointerPos.y + 1
		exhaustionBox.takeObject({
			index = 1,
			smooth = false,
			position = pointerPos
		})
	end)
	addHotkey("Torpor Token", function(playerColor, hoverObj, pointerPos)
		pointerPos.y = pointerPos.y + 1
		torporBox.takeObject({
			index = 1,
			smooth = false,
			position = pointerPos,
			rotation = {x = 0, y = 180, z = 180}
		})
	end)
	lockObjects(G.lockedObjects)
	invisObjects(G.invisObjects)
	M.removeUnusedClanRefs()
	M.syncState()
	UI.show("adminControls")
	Wait.time(function()
		Z.onLoad()

		-- Z.updateTestObject()
		M.highlightBattlegrounds()
		M.syncPhase()

		-- S.setStateVal({
		-- 	"Kindred1", "Kindred2", "Mortals1", "Mortals2", "Wealth1", "Wealth2", "Subterfuge1", "Subterfuge2", "Subterfuge3", "Warfare1", "Occult1", "Occult2", "Occult3", "Occult4", "Cruelty1", "Cruelty2", "Mercy1", "Mercy2", "Mercy3", "Detachment1", "Detachment2", "Sabbat1", "Animalism1", "Dominate1", "Oblivion1", "Potence1", "Presence2", "Blood_Sorcery1"
		-- }, "usedAbilityStickers")
		-- S.setStateVal({
		-- 	Brujah = 2, Gangrel = 4, Lasombra = 2, Malkavian = 0, Nosferatu = 2, Toreador = 1, Tremere = 4, Tzimisce = 3, Ventrue = 2
		-- }, "usedClanStickers")
	end, 1)
end

function M.syncPhase()
	local phase = S.getStateVal("gamePhase")
	if phase == nil then
		broadcastToAll("Error determining game phase.", "Red")
		return
	end
	if phase == "INIT" then
		local clans = S.getStateVal("clans")
		if clans ~= nil then
			for color, clan in pairs(S.getStateVal("clans")) do
				UI.setValue(color .. "ClanChoice", C.Names[color] .. " chooses Clan " .. clan)
				UI.show(color .. "ClanChoice")
			end
		end
		M.doNextClan()
	end
end

function M.onPlayerTurn(player, previous_player)
	if S.isInPhase("PLAY") then
		Wait.time(M.highlightBattlegrounds, 1)
		if M.ignorePlayerTurn(player.color) then return end
		M.advanceTurn()
	else
		Turns.enable = false
	end
end
function M.tryObjectEnterContainer(container, object)
	if object.hasTag("LetterOfIntroduction") then return false end
	if container.type == "Card" and object.type == "Card" and object.getPosition().z < -6.5 then return false end
	-- if container.type == "Card" and object.hasTag("ClanScheme") and not container.hasTag("ClanScheme") then return false end
	-- if U.hasAnyTag(object, {"TopChar", "Monstrosity_1", "Monstrosity_2", "Monstrosity_3", "Monstrosity_4"}) then return false end
	-- if U.hasAnyTag(container, {"TopChar", "Monstrosity_1", "Monstrosity_2", "Monstrosity_3", "Monstrosity_4"}) then return false end
	return true
end
function M.onObjectEnterZone(zone, object)
	if S.getStateVal("allZonesLocked") == true then return end
	Z.onObjectEnterZone(zone, object)
	if S.getStateVal("playerZonesLocked") == true or not Z.isPlayerCardZone(zone) then return end
	local color = Z.getZoneColor(zone)
	if color == nil then return end
	if S.isInPhase("INIT") and object.hasTag("ClanLeader")  then
		M.updateMoralityToken(color)
	end
	if S.isInPhase("SCORING") then
		Wait.time(function()
			M.updatePlayerScore(color)
		end, 1)
	end
end

-- *** GAME STATUS ***
-- === Player Storage === --
function M.showHavens()
	for _, color in pairs(C.Colors) do
		local haven = getObjectFromGUID(G.playerObjs[color].haven)
		if haven then
			local havenPos = haven.getPosition()
			if havenPos.y < -2 then
				havenPos.y = 2
				haven.setPosition(havenPos)
				havenPos.y = -0.40
				haven.setInvisibleTo({})
				haven.setPositionSmooth(havenPos)
				haven.tooltip = true
			end
		end
	end
end

function M.hideHavens()
	for _, color in pairs(C.Colors) do
		local haven = getObjectFromGUID(G.playerObjs[color].haven)
		if haven then
			local havenPos = haven.getPosition()
			if havenPos.y > -2 then
				havenPos.y = 2
				haven.setPositionSmooth(havenPos)
				Wait.time(function()
					haven.setInvisibleTo(C.Colors)
					haven.tooltip = false
					havenPos.y = -10
					Wait.frames(function() haven.setPosition(havenPos) end)
				end, 0.5)
			end
		end
	end
end

function M.showPouches()
	for _, color in pairs(C.Colors) do
		local pouch = getObjectFromGUID(G.playerObjs[color].pouch)
		if pouch then
			local pouchPos = pouch.getPosition()
			if pouchPos.y < -2 then
				pouchPos.y = 2
				pouch.setPosition(pouchPos)
				pouchPos.y = -0.13
				pouch.setInvisibleTo({})
				pouch.setPositionSmooth(pouchPos)
				pouch.tooltip = true
			end
		end
	end
end

function M.hidePouches()
	for _, color in pairs(C.Colors) do
		local pouch = getObjectFromGUID(G.playerObjs[color].pouch)
		if pouch then
			local pouchPos = pouch.getPosition()
			if pouchPos.y > -2 then
				pouchPos.y = 2
				pouch.setPositionSmooth(pouchPos)
				Wait.time(function()
					pouch.setInvisibleTo(C.Colors)
					pouch.tooltip = false
					pouchPos.y = -10
					Wait.frames(function() pouch.setPosition(pouchPos) end)
				end, 0.5)
			end
		end
	end
end

-- === LastChapterStandings ===
function M.checkLastChapterStandings(data)
  if data == nil then data = S.getStateVal("lastChapterStandings") end
  if not (type(data) == "table" and #data == #Player.getPlayers()) then return false end
	data = table.sort(U.clone(data))
	if data ~= nil and table.concat(data) ~= "BlueRedYellow" then return false end
  return true
end
function M.getLastChapterStandings()
  if (M.checkLastChapterStandings()) then
    return S.getStateVal("lastChapterStandings")
  end
  -- broadcastToColor("[getLastChapterStandings] " .. logString(H.getStateVal("lastChapterStandings")) .. " is invalid state! Using fallback value.", "Red", "Red")
  return C.Colors
end
function M.getLastChapterVictor()
  return M.getLastChapterStandings()[1]
end
function M.getLastChapterMiddle()
  return M.getLastChapterStandings()[2]
end
function M.getLastChapterVanquished()
  return M.getLastChapterStandings()[3]
end
function M.determineLastChapterStandings(callback)
  if not M.checkLastChapterStandings() then
    M.askLastChapterStandings(function() M.determineLastChapterStandings(callback) end)
  end
end
function M.setLastChapterStandings(data)
  if (M.checkLastChapterStandings(data)) then
    S.setStateVal(data, "lastChapterStandings")
    return
  end
  broadcastToColor("[setLastChapterStandings] " .. logString(data) .. " is invalid data!", "Red", "Red")
end
function M.askLastChapterStandings(callback)
  local chapterStandings = {}
  local hostPlayer = U.getHost()
  local playerOptions = U.map(Player.getPlayers(), function(player) return player.color end)
  hostPlayer.showOptionsDialog("Who won the last chapter?", playerOptions, 1,
    function (color, index)
      table.insert(chapterStandings, color)
      hostPlayer.showOptionsDialog("Who came in second?", playerOptions, 1,
        function (color, index)
          table.insert(chapterStandings, color)
          hostPlayer.showOptionsDialog("Who came in last?", playerOptions, 1,
            function (color, index)
              table.insert(chapterStandings, color)
              M.setLastChapterStandings(chapterStandings)
              if (callback) then callback() end
            end
          )
        end
      )
    end
  )
end
function M.askChapterData(callback)
  local chapterData = {}
  local hostPlayer = U.getHost()

  hostPlayer.showInputDialog("Upcoming Chapter Number (Roman Numerals)",
      function (text)
        chapterData.chapterNum = text
        hostPlayer.showInputDialog("Last Chapter Number (Roman Numerals)",
            function (text)
              chapterData.lastChapterNum = text
              hostPlayer.showInputDialog("Upcoming Chapter Location",
                  function (text)
                    chapterData.location = text
                    hostPlayer.showInputDialog("Upcoming Chapter Years",
                        function (text)
                          chapterData.years = text
                          hostPlayer.showInputDialog("Upcoming Chapter Blurb",
                              function (text)
                                chapterData.chapterBlurb = text
                                S.setStateVal(chapterData, "chapterData")
                              end
                          )
                        end
                    )
                  end
              )
            end
        )
      end
  )
end

-- === Turn Order ===
-- This is strictly for the game's Turns object, not for clan selection --> use lastChapterStandings for that.
local turnOrderMap = {
  Red = {"Red", "Yellow", "Blue"},
  Yellow = {"Yellow", "Blue", "Red"},
  Blue = {"Blue", "Red", "Yellow"}
}
local function getColorOfClan(clan)
  local clans = M.getClans()
  if clans.Red == clan then return "Red" end
  if clans.Yellow == clan then return "Yellow" end
  if clans.Blue == clan then return "Blue" end
  return ""
end
local function getMoralityToken(playerColor)
	-- if not isLoaded then return false end
  local clan = S.getStateVal("clans")[playerColor]
  if (clan == nil) then return nil end
  local tokenName = clan .. " Morality"
  local token = U.find(Global.getObjects(), function (obj) return obj.getName() == tokenName end)
	return token
end
local function moveCurrentMoralityTokenToTop()
  local round, turn = M.getRoundAndTurn()
  if (round < 1 or round > 9) then return end
  local curMoralityToken = getMoralityToken(M.getCurrentPlayer())
	if curMoralityToken ~= nil then
		local tokenPos = curMoralityToken.getPosition()
		tokenPos.y = tokenPos.y + 1
		curMoralityToken.setPosition(tokenPos)
		Wait.time(M.highlightBattlegrounds, 2)
	end
end

function M.readTurnOrderFromBG()

  local turnOrder = M.getTurnOrder()
  local lastFirstPlayer = turnOrder[1]
  local bg = getObjectFromGUID(G.battlegrounds.b)
  local bgSnapPoints = U.getSnapPointPositions(bg)
  local pTokens = U.filter(U.findAboveObject(bg, "Tile"), function(tok) return string.find(tok.getName(), "Morality") ~= nil end)

  local function getTokenSlot(tk)
    local slot = U.findSnapPoint(bgSnapPoints, bg.positionToLocal(tk.getPosition()))
      local clan = U.findClanTag(tk)
      local color = getColorOfClan(clan)
    if (slot >= 6 and slot <= 9) then slot = 7 end
    if (color == lastFirstPlayer) then
      slot = slot + 0.5
    end
    return slot, color, clan
  end

  local curTopTokenSlot = 0
  local curTopTokenColors = {}
  for _, tok in pairs(pTokens) do
    local slot = U.findSnapPoint(bgSnapPoints, bg.positionToLocal(tok.getPosition()))
    local slot, color, clan = getTokenSlot(tok)
    if (slot > curTopTokenSlot) then
      curTopTokenSlot = slot
      curTopTokenColors = {}
      table.insert(curTopTokenColors, color)
    elseif (slot == curTopTokenSlot) then
      table.insert(curTopTokenColors, color)
    end
  end

  if (#curTopTokenColors == 1) then
    return turnOrderMap[curTopTokenColors[1]]
	end

	return turnOrderMap[lastFirstPlayer]
end
function M.checkTurnOrder(data)
  if data == nil then data = S.getStateVal("turnOrder") end
  -- if not (type(data) == "table" and #data == 3) then return false end
  -- if not (table.concat(turnOrderMap[data[1]]) == table.concat(data)) then return false end
  return true
end
function M.getTurnOrder()
  if (M.checkTurnOrder()) then
    return S.getStateVal("turnOrder")
  end
  broadcastToColor("[getTurnOrder] " .. logString(S.getStateVal("turnOrder")) .. " is invalid state! Using order set in 'Turns'.", "Red", "Red")
  return Turns.order
end
function M.determineTurnOrder(callback)
  local turnOrder = {}
  local round, turn = M.getRoundAndTurn()
  if round > 1 and round < 10 then
    -- if S.getStateVal("isReadingMoralityBoard") then
      turnOrder = M.readTurnOrderFromBG()
      M.setTurnOrder(turnOrder)
    -- else
      -- M.askTurnOrder(function() M.determineTurnOrder(callback) end)
      -- return
    -- end
  else
    turnOrder = turnOrderMap[M.getLastChapterStandings()[3]]
    M.setTurnOrder(turnOrder)
  end
  if callback then callback() end
end
function M.setTurnOrder(data)
  if (M.checkTurnOrder(data)) then
    S.setStateVal(data, "turnOrder")
    return
  end
  broadcastToColor("[setTurnOrder] " .. logString(data) .. " is invalid data!", "Red", "Red")
end
function M.askTurnOrder(callback)
  -- S.setStateVal("isReadingMoralityBoard", false)
  local round, turn = M.getRoundAndTurn()
  if round == 0 then
    M.askLastChapterStandings(callback)
  else
    local turnOrder
    local hostPlayer = U.getHost()
    local playerOptions = U.map(Player.getPlayers(), function(player) return player.color end)
    hostPlayer.showOptionsDialog("Who is this round's first player?", playerOptions, 1,
      function (color)
        M.setTurnOrder(turnOrderMap[color])
        if callback then callback() end
      end
    )
  end
end
function M.syncTurnOrder()
  local round, turn = M.getRoundAndTurn()
  if round > 0 and round < 10 then
    local turnOrder = M.getTurnOrder()
    if (table.concat(Turns.order) ~= table.concat(turnOrder)) then
      Turns.order = M.getTurnOrder()
    end
    if (Turns.type ~= 2) then
      Turns.type = 2
    end
    M.setHighlighter("TurnIndicator", "faint", Turns.order[turn])
    if (Turns.turn_color ~= Turns.order[turn]) then
      Turns.turn_color = Turns.order[turn]
    end
    if (not Turns.enable) then
      Turns.enable = true
    end
    moveCurrentMoralityTokenToTop()
    M.syncTurnTracker()
  else
    UI.hide("turnTracker")
    Turns.enable = false
  end
end
function M.syncTurnTracker()
  local round, turn = M.getRoundAndTurn()
  local turnOrder = M.getTurnOrder()
  local curPlayer = turnOrder[turn]
  local colors = {
      hex = {
          past = "white",
          current = "white",
          future = "white"
      },
      turn = {
          past = "rgba(0.3, 0.3, 0.3, 0.75)",
          current = {
              Red = "rgba(1, 0.2, 0.2, 1)",
              Yellow = "rgba(1, 1, 0, 1)",
              Blue = "rgba(0, 0.4, 0.8, 1)"
          },
          future = {
              Red = "rgba(1, 0.2, 0.2, 0.5)",
              Yellow = "rgba(1, 1, 0, 0.5)",
              Blue = "rgba(0, 0.4, 0.8, 0.5)",
              none = "rgba(1, 1, 1, 0.5)"
          }
      },
  }

    if (round < 1 or round > 9) then
        UI.hide("turnTracker")
        return
    else
        UI.show("turnTracker")
        for _, clr in pairs({"Red", "Yellow", "Blue"}) do
          if (curPlayer == clr) then
            M.setHighlighter("TurnIndicator", "faint", clr)
          else
            M.setHighlighter("TurnIndicator", "inactive", clr)
          end
        end
    end

    for i = 1, 9, 1 do
        UI.setAttribute("tt-round-past-" .. i, "color", "clear")
        UI.setAttribute("tt-round-current-" .. i, "color", "clear")
        UI.setAttribute("tt-round-future-" .. i, "color", "clear")
        if (i < round) then
            UI.setAttribute("tt-round-past-" .. i, "color", colors.hex.past)
        elseif (i == round) then
            UI.setAttribute("tt-round-current-" .. i, "color", colors.hex.current)
        elseif (i > round) then
            UI.setAttribute("tt-round-future-" .. i, "color", colors.hex.future)
        end

        for j = 1, 3, 1 do
            UI.setAttribute("tt-round-past-" .. i .. "-turn-" .. j, "color", "clear")
            UI.setAttribute("tt-round-current-" .. i .. "-turn-" .. j, "color", "clear")
            UI.setAttribute("tt-round-future-" .. i .. "-turn-" .. j, "color", "clear")
            if (i < round) then
                UI.setAttribute("tt-round-past-" .. i .. "-turn-" .. j, "color", colors.turn.past)
            elseif (i == round) then
                if (j < turn) then
                    UI.setAttribute("tt-round-past-" .. i .. "-turn-" .. j, "color", colors.turn.past)
                elseif (j == turn) then
                    UI.setAttribute("tt-round-current-" .. i .. "-turn-" .. j, "color", colors.turn.current[turnOrder[j]])
                elseif (j > turn) then
                    UI.setAttribute("tt-round-future-" .. i .. "-turn-" .. j, "color", colors.turn.future[turnOrder[j]])
                end
            elseif (i > round) then
                UI.setAttribute("tt-round-future-" .. i .. "-turn-" .. j, "color", colors.turn.future.none)
            end
        end
    end
end

-- === Clans ===
function M.getClans()
  local clans = S.getStateVal("clans")
  if (clans == nil) then return {} end
  return clans
end
local function getUnusedClanTokens()
	local clans = S.getStateVal("clans")
	return U.filter(
		getAllObjects(),
		function(obj)
			return obj and obj.hasTag("ClanToken")
				and string.gsub(obj.getName(), " Clan Token", "") ~= S.getStateVal("clans", "Red")
				and string.gsub(obj.getName(), " Clan Token", "") ~= S.getStateVal("clans", "Yellow")
				and string.gsub(obj.getName(), " Clan Token", "") ~= S.getStateVal("clans", "Blue")
		end
	)
end


-- === Round & Turn ===
function M.checkRoundAndTurn(dataRound, dataTurn)

  if dataRound == nil then dataRound = S.getStateVal("round") end
  if dataTurn == nil then dataTurn = S.getStateVal("turn") end

	dataRound = 1 * dataRound
	dataTurn = 1 * dataTurn
  -- if not (type(dataRound) == "number" and type(dataTurn) == "number") then return false end
  if dataRound < 0 or dataRound > 10 then return false end
  if dataTurn < 0 or dataTurn > 3 then return false end
  if dataRound > 0 and dataTurn == 0 then return false end
  if dataRound == 0 and dataTurn ~= 0 then return false end
  return true
end
function M.getRoundAndTurn()
  if (M.checkRoundAndTurn()) then
    return S.getStateVal("round"), S.getStateVal("turn")
  end
  local clans = M.getClans()
  if not (clans and clans.Red and clans.Yellow and clans.Blue) then
    M.setRoundAndTurn(0, 0)
    return 0, 0
  end
  broadcastToColor("[getRoundAndTurn] Round: " .. logString(S.getStateVal("round")) .. ", Turn: " .. logString(S.getStateVal("turn")) .. " is invalid state! Falling back to default!", "Red", "Red")
  local round = S.getStateVal("round")
  local turn = S.getStateVal("turn")
  if not (type(round) == "number" and round >= 0 and round <= 9) then -- Round is invalid, reset to 0, 0
    M.setRoundAndTurn(0, 0)
    return 0, 0
  end
  if (round == 0) then
    M.setRoundAndTurn(0, 0)
    return 0, 0
  end
  -- Round is valid: Extract turn number from turn order and current player
  local turnOrder = M.getTurnOrder()
  if (turnOrder[1] == Turns.turn_color) then turn = 1 end
  if (turnOrder[2] == Turns.turn_color) then turn = 2 end
  if (turnOrder[3] == Turns.turn_color) then turn = 3 end
  M.setRoundAndTurn(round, turn)
  return round, turn
end
function M.setRoundAndTurn(dataRound, dataTurn)
  if (M.checkRoundAndTurn(dataRound, dataTurn)) then
    S.setStateVal(dataRound, "round")
    S.setStateVal(dataTurn, "turn")
    return
  end
  broadcastToColor("[setRoundAndTurn] Round: " .. logString(dataRound) .. ", Turn: " .. logString(dataTurn) .. " is invalid data!", "Red", "Red")
end
function M.askRoundAndTurn(callback)
  local hostPlayer = U.getHost()
  hostPlayer.showOptionsDialog("What round is it?", {0,1,2,3,4,5,6,7,8,9}, 1,
    function(roundNum)
      hostPlayer.showOptionsDialog("What turn is it?", {0,1,2,3}, 2,
        function(turnNum)
					roundNum = roundNum * 1
					turnNum = turnNum * 1
					-- log({round = roundNum, turn = turnNum})
					local isAdvancingTurn = roundNum > 0 and turnNum > 0
					if roundNum > 0 and turnNum > 0 then
						if turnNum == 1 then
							turnNum = 3
							roundNum = roundNum - 1
						else
							turnNum = turnNum - 1
						end
					end
          M.setRoundAndTurn(roundNum, turnNum)
					M.advanceTurn()
          if (callback) then callback() end
        end
      )
    end
  )
end
function M.syncRoundAndTurn() M.syncTurnOrder() end

function M.advanceTurn()
  local round, turn = M.getRoundAndTurn()
  if (round == 0) then return end
  if (turn == 3) then return M.advanceRound() end
  UI.setValue("roundOverNotice", "")
  M.setRoundAndTurn(round, turn + 1)
  M.syncTurnOrder()
  -- Wait.time(H.syncTurnOrder, 1)
end
function M.advanceRound()
  local round, turn = M.getRoundAndTurn()
  if (round == 0) then return end
  local roundsLeft = 12 - #Player.getPlayers() - round
  if (roundsLeft <= 0) then
    M.setRoundAndTurn(10, 1)
    U.splashUIElement("splash-backdrop", 6)
    U.splashUIElement("gameOverNotice", 5, 0.5)
    UI.hide("turnTracker")
    Wait.time(function()
      M.setHighlighter("TurnIndicator", "inactive", "Red")
      M.setHighlighter("TurnIndicator", "inactive", "Yellow")
      M.setHighlighter("TurnIndicator", "inactive", "Blue")
      M.setHighlighter("BGIndicator", "inactive", "left")
      M.setHighlighter("BGIndicator", "inactive", "center")
      M.setHighlighter("BGIndicator", "inactive", "right")
    end, 3)
    return
  end
	Wait.time(function() M.highlightBattlegrounds() end, 2)
  local lastRoundFirstPlayer = M.getRoundFirstPlayer()
  UI.setValue("roundOverNoticeText", "End of Round " .. round)
  if (roundsLeft == 1) then
    UI.setValue("roundsRemainingNoticeText", "FINAL ROUND!")
  elseif (roundsLeft <= 3) then
    UI.setValue("roundsRemainingNoticeText", roundsLeft .. " Rounds Remain...")
  else
    UI.setValue("roundsRemainingNoticeText", "")
  end
  UI.setValue("roundStartNoticeText", "Beginning Round " .. round + 1)

  M.setRoundAndTurn(round + 1, 1)
  M.determineTurnOrder(function()
    local initiativeElem
    local roundFirstPlayer = M.getRoundFirstPlayer()
    if (lastRoundFirstPlayer == roundFirstPlayer) then
        UI.setValue("retainInitiativeNotice", "(" .. C.Names[roundFirstPlayer] .. " Retains His Initiative)")
        UI.setValue("seizeInitiativeNotice", "")
        initiativeElem = "retainInitiativeNotice"
    else
        UI.setValue("seizeInitiativeNotice", C.Names[roundFirstPlayer] .. " Seizes Initiative!")
        UI.setValue("retainInitiativeNotice", "")
        initiativeElem = "seizeInitiativeNotice"
    end
    U.splashUIElement("splash-backdrop", 4.5)
    U.splashUIElement("roundOverNotice", 1)
    U.splashUIElement("roundsRemainingNoticeText", 1)
    U.splashUIElement("roundStartNotice", 2, 1.5)
    U.splashUIElement(initiativeElem, 1, 1.5)

    M.syncTurnOrder()
  end)
end

-- *** DERIVED GAME STATUSES ***
function M.getCurrentPlayer()
  local round, turn = M.getRoundAndTurn()
  if (round == 0) then
    return M.getNextPlayer() -- 'current' and 'next' player are both 'the player who is next to choose a clan'
  end
  if (round > 9) then return nil end
  return M.getTurnOrder()[turn]
end
function M.getNextPlayer()
  local round, turn = M.getRoundAndTurn()
  local clans = M.getClans()
  if (round == 0) then
    for _, color in ipairs(U.reverse(M.getLastChapterStandings())) do
      if (clans[color] == nil) then return color end
    end
    return nil
  end
  if (round == 9 and turn == 3) or round > 9 then return nil end
  if (turn == 3) then return M.getNextRoundFirstPlayer() end
  return M.getTurnOrder()[turn + 1]
end
function M.getRoundFirstPlayer()
  local round, turn = M.getRoundAndTurn()
  if (round == 0) then
    return M.getLastChapterStandings()[#Player.getPlayers()]
  end
  local curRoundTurnOrder = M.getTurnOrder()
  return curRoundTurnOrder[1]
end
function M.getNextRoundFirstPlayer()
  local round, turn = M.getRoundAndTurn()
  if (round == 0) then
    return M.getLastChapterStandings()[#Player.getPlayers()]
  end
  if (round >= 9) then return nil end
  -- if S.getStateVal("isReadingMoralityBoard") then
    local nextRoundTurnOrder = M.readTurnOrderFromBG()
    return nextRoundTurnOrder[1]
  -- end
  -- return nil
end




local targetCard = false
function M.zoomCard(player)
  pcall(function()
    if targetCard then
      targetCard.setLock(false)
      targetCard.setRotationSmooth({x=0, y=180, z=0}, false, true)
      targetCard.setPositionSmooth({x=8.83, y=2, z=1.13}, false, true)
    end
  end)

  local sourceDeck = U.findAboveObject(getObjectFromGUID(G.decks.missionSpot), "Deck")[1]
  targetCard = sourceDeck.takeObject({
    position = {x=-0.5, y=5.47, z=2},
    rotation = {x=19.28, y=180, z=0},
    callback_function = function(obj) obj.setLock(true) end
   })
   -- H.setCamera()
	 M.setCamera(player, "ZoomCard")
end
function M.clearZoom(player)
  pcall(function()
    if targetCard then
      targetCard.setLock(false)
      targetCard.setRotationSmooth({x=0, y=180, z=0}, false, true)
      targetCard.setPositionSmooth({x=8.83, y=2, z=1.13}, false, true)
    end
    targetCard = false
  end)
end

-- *** GAME PHASE ACTIONS ***
local chapterCard
local missionDeck

function M.gameSETUP()
	if (S.getStateVal("gamePhase") ~= "NONE") then
		broadcastToColor("Game Phase is '" .. S.getStateVal("gamePhase") .. "', must be 'NONE' to enter 'SETUP'", "Red", "Red")
		return
	end
	S.setStateVal("SETUP", "gamePhase")

	missionDeck = U.findAboveObject(getObjectFromGUID(G.decks.missionSpot), "Deck")[1]

	-- Reset any tags set on player Leader Card spaces
  getObjectFromGUID(G.playerObjs.Red.leaderCard).setTags({"Red"})
  getObjectFromGUID(G.playerObjs.Yellow.leaderCard).setTags({"Yellow"})
  getObjectFromGUID(G.playerObjs.Blue.leaderCard).setTags({"Blue"})

	M.sequence({
		M.showHavens,
		M.hidePouches,
		function() M.setCamera("ALL", "ZoomCard") end,
		function()
			chapterCard = missionDeck.takeObject({
				position = {x=-0.5, y=5.47, z=2},
				rotation = {x=19.28, y=180, z=0},
				callback_function = function(obj)
					obj.setLock(true)
					M.processObj(obj, "chapter")
				end
			})
		end,
		5,
		function()
			chapterCard.setPositionSmooth({x=-3.50, y=3.00, z=-0.50})
			chapterCard.setRotationSmooth({x=19.28, y=180, z=180})
		end,
		function() getObjectFromGUID("afb371").call("Populate_Missions") end,
		2,
		function() getObjectFromGUID("afb371").call("Populate_Queue") end
	})

end

function M.dealAssets()
	for _, color in pairs(C.Colors) do
		local haven = getObjectFromGUID(G.playerObjs[color].haven)
		local havenObjGUIDs = U.map(U.filter(haven.getObjects(), function(obj)
			return U.isIn("Asset", obj.tags)
		end), function(obj) return obj.guid end)
		U.forEach(havenObjGUIDs, function(guid)
			haven.takeObject({
				guid = guid,
				callback_function = function(obj)
					obj.deal(1, color)
					if obj.hasTag("Card") then
						Wait.time(function() obj.flip() end, 1)
					end
				end
			})
		end)
	end
end

function M.dealRetainer()
	for _, color in pairs(C.Colors) do
		local haven = getObjectFromGUID(G.playerObjs[color].haven)
		local havenObjGUIDs = U.map(U.filter(haven.getObjects(), function(obj)
			return U.isIn("Character", obj.tags)
		end), function(obj) return obj.guid end)
		U.forEach(havenObjGUIDs, function(guid)
			haven.takeObject({
				guid = guid,
				callback_function = function(obj)
					obj.deal(1, color)
				end
			})
		end)
	end
end

function M.displayClanSelectionRing()
	if #getUnusedClanTokens() == 0 then
    local masterStorage = getObjectFromGUID(G.mainStorage.id)
    local clanTokenObjs = {}
    local stagingPosition = masterStorage.getPosition()
    stagingPosition.x = stagingPosition.x + 5
    stagingPosition.z = stagingPosition.z - 5

    -- Extract clan token objects from storage.
    for _, obj in pairs(U.filter(masterStorage.getObjects(), function(objData) return U.isIn("ClanToken", objData.tags) end)) do
        stagingPosition.y = stagingPosition.y + 1
        masterStorage.takeObject({guid = obj.guid, position = stagingPosition})
    end

    -- Arrange in ring for player selection.
    Wait.time(function()
        U.makeRing(
            U.filter(getAllObjects(), function(obj) return obj.hasTag("ClanToken") end),
            G.tableSpots.highlighters.clanSelection.active,
            3,
            {
                scale = {x = 0.5, y = 1, z = 0.5}
            }
        )
    end, 0.5)
	end

	-- Make clan selection highlight visible and position appropriately.
	M.setHighlighter("ClanSelection", "active")
end

function M.storeClanSelectionRing()
  local clans = S.getStateVal("clans")
  local mainStorage = getObjectFromGUID(G.mainStorage.id)
	M.setHighlighter("ClanSelection", "inactive")
	for _, token in pairs(getUnusedClanTokens()) do
			mainStorage.putObject(token)
	end
end

function M.promptPlayerClanChoice(color)
	M.displayClanSelectionRing()
	M.setHighlighter("TurnIndicator", "strong", color)
	-- M.setHighlighter("ClanSelection", "active")
	UI.setValue("chooseClanPlayer", C.Names[color])
	UI.setAttribute("chooseClanPlayer", "color", color)
	U.splashUIElement("chooseClanNotice", 5)
end

function M.doNextClan()
	if (M.getNextPlayer()) then
		M.promptPlayerClanChoice(M.getNextPlayer())
	else
		M.storeClanSelectionRing()
	end
end

function M.assignClan(clan, color)
  S.setStateVal(clan, "clans", color)
  UI.setValue(color .. "ClanChoice", C.Names[color] .. " chooses Clan " .. clan)
  if (color == M.getLastChapterMiddle()) then
    U.splashUIElement("chooseStrandsOfTimeNotice", 5) -- Vanquished last Chapter, you may choose a Strand of time
    local strandOfTimeSpot = getObjectFromGUID(G.decks.strandOfTimeSpot)
    strandOfTimeSpot.highlightOn("Green")
    M.presentStrandsOfTimeToMiddle()
  end
  UI.show(color .. "ClanChoice")
  Wait.time(M.doNextClan, 1)
end

function M.gameINIT()
	if (S.getStateVal("gamePhase") ~= "SETUP") then
		broadcastToColor("Game Phase is '" .. S.getStateVal("gamePhase") .. "', must be 'SETUP' to enter 'INIT'", "Red", "Red")
		return
	end
	S.setStateVal("INIT", "gamePhase")

  if not M.checkLastChapterStandings() then
    M.determineLastChapterStandings(M.gameINIT)
    return
  end

  if not missionDeck then
    missionDeck = U.findAboveObject(getObjectFromGUID(G.decks.missionSpot), "Deck")[1]
  end

  M.syncState()

	local timeBlurbAloneOnScreen = 5
	local timePadding = 0.5
	local timeScoresOnScreen = 6
	local timeBlurbOnScreen = timeBlurbAloneOnScreen + (2 * timePadding) + timeScoresOnScreen
	local timeStep = 1

	M.sequence({
		function()
			local chapterData = S.getStateVal("chapterData")

			UI.setValue("lastChapterStandingsNotice-title", "Chapter " .. chapterData.lastChapterNum .. " Standings:")
			UI.setValue("logoIntro-title", "Chapter " .. chapterData.chapterNum .. " â€” " .. string.upper(chapterData.location))
			UI.setValue("logoIntro-subtitle", "(" .. chapterData.years .. ")")
			UI.setValue("logoIntro-body", chapterData.chapterBlurb)


			U.splashUIElement("logoIntro", timeBlurbOnScreen)
			U.splashUIElement("logoIntro-title", 10, timePadding)
			U.splashUIElement("logoIntro-subtitle", 10, timePadding + timeStep)
			U.splashUIElement("logoIntro-body", 10, timePadding + (timeStep * 2))

			local timePassed = timeBlurbAloneOnScreen + (2 * timePadding)

			U.splashUIElement("lastChapterStandingsNotice", timeScoresOnScreen, timePassed)
			U.splashUIElement("lastChapterStandingsNotice-title", 10, timePassed)
			U.splashUIElement("lastChapterStandingsNotice-subtitle1", 10, timePassed + timeStep)
			U.splashUIElement("lastChapterStandingsNotice-subtitle2", 10, timePassed + timeStep * 1.5)
			U.splashUIElement("lastChapterStandingsNotice-subtitle3", 10, timePassed + timeStep * 2)
			U.splashUIElement("lastChapterStandingsNotice-subtitle4", 10, timePassed + timeStep * 3)
			U.splashUIElement("lastChapterStandingsNotice-subtitle5", 10, timePassed + timeStep * 3.5)
			U.splashUIElement("lastChapterStandingsNotice-subtitle6", 10, timePassed + timeStep * 4)


			U.splashUIElement("splash-backdrop", timeBlurbAloneOnScreen + (2 * timePadding) + timeScoresOnScreen + timePadding)
		end,
		timeBlurbAloneOnScreen + timeScoresOnScreen + (4 * timePadding),
		function()
			if chapterCard then
				chapterCard.setLock(false)
				chapterCard.setRotationSmooth({x=0, y=180, z=0})
				missionDeck.putObject(chapterCard)
			end
		end,
		function() M.setCamera("ALL", "ClanSelection") end,
		M.displayClanSelectionRing,
		1,
		M.dealAssets,
		M.dealRetainer,
		function()
			local clanChooser = M.getNextPlayer()
			M.setHighlighter("TurnIndicator", "strong", clanChooser)
			UI.setValue("chooseClanPlayer", C.Names[clanChooser])
			UI.setAttribute("chooseClanPlayer", "color", clanChooser)
		end,
		function()
			U.splashUIElement("chooseClanNotice", 5)
			UI.show("clanChoiceAlert")
		end
	})
end
local function getSchemesDeck(color)
  local deck = U.findAboveObject(getObjectFromGUID(G.playerObjs[color].schemeDeck), "Deck")[1]
  if not deck then
    local card = U.findAboveObject(getObjectFromGUID(G.playerObjs[color].schemeDeck), "Card")[1]
    if not card then return false end
		return card
	end
  return deck
end
local function getSchemesDiscard(color)
  local deck = U.findAboveObject(getObjectFromGUID(G.playerObjs[color].schemeDiscard), "Deck")[1]
  if not deck then
    local card = U.findAboveObject(getObjectFromGUID(G.playerObjs[color].schemeDiscard), "Card")[1]
    if not card then return false end
    return card
  end
  return deck
end
function M.updateMoralityToken(color)
  local leaderClan = M.getClans()[color]
  local leaderCard = Z.getClanLeader(color)
  local leaderName = leaderCard.getName()
  local leaderMorality
  if not leaderName then return false end
  if leaderCard.hasTag("DoubleSided") then
    local leaders = U.split(leaderName, "|")
    if (U.isFlipped(leaderCard)) then
      leaderName = leaders[2]
    else
      leaderName = leaders[1]
    end
  end
  if string.match(leaderName, ":M") ~= nil then
    leaderMorality = "M"
  else
    leaderMorality = "C"
  end
  local moralityToken = getMoralityToken(color)
	if moralityToken == nil then return Wait.time(function() M.updateMoralityToken(color) end, 1) end
	local moralityPosition = moralityToken.getPosition()
	moralityPosition.y = moralityPosition.y + 1
	local moralityRotation = moralityToken.getRotation()
	if C.MoralityTokens[leaderClan] == leaderMorality then
		moralityRotation.z = 0
	else
		moralityRotation.z = 180
	end
	moralityToken.setPosition(moralityPosition)
	moralityToken.setRotation(moralityRotation)
end
function M.initializeClanLeader(col)
	if col == nil then
		M.sequence(U.map(C.Colors, function(color)
			local colorFunc = function() M.initializeClanLeader(color) end
			return colorFunc
		end), 0.5)
		return
	end

	local leaderCard = Z.getClanLeader(col)
	M.processObj(leaderCard, "clanLeader")

	local leaderSchemes = leaderCard.getDescription()
  local schemesDeck = getSchemesDeck(col)

	if schemesDeck ~= nil then

		if leaderCard.hasTag("DoubleSided") then
			local schemes = U.split(leaderSchemes, "|")
			if (U.isFlipped(leaderCard)) then
				leaderSchemes = schemes[2]
			else
				leaderSchemes = schemes[1]
			end
		end

		M.sequence({
			function()
				local schemesToDeal = {}
				local schemeFuncs = {}
				for _, obj in pairs(schemesDeck.getObjects()) do
					if string.match(leaderSchemes, obj.name) ~= nil then
						table.insert(schemesToDeal, obj.guid)
					end
				end
				local pos = schemesDeck.getPosition()
				for i, cardID in pairs(schemesToDeal) do
					table.insert(schemeFuncs, function()
						schemesDeck.takeObject({
							flip = true,
							position = {
								x = pos.x - 2.5 + (2.5 * (i - 1)),
								y = pos.y + 2,
								z = pos.z + 4
							},
							guid = cardID,
							callback_function = function(card) card.deal(1, col) end
						})
					end)
				end
				M.sequence(schemeFuncs, 0.1)
			end,
			function()
				local aftermathZone = getObjectFromGUID(G.zones[col].aftermath)

				-- move existing objects out of position
				local currentObjects = U.filter(U.findAboveObject(leaderCard),
					function(obj)
						return obj.guid ~= leaderCard.guid and obj.type ~= "Block" and not U.isIn(obj.guid, G.lockedObjects) and not U.isIn(obj.guid, G.invisObjects)
					end)

				currentObjects = U.map(currentObjects, function(obj)
					local pos = obj.getPosition()
					pos.y = pos.y + 2
					obj.setPosition(pos)
					return obj.guid
				end)

				-- move Boons into position
				U.forEach(Z.getTaggedZoneObjects(aftermathZone, "Boon"),
					function(boon)
						if U.isIn(boon.guid, currentObjects) then return end
						local boonPos = boon.getPosition()
						boonPos.x = boonPos.x - 1
						boonPos.y = boonPos.y + 1
						boon.setPosition(boonPos)
					end)

				-- move Power into position
				U.forEach(Z.getTaggedZoneObjects(aftermathZone, "Power"),
					function(power)
						if U.isIn(power.guid, currentObjects) then return end
						local powerPos = power.getPosition()
						powerPos.z = powerPos.z + 2.5
						powerPos.y = powerPos.y + 1
						power.setPosition(powerPos)
					end)
			end
		}, 1)

		-- local leaderZone = getObjectFromGUID(G.zones[col].bloodline[1][1])
		-- for _, token in pairs(Z.getTaggedZoneObjects(leaderZone, {"Power", "Boon", "Infamy"})) do
		-- 	token.setLock(false)
		-- end
		-- local leaderName = leaderCard.getName()

		-- local leaderMorality
		-- if not leaderName then return false end

		-- M.updateMoralityToken(col)
		-- leaderName = string.gsub(leaderName, ":.", "")
		end
end
function M.clearUnusedClanLeaders()
  local usedClanLeaderIDs = {
    Z.getClanLeader("Red").guid,
    Z.getClanLeader("Yellow").guid,
    Z.getClanLeader("Blue").guid
  }
  local unusedClanLeaders = U.filter(getObjectsWithTag("ClanLeader"), function(obj) return obj.type == "Card" and not U.isIn(obj.guid, usedClanLeaderIDs) end)
  for _, obj in pairs(unusedClanLeaders) do
		local targetContainer
    if obj.hasTag("Red") then
			targetContainer = getObjectFromGUID(G.playerObjs.Red.haven)
    elseif obj.hasTag("Yellow") then
      targetContainer = getObjectFromGUID(G.playerObjs.Yellow.haven)
    elseif obj.hasTag("Blue") then
      targetContainer = getObjectFromGUID(G.playerObjs.Blue.haven)
    else
      local clan = U.findClanTag(obj)
      if (clan) then
        targetContainer = getObjectFromGUID(G.mainStorage.clanStorage[clan])
      end
    end
		targetContainer.putObject(obj)
  end
end

function M.removeUnusedClanRefs()
	local clans = M.getClans()
	local round, turn = M.getRoundAndTurn()
	if round > 0 and round < 10 then
		for _, clan in pairs(C.Clans) do
			if not U.isIn(clan, clans) then
				for _, color in pairs({"Red", "Yellow", "Blue"}) do
					UI.hide("hudRef" .. clan .. color)
					UI.hide("hudRef" .. clan .. color .. "Overlay")
				end
			end
		end
		for _, col in pairs(C.Colors) do
      UI.setAttributes("hudSidebar" .. col, {
        rectAlignment = "MiddleRight",
        height = "360",
        offsetXY = "0 0"
      })
    end
	end
end

function M.presentObligations(color)
	local player = Player[color]
	if player == nil then return end
	local pHaven = getObjectFromGUID(G.playerObjs[color].haven)
	if pHaven == nil then return end
	local oblData = U.filter(pHaven.getObjects(), function(oData) return U.isIn("Obligation", oData.tags) end)

	local function displayObligation(oblID, num)
		if num == nil then num = 1 end
		local oblPos = G.tableSpots.obligations[color]
		local oblRot = G.tableSpots.obligations.rotation
		pHaven.takeObject({
			guid = oblID,
			position = {
				x = oblPos.x + (num - 1) * 2.5,
				y = oblPos.y,
				z = oblPos.z
			},
			rotation = oblRot,
			callback_function = function(obl)
				obl.setLock(true)
				obl.highlightOn("Red")
			end
		})
	end

	U.forEach(oblData, function(oData, i) displayObligation(oData.guid, i) end)
end

function M.retrieveObligations(color)
	if color == nil then
		for _, color in pairs(C.Colors) do
			M.retrieveObligations(color)
		end
	else
		local playerZone = getObjectFromGUID(G.zones[color].aftermath)
		if playerZone ~= nil then
			local playerHaven = getObjectFromGUID(G.playerObjs[color].haven)
			for _, obl in pairs(Z.getTaggedZoneObjects(playerZone, "Obligation")) do
				obl.highlightOff()
				obl.setLock(false)
				obl.setRotation({x = 0, y = 180, z = 0})
				playerHaven.putObject(obl)
			end
		end
	end
end

function M.gameSTART()
	if (S.getStateVal("gamePhase") ~= "INIT") then
		broadcastToColor("Game Phase is '" .. S.getStateVal("gamePhase") .. "', must be 'INIT' to enter 'PLAY'", "Red", "Red")
		return
	end
	S.setStateVal("PLAY", "gamePhase")

	M.sequence({
		function()
			UI.hide("RedClanChoice")
			UI.hide("YellowClanChoice")
			UI.hide("BlueClanChoice")
			UI.hide("clanChoiceAlert")
			UI.hide("chooseStrandsOfTimeNotice")
			M.removeUnusedClanRefs()
		end,
		M.showHavens,
		1,
		M.retrieveObligations,
		M.clearUnusedClanLeaders,
		M.removeUnusedClanRefs,
		M.hideHavens,
		M.hidePouches,
		function() M.initializeClanLeader("Red") end, 1,
		function() M.initializeClanLeader("Yellow") end, 1,
		function() M.initializeClanLeader("Blue") end, 1,
		function()
			U.splashUIElement("splash-backdrop", 2)
			U.splashUIElement("gameStartNotice", 1, 0.5)

			M.setRoundAndTurn(1, 1)
			M.determineTurnOrder(M.syncTurnOrder)
		end
	})
end


local function getSortedVictoryBoardSnapPoints(victoryBoard)
  local snapPointPositions = U.map(U.getSnapPointPositions(victoryBoard), function(posData) return U.roundTableVals(posData) end)
	snapPointPositions = U.getSnapPointPositions(victoryBoard)
  table.sort(snapPointPositions, function(a,b)
    if (math.abs(a.z - b.z) <= 0.2) then
      return a.x > b.x
    end
    return a.z < b.z
  end)
	-- log({localSnapPoints = snapPointPositions,
	-- localSnapPointZs = U.map(snapPointPositions, function(pos) return pos.z end)})
  return snapPointPositions
end

local function getClanToken(playerColor)
  local clan = S.getStateVal("clans", playerColor)
  if (clan == nil) then return false end
  local tokenName = clan .. " Clan Token"
  local token = U.find(Global.getObjects(), function (obj) return obj.getName() == clan .. " Clan Token" end)
  if (token == nil) then return false end
  return token
end

function M.updatePlayerScore(color)
	-- Z.showScores()
	local playerName = C.Names[color]
	local playerScore = Z.scoreBloodline(color)
	UI.setValue(color .. "Score", playerName .. "'s Bloodline: " .. playerScore .. " points.")
	UI.show(color .. "Score")
	local token = getClanToken(color)
	local victoryBoard = getObjectFromGUID(G.victoryBoard)
	if (token and victoryBoard) then
		local positions = U.map(getSortedVictoryBoardSnapPoints(victoryBoard), function(pos) return victoryBoard.positionToWorld({
			x = pos.x,
			y = pos.y + 0.5,
			z = pos.z - 0.02-- - 0.2 -- + 0.2
		}) end)
		-- log({snapPoint4 = positions[4]})
		local scorePos
		if playerScore > 0 then
			if playerScore > 60 then playerScore = 60 end
			scorePos = positions[playerScore]
		else
			scorePos = G.tableSpots.clanTokenVictory[color]
		end
		token.setPositionSmooth(scorePos, false, true)
		token.setRotationSmooth(G.tableSpots.clanTokenVictory.rotation, false, true)
		token.setScale(G.tableSpots.clanTokenVictory.scale)
		token.setColorTint(color)
	end
end

local function scoreBloodlines()
  Z.showScores()
  local waitStep = 2
  UI.show("scoreAlert")
  for i, color in pairs(C.Colors) do
		Wait.time(function() M.updatePlayerScore(color) end, waitStep * (i - 1))
  end
end
local function hideBloodlinesScore()
  Z.hideScores()
  UI.hide("scoreAlert")
  for _, color in pairs(C.Colors) do
    UI.hide(color .. "Score")
    Wait.time(function() UI.setValue(color .. "Score", "") end, 1)
  end
end

function M.showVictoryBoard()
  local mainStorage = getObjectFromGUID(G.mainStorage.id)
  local victoryTable = getObjectFromGUID(G.victoryTable)
  victoryTable.setInvisibleTo({})
  victoryTable.setPositionSmooth(G.tableSpots.victory.table, false, true)
  victoryTable.setRotationSmooth(G.tableSpots.victory.rotation, false, true)
  mainStorage.takeObject({
    position = G.tableSpots.victory.board,
    rotation = G.tableSpots.victory.rotation,
    guid = G.victoryBoard,
    smooth = false,
		callback_function = function(vBoard) vBoard.setLock(true) end
  })
  for _, pColor in pairs(C.Colors) do
    local token = getClanToken(pColor)
    if (token) then
      token.setPosition(G.tableSpots.clanTokenVictory[pColor], false, true)
      token.setRotation(G.tableSpots.clanTokenVictory.rotation, false, true)
      token.setScale(G.tableSpots.clanTokenVictory.scale)
      token.setColorTint(pColor)
    end
  end
end

function M.hideVictoryBoard()
  local mainStorage = getObjectFromGUID(G.mainStorage.id)
  local victoryTable = getObjectFromGUID(G.victoryTable)
  local victoryBoard = getObjectFromGUID(G.victoryBoard)
  local clanTokens = U.filter(Global.getObjects(), function (obj) return string.match(obj.getName(), "Clan Token") ~= nil end)
  -- log({TOKENS = clanTokens})
  mainStorage.putObject(victoryBoard)
  for _, token in pairs(clanTokens) do
    token.setColorTint("White")
    token.setScale({x = 0.24, y = 1, z = 0.24})
    mainStorage.putObject(token)
  end
  victoryTable.setInvisibleTo({"Red", "Yellow", "Blue"})
  victoryTable.setPosition({x = 0, y = 50, z = 0})
end

function M.recallSchemesToDiscard()
	local schemeDiscardPos = {}
	local schemeDiscardRot = {x = 0, y = 180, z = 180}
	for color, clan in pairs(M.getClans()) do
		local schemesDeck = getSchemesDeck(color)
		if schemesDeck ~= false then schemesDeck.addTag(clan) end
		local schemesDiscard = getSchemesDiscard(color)
		if schemesDiscard ~= false then
			schemesDiscard.addTag(clan)
			schemesDiscard.flip()
		end
		local pos = getObjectFromGUID(G.playerObjs[color].schemeDiscard).getPosition()
		pos.y = pos.y + 2
		schemeDiscardPos[clan] = pos
	end

	local schemeCards = getObjectsWithTag("ClanScheme")

	U.forEach(C.Colors, function(color)
		schemeCards = U.concat(schemeCards, U.filter(Player[color].getHandObjects(), function(obj) return obj.hasTag("ClanScheme") end))
	end)

	local function moveSchemeToDiscard(card)
		if card == nil or not card.hasTag("ClanScheme") or card.hasTag("LockedScheme") then return end
		local schemeClan = U.findClanTag(card)
		if schemeClan == nil then return end
		card.setLock(false)
		card.use_hands = false
		local schemePos = schemeDiscardPos[schemeClan]
		card.use_hands = false
		card.setScale({1, 1, 1})
		card.setPosition(schemePos)
		card.setRotation(schemeDiscardRot)
		card.use_hands = true
	end

	M.sequence(U.map(schemeCards, function(card)
		return function()
			-- log({schemeClan = U.findClanTag(card)})
			moveSchemeToDiscard(card)
		end
	end), 0.1)
end

function M.recallStrandsOfTime()
  local strand = U.findAboveObject(getObjectFromGUID(G.decks.strandOfTimeSpot), "Card")[1]
	if strand == nil then return end
  local strandStaging = getObjectFromGUID(G.decks.unusedStrandsOfTime)
  local strandStagingPos = strandStaging.getPosition()
  strandStagingPos.y = strandStagingPos.y + 1
  strand.setRotation({x = 0, y = 180, z = 0})
  strand.setPosition(strandStagingPos)
  Wait.time(function()
    local strandsDeck = U.findAboveObject(strandStaging, "Deck")[1]
    local mainStorage = getObjectFromGUID(G.mainStorage.id)
    mainStorage.putObject(strandsDeck)
  end, 1)
end

function M.returnAssetsToHaven()
	U.forEach(C.Colors, function(color)
		local player = Player[color]
		local playerHaven = getObjectFromGUID(G.playerObjs[color].haven)
		local havenPos = playerHaven.getPosition()
		havenPos.y = havenPos.y + 4
		-- log({player = player, haven = playerHaven, hPos = havenPos})
		local assetsInHand = U.filter(player.getHandObjects(), function(obj) return obj.hasTag("Asset") end)
		M.sequence(U.map(assetsInHand, function(asset)
			return function()
				asset.use_hands = false
				asset.setPosition(havenPos)
				asset.use_hands = true
				playerHaven.putObject(asset)
			end
		end))
	end)
end

function M.gameSCORE()
	if (S.getStateVal("gamePhase") ~= "PLAY") then
		broadcastToColor("Game Phase is '" .. S.getStateVal("gamePhase") .. "', must be 'PLAY' to enter 'SCORING'", "Red", "Red")
		return
	end
	S.setStateVal("SCORING", "gamePhase")

	M.sequence({
		M.recallSchemesToDiscard,
		M.showVictoryBoard,
		M.recallStrandsOfTime,
		M.returnAssetsToHaven,
		scoreBloodlines
	})
end

function M.recallSchemeDiscard()
  for _, color in pairs(C.Colors) do
    local sDiscardDeck = getSchemesDiscard(color)
    if (sDiscardDeck) then
      local schemeDeckPos = getObjectFromGUID(G.playerObjs[color].schemeDeck).getPosition()
      schemeDeckPos.y = schemeDeckPos.y + 1
      sDiscardDeck.setPosition(schemeDeckPos)
      sDiscardDeck.setRotation({x = 0, y = 180, z = 180})
    end
  end
end

local function showObligationToPlayer(color, card, highlightColor)
	local oblPos = G.tableSpots.obligations[color]
	local oblRotation = G.tableSpots.obligations.rotation
	card.setLock(true)
	card.setPositionSmooth(oblPos)
	card.setRotationSmooth(oblRotation)
	card.highlightOn(highlightColor, 3)
	if highlightColor == "Green" then
		card.addTag("OblDiscard")
	else
		card.addTag("OblDraw")
		card.addTag(color)
	end
end

local obligationsDeck
function M.presentObligationsToVictor()
  local mainStorage = getObjectFromGUID(G.mainStorage.id)
	local stagingPos = G.tableSpots.obligations.staging
	local oblData = U.find(mainStorage.getObjects(), function(objData)
		return U.isIn("Obligation", objData.tags)
	end)
	if oblData == nil then return end
	mainStorage.takeObject({
		position = stagingPos,
		rotation = G.tableSpots.obligations.stagingRot,
		guid = oblData.guid,
		callback_function = function(cardOrDeck)
			if cardOrDeck == nil then return end
			obligationsDeck = cardOrDeck
			M.getRandomCard(cardOrDeck, function(card)
				showObligationToPlayer(M.getLastChapterVictor(), card, "Red")
			end)
		end
	})
end

function M.revealLostObligationsToNonVictors()
	local nonVictors = U.filter(C.Colors, function(color) return color ~= M.getLastChapterVictor() end)
	U.forEach(nonVictors, function(color)
		local player = Player[color]
		if player == nil then return end
		local playerHaven = getObjectFromGUID(G.playerObjs[color].haven)
		local oblData = U.filter(playerHaven.getObjects(), function(objData)
			return U.isIn("Obligation", objData.tags)
		end)
		if #oblData == 0 then return end
		local oblGUID = oblData[math.random(#oblData)].guid
		playerHaven.takeObject({
			guid = oblGUID,
			callback_function = function(card)
				showObligationToPlayer(color, card, "Green")
			end
		})
	end)
end

function M.clearAllTokens()
	U.forEach(getObjectsWithTag("Power"), function(token) if token.type == "Generic" then token.destruct() end end)
	U.forEach(getObjectsWithTag("Infamy"), function(token) if token.type == "Generic" then token.destruct() end end)
	U.forEach(getObjectsWithTag("ExhaustTorpor"), function(token) if token.type == "Tile" then token.destruct() end end)
end

function M.gameMISSIONS()
	if (S.getStateVal("gamePhase") ~= "SCORING") then
		broadcastToColor("Game Phase is '" .. S.getStateVal("gamePhase") .. "', must be 'SCORING' to enter 'MISSIONS'", "Red", "Red")
		return
	end

  M.askLastChapterStandings(function()
		S.setStateVal("MISSIONS", "gamePhase")
		S.setStateVal(true, "playerZonesLocked")
		M.sequence({
			hideBloodlinesScore,
			M.showUpdatedTraits,
			Z.discardTorporedVamps,
			M.recallSchemeDiscard,
			M.presentLockedSchemesToVanquished,
			function() M.clearPlayerZones(1) end,
			M.hideVictoryBoard,
			function() M.resetBattleground("d") end,
			function() M.resetBattleground("f") end,
			M.clearAllTokens,
			M.showHavens,
			M.showPouches,
			M.presentObligationsToVictor,
			M.revealLostObligationsToNonVictors
		}, 1)
  end)
end

function M.recoverObligations()
	U.forEach(C.Colors, function(pColor)
		local aftermathZone = getObjectFromGUID(G.zones[pColor].aftermath)
		U.forEach(Z.getTaggedZoneObjects(aftermathZone, "Obligation"), function(obl)
			if obl == nil then return end
			obl.setLock(false)
			obl.highlightOff()
			if obl.hasTag("OblDraw") then
				local playerHaven = getObjectFromGUID(G.playerObjs[pColor].haven)
				obl.removeTag("OblDraw")
				playerHaven.putObject(obl)
			else
				obl.removeTag("OblDiscard")
				obl.setRotation(G.tableSpots.obligations.stagingRot)
				obl.setPositionSmooth(G.tableSpots.obligations.staging)
			end
		end)
	end)
end

function M.dealLettersOfIntroduction()
	for _, color in pairs(C.Colors) do
		local haven = getObjectFromGUID(G.playerObjs[color].haven)
		local havenObjGUIDs = U.map(U.filter(haven.getObjects(), function(obj)
			return U.isIn("LetterOfIntroduction", obj.tags)
		end), function(obj) return obj.guid end)
		U.forEach(havenObjGUIDs, function(guid)
			haven.takeObject({
				guid = guid,
				callback_function = function(obj)
					obj.deal(1, color)
				end
			})
		end)
	end
end

function M.sendRetainerToTable()
	for _, color in pairs(C.Colors) do
		local player = Player[color]
		local charsInHand = U.filter(player.getHandObjects(), function(obj) return obj.hasTag("Character") end)
		local pHaven = getObjectFromGUID(G.playerObjs[color].haven)
		local pos = pHaven.getPosition()
		pos.y = pos.y + 4
		U.forEach(charsInHand, function(charCard, i)
			charCard.use_hands = false
			charCard.setPosition(pos)
			charCard.setPositionSmooth({
				x = G.tableSpots.stagingArea[color].x + 2.5 * (i - 1),
				y = 1,
				z = G.tableSpots.stagingArea[color].z
			})
			charCard.setRotation({x = 0, y = 180, z = 0})
			Wait.time(function() charCard.use_hands = true end, 0.5)
		end)
	end
end

function M.gameAFTERMATH()
	if (S.getStateVal("gamePhase") ~= "MISSIONS") then
		broadcastToColor("Game Phase is '" .. S.getStateVal("gamePhase") .. "', must be 'MISSIONS' to enter 'AFTERMATH'", "Red", "Red")
		return
  end
	S.setStateVal("AFTERMATH", "gamePhase")

	M.sequence({
		-- M.hideUpdatedTraits,
		M.recoverObligations,
		M.dealLettersOfIntroduction,
		M.sendRetainerToTable,
		function()
			local schemeDeck = getSchemesDeck(M.getLastChapterVanquished())
			if schemeDeck ~= false then
				M.processDeck(schemeDeck, "unlockedScheme")
				-- M.processSchemesDeck(schemeDeck)
			end
		end,
		M.hidePouches,
		1,
		function()
			if obligationsDeck ~= nil then
				local mainStorage = getObjectFromGUID(G.mainStorage.id)
				mainStorage.putObject(obligationsDeck)
			end
		end,
		function()
			local lockedSchemeObjs = getObjectsWithTag("LockedScheme")
			if #lockedSchemeObjs == 1 and lockedSchemeObjs[1].type == "Deck" then
				getObjectFromGUID(G.mainStorage.id).putObject(lockedSchemeObjs[1])
			end
		end,
		function()
			U.forEach(C.Colors, function(color)
				local schemeDeck = getSchemesDeck(color)
				if schemeDeck then
					getObjectFromGUID(G.mainStorage.clanStorage[M.getClans()[color]]).putObject(schemeDeck)
				end
			end)
		end,
		1,
		M.showStickerUnlocks,
		function() M.clearPlayerZones(2) end,
		M.packObligations
		}
	)
end

function M.returnLettersOfIntroduction()
	U.forEach(C.Colors, function(color)
		local player = Player[color]
		local playerHaven = getObjectFromGUID(G.playerObjs[color].haven)
		local lettersInHand = U.filter(player.getHandObjects(), function(obj) return obj.hasTag("LetterOfIntroduction") end)
		U.forEach(lettersInHand, function(letter)
			playerHaven.putObject(letter)
		end)
	end)
end

function M.resetBattleground(bgRef)
	local bg = getObjectFromGUID(G.battlegrounds[bgRef])
	bg.call("Reset")
end

function M.resetBattlegrounds()
	local bgF = getObjectFromGUID(G.battlegrounds.f)
	local bgD = getObjectFromGUID(G.battlegrounds.d)
	local bgB = getObjectFromGUID(G.battlegrounds.b)
	M.sequence({
		function() bgD.call("Reset") end,
		function() bgF.call("Reset") end,
		function() bgB.call("Reset") end
	}, 1)
end

function M.gameEND()
	if (S.getStateVal("gamePhase") ~= "AFTERMATH") then
		broadcastToColor("Game Phase is '" .. S.getStateVal("gamePhase") .. "', must be 'AFTERMATH' to enter 'END'", "Red", "Red")
		return
	end
	S.setStateVal("END", "gamePhase")

	M.sequence({
		M.showUpdatedTraits,
		M.returnLettersOfIntroduction,
		M.packObligations,
		function() M.clearPlayerZones(3) end,
		M.packClanStorageBoxes,

		function()
			S.resetGameState()
			M.showHavens()
			M.showPouches()
		end
	}, 1)
end

function M.packObligations()
	local oblDeck = U.filter(getObjectsWithTag("Obligation"), function(obj) return obj.type == "Deck" end)[1]
	if oblDeck == nil then return end
	local mainStorage = getObjectFromGUID(G.mainStorage.id)
	mainStorage.putObject(oblDeck)
end

function M.packClanStorageBoxes()
  local mainStorage = getObjectFromGUID(G.mainStorage.id)
  for color, clan in pairs(M.getClans()) do
    local clanChest = getObjectFromGUID(G.mainStorage.clanStorage[clan])
    mainStorage.putObject(clanChest)
  end
end

function M.clearPlayerZones(clearanceLevel)
	-- Clearance Level 1 (default) --> Power, Infamy, Exhaustion, Boons, Morality, Ankhs
	-- Clearance Level 2 --> Clan Leader
	-- Clearance Level 3 --> Torpor, Characters
	if (not clearanceLevel) then clearanceLevel = 1 end
	local characterDeckSpot = getObjectFromGUID(G.decks.characterSpot)
	local characterDeck = U.findAboveObject(characterDeckSpot, "Deck")[1]
	local characterDiscardDeck = U.findAboveObject(getObjectFromGUID(G.decks.characterDiscardSpot), "Deck")[1]
	if (characterDiscardDeck) then
		if (characterDeck) then
			characterDeck.putObject(characterDiscardDeck)
		else
			local charDeckPos = characterDeckSpot.getPosition()
			charDeckPos.y = charDeckPos.y + 1
			characterDiscardDeck.setRotation({x = 0, y = 180, z = 180})
			characterDiscardDeck.setPosition(charDeckPos)
			characterDeck = characterDiscardDeck
		end
	else
		local charDiscard = U.findAboveObject(getObjectFromGUID(G.decks.characterDiscardSpot), "Card")[1]
		if (charDiscard) then
			characterDeck.putObject(charDiscard)
		end
	end

	local playerPouches = U.map(C.Colors,
		function(color) return getObjectFromGUID(G.playerObjs[color].pouch) end)

	local clanChests = {}

	for _, clan in pairs(M.getClans()) do
		clanChests[clan] = getObjectFromGUID(G.mainStorage.clanStorage[clan])
	end

	-- log({clanChests = clanChests})

	U.forEach(Z.getCharQueueCards(), function(card)
		characterDeck.putObject(card)
	end)

	-- U.forEach(Z.getTaggedZoneObjects(charQueueZone, {"Character"}),
	-- 	function(charCard) characterDeck.putObject(charCard) end)


	U.forEach(getObjectsWithTag("Boon"), function(obj)
		if obj.type == "Tile" then
			clanChests[string.gsub(obj.getName(), " Boon", "")].putObject(obj)
		end
	end)


	U.forEach(C.Colors,
		function(pColor)
			local pZone = getObjectFromGUID(G.zones[pColor].aftermath)
			local pChest = getObjectFromGUID(G.mainStorage.clanStorage[M.getClans()[pColor]])
			local pHaven = getObjectFromGUID(G.playerObjs[pColor].haven)
			local pPouch = getObjectFromGUID(G.playerObjs[pColor].pouch)

			local function sendBoonsHome(boons)
				local boonsByClan = {}
				U.forEach(boons, function(boon)
					if boon.type ~= "Tile" then return end
					local boonClan = string.gsub(boon.getName(), " Boon", "")
					if not U.isIn(boonClan, C.Clans) then return end
					if boonsByClan[boonClan] == nil then boonsByClan[boonClan] = {} end
					table.insert(boonsByClan[boonClan], boon)
				end)
				U.forEach(boonsByClan, function(boons, clan)
					local pColor = getColorOfClan(clan)
					local leaderCard = Z.getClanLeader(pColor)
					local leaderPos = leaderCard.getPosition()
					leaderPos.y = leaderPos.y + 1
					local clanBoonPos = {
						{x = leaderPos.x + 2, y = leaderPos.y, z = leaderPos.z - 1},
						{x = leaderPos.x + 2, y = leaderPos.y, z = leaderPos.z},
						{x = leaderPos.x + 2, y = leaderPos.y, z = leaderPos.z + 1}
					}
					U.forEach(boons, function(boon, i)
						boon.setPositionSmooth(clanBoonPos[i])
					end)
				end)
			end

			-- sendBoonsHome(getObjectsWithTag("Boon"))

			local moralityToken = getMoralityToken(pColor)
			if moralityToken ~= nil then pChest.putObject(moralityToken) end

			if clearanceLevel < 2 then return end

			U.forEach(Z.getTaggedZoneObjects(pZone, {"ClanLeader"}),
				function(leaderCard)
					leaderCard.removeTag("TopChar")
					local leaderColor = U.findColorTag(leaderCard)
					if leaderColor then pPouch.putObject(leaderCard)
					else pChest.putObject(leaderCard) end
				end)

			if clearanceLevel < 3 then return end

			U.forEach(Z.getTaggedZoneObjects(pZone, "Character"),
				function (charCard)
					charCard.setLock(false)
					charCard.removeTag("TopChar")
					charCard.removeTag("Monstrosity_1")
					charCard.removeTag("Monstrosity_2")
					charCard.removeTag("Monstrosity_3")
					charCard.removeTag("Monstrosity_4")
					local yAngle = U.pAngle(charCard.getRotation().y, 90)
					if yAngle == 90 or yAngle == 270 then
						charCard.setRotationSmooth({x = 0, y = 180, z = 0})
						pHaven.putObject(charCard)
					else
						characterDeck.putObject(charCard)
					end
				end)
		end)
end

function M.highlightBattlegrounds()
	for _, loc in pairs({"left", "center", "right"}) do
		M.setHighlighter("BGIndicator", "active", loc)
	end
end

-- *** GAME STATE VALUE CONTROL ***

function M.syncState()
    local clans = M.getClans()
    if (clans == nil) then S.setStateVal("clans", {Red = nil, Yellow = nil, Blue = nil}) end
    clans = M.getClans()

    M.determineTurnOrder(function()
      M.syncTurnOrder()
      local lastChapterStandings = M.getLastChapterStandings()
      local round, turn = M.getRoundAndTurn()
      local clans = M.getClans()
      local turnOrder = M.getTurnOrder()
      if (round > 0 and round < 10) then
        M.readTurnOrderFromBG()
      end

			for i = 1, 3, 1 do
				if lastChapterStandings[i] ~= nil then
        	UI.setValue("lastChapterStandingsNotice-subtitle" .. i, C.Names[lastChapterStandings[i]])
        	UI.setAttribute("lastChapterStandingsNotice-subtitle" .. i, "color", lastChapterStandings[i])
				end
      end

      for _, color in ipairs(turnOrder) do
        if (clans[color] ~= nil) then
          UI.setValue(color .. "ClanChoice", C.Names[color] .. " chooses Clan " .. clans[color])
        end
      end

			if lastChapterStandings[3] ~= nil then
      	UI.setValue("lastChapterStandingsNotice-subtitle5", C.Names[lastChapterStandings[3]])
      	UI.setAttribute("lastChapterStandingsNotice-subtitle5", "color", lastChapterStandings[3])
			end

      -- S.refreshStateDebug(state)

      M.setHighlighter("ClanSelection", "inactive")
      M.setHighlighter("TurnIndicator", "inactive", "Red")
      M.setHighlighter("TurnIndicator", "inactive", "Yellow")
      M.setHighlighter("TurnIndicator", "inactive", "Blue")

      if (round == 0) then
        if (clans.Red or clans.Yellow or clans.Blue) then
          local clanChooser = M.getNextPlayer()
          if (clanChooser ~= nil) then
            M.setHighlighter("ClanSelection", "active")
            M.setHighlighter("TurnIndicator", "strong", clanChooser)
            UI.setValue("chooseClanPlayer", C.Names[clanChooser])
            UI.setAttribute("chooseClanPlayer", "color", clanChooser)
            U.splashUIElement("chooseClanNotice", 5)
          end
          for color, clan in pairs(clans) do
            if (clan ~= nil) then
              UI.show(color .. "ClanChoice")
            else
              UI.hide(color .. "ClanChoice")
            end
          end
          UI.show("clanChoiceAlert")
        end
      else
        -- UI.hide("setupReminder")
        UI.hide("clanChoiceAlert")
      end

      if (round >= 1 and round <= 9) then
        UI.show("turnTracker")
        M.syncTurnTracker()
      else
        UI.hide("turnTracker")
      end
  end)
end

function M.refresh() M.syncState() end

function M.setHighlighter(ref, mode, subRef)
  -- local round, turn = H.getRoundAndTurn()
    local obj
    if (ref == "ClanSelection") then
        obj = getObjectFromGUID(G.highlighters.clanSelection)
        obj.setPosition(G.tableSpots.highlighters.clanSelection[mode])
    elseif (ref == "TurnIndicator") then
      -- if round > 9 then
        -- mode = "inactive"
      -- end
      if not subRef then
        for _, color in pairs({"Red", "Yellow", "Blue"}) do
          M.setHighlighter(ref, mode, color)
          return
        end
      end
      obj = getObjectFromGUID(G.highlighters.turnIndicator[subRef])
      obj.setPosition(G.tableSpots.highlighters.turnIndicator[subRef][mode])
    elseif (ref == "BGIndicator") then
      -- if round > 9 then
        -- mode = "inactive"
      -- end
      if not subRef then
        for _, loc in pairs({"left", "center", "right"}) do
          M.setHighlighter(ref, mode, loc)
          return
        end
      end
      obj = getObjectFromGUID(G.highlighters.bgIndicator[subRef])
      obj.setPosition(G.tableSpots.highlighters.bgIndicator[subRef][mode])
    end

    if (mode == "inactive") then
        obj.setInvisibleTo({"Red","Blue","Yellow"})
    else
        obj.setInvisibleTo({})
    end
end

function M.processContainer(container, objCat, destContainer)
	-- local containerPos = container.getPosition()
	-- containerPos.y = containerPos.y + 4

	local objGUIDs = U.map(container.getObjects(), function(obj) return obj.guid end)
	local index = 1


	local function processNextObj()
		container.takeObject({
			guid = objGUIDs[index],
			smooth = false,
			callback_function = function(obj)
				if M.processObj(obj, objCat) == false then
					return U.alertGM("STOPPING: Error processing container object.")
				end
				container.putObject(obj)
				index = index + 1
				if objGUIDs[index] ~= nil then
					processNextObj()
				end
			end
		})
	end

	processNextObj()
end

function M.processDeck(deck, cardCat, dest)

	if dest == nil then
		dest = deck.getPosition()
		dest.y = dest.y + 4
	end

	local function processNextCard(remainderCard)
		dest.y = dest.y + 0.04
		if remainderCard ~= nil then
			remainderCard.setPosition(dest)
			if M.processObj(remainderCard, cardCat) == false then
				U.alertGM("Error processing final card in deck.")
			end
		else
			deck.takeObject({
				position = dest,
				top = false,
				smooth = false,
				callback_function = function(card)
					if M.processObj(card, cardCat) == false then
						return U.alertGM("STOPPING: Error processing most recent card moved.")
					end
					if deck.remainder then
						processNextCard(deck.remainder)
					else
						processNextCard()
					end
				end
			})
		end
	end

	processNextCard()
end




function M.processObj(obj, objCat)
	if objCat == nil then
		if obj.hasTag("Mission") then objCat = "mission"
		elseif obj.hasTag("LockedScheme") then objCat = "lockedScheme"
		elseif obj.hasTag("ClanScheme") then objCat = "unlockedScheme"
		elseif obj.hasTag("ChapterCard") then objCat = "chapter"
		elseif obj.hasTag("letterOfIntroduction") then objCat = "letterOfIntroduction"
		elseif obj.hasTag("ClanLeader") then objCat = "clanLeader"
		elseif obj.hasTag("Character") then objCat = "character"
		elseif obj.hasTag("Asset") then objCat = "asset"
		elseif obj.hasTag("Obligation") then objCat = "obligation"
		elseif obj.hasTag("EraCard") then objCat = "era"
		elseif obj.hasTag("StrandsOfTime") then objCat = "strand"
		end
	end

	if objCat == nil then return false end

	if objCat == "mission" then
		obj.auto_raise = true
		obj.drag_selectable = false
		obj.grid_projection = false
		obj.sticky = true
		obj.tooltip = false
		obj.use_hands = false
		obj.hide_when_face_down = false
		obj.setTags({"Mission"})
		obj.tooltip = false
	elseif objCat == "unlockedScheme" then
		local clan = U.findClanTag(obj)
		if clan == nil then return false end
		obj.auto_raise = true
		obj.drag_selectable = false
		obj.grid_projection = false
		obj.sticky = false
		obj.tooltip = false
		obj.use_hands = true
		obj.hide_when_face_down = true
		obj.setTags({"Card", "ClanScheme", clan})
	elseif objCat == "lockedScheme" then
		local clan = U.findClanTag(obj)
		if clan == nil then return false end
		obj.auto_raise = true
		obj.drag_selectable = false
		obj.grid_projection = false
		obj.sticky = false
		obj.tooltip = false
		obj.use_hands = true
		obj.hide_when_face_down = true
		obj.setTags({"Card", "ClanScheme", clan, "LockedScheme"})
	elseif objCat == "chapter" then
		obj.auto_raise = true
		obj.drag_selectable = false
		obj.grid_projection = false
		obj.sticky = false
		obj.tooltip = false
		obj.use_hands = false
		obj.hide_when_face_down = true
		obj.setTags({"ChapterCard"})
	elseif objCat == "letterOfIntroduction" then
		obj.auto_raise = true
		obj.drag_selectable = false
		obj.grid_projection = false
		obj.sticky = false
		obj.tooltip = false
		obj.use_hands = true
		obj.hide_when_face_down = true
		obj.setTags({"Card", "LetterOfIntroduction"})
	elseif objCat == "character" then
		if obj.hasTag("ClanLeader") then return false end
		obj.auto_raise = true
		obj.drag_selectable = false
		obj.grid_projection = false
		obj.sticky = true
		obj.tooltip = false
		obj.use_hands = true
		obj.hide_when_face_down = true
		obj.setTags({"Card", "Character"})
	elseif objCat == "clanLeader" then
		local clan = U.findClanTag(obj)
		if clan == nil then return false end
		obj.auto_raise = true
		obj.drag_selectable = false
		obj.grid_projection = false
		obj.sticky = true
		obj.tooltip = false
		obj.use_hands = false
		obj.hide_when_face_down = false
		local tags = {"Card", "ClanLeader", clan}
		if obj.hasTag("DoubleSided") then table.insert(tags, "DoubleSided")
		elseif obj.hasTag("Red") then table.insert(tags, "Red")
		elseif obj.hasTag("Yellow") then table.insert(tags, "Yellow")
		elseif obj.hasTag("Blue") then table.insert(tags, "Blue") end
		obj.setTags(tags)
	elseif objCat == "asset" then
		obj.auto_raise = true
		obj.drag_selectable = true
		obj.grid_projection = false
		obj.sticky = false
		obj.tooltip = false
		obj.use_hands = true
		obj.hide_when_face_down = false
		obj.setTags({"Asset", "Card"})
	elseif objCat == "obligation" then
		obj.auto_raise = true
		obj.drag_selectable = false
		obj.grid_projection = false
		obj.sticky = false
		obj.tooltip = false
		obj.use_hands = true
		obj.hide_when_face_down = true
		obj.setTags({"Card", "Obligation"})
	elseif objCat == "era" then
		obj.auto_raise = true
		obj.drag_selectable = false
		obj.grid_projection = false
		obj.sticky = false
		obj.tooltip = false
		obj.use_hands = false
		obj.hide_when_face_down = true
		obj.setTags({"EraCard"})
	elseif objCat == "strand" then
		obj.auto_raise = true
		obj.drag_selectable = false
		obj.grid_projection = false
		obj.sticky = false
		obj.tooltip = false
		obj.use_hands = false
		obj.hide_when_face_down = false
		obj.setTags({"Card", "StrandsOfTime"})
	else
		return false
	end
	return true
end

local decksOnBoard = {}

function M.presentDeck(deckTags, playerColor, position, options)
  local mainStorage = getObjectFromGUID(G.mainStorage.id)
  if (position == nil) then
    position = G.tableSpots.deckStaging[playerColor]
  end
  local deckData = U.find(mainStorage.getObjects(), function (obj)
    for _, tag in pairs(deckTags) do
      if not U.isIn(tag, obj.tags) then return false end
    end
    return true
  end)
	if deckData == nil then return end
	local rotation = {x = 0, y = 180, z = 180}
	if options and options.isFlipped then
		rotation.z = 0
	end

  decksOnBoard[deckTags[1]] = mainStorage.takeObject({
      position = position,
      rotation = rotation,
			smooth = false,
      guid = deckData.guid,
			callback_function = function(deck)
				Wait.frames(function()
					if options and options.spread then
						decksOnBoard[deckTags[1]].spread(options.spread)
					end
				end)
			end
    })
	return decksOnBoard[deckTags[1]]
end

function M.presentLockedSchemesToVanquished()
	M.presentDeck({"ClanScheme", S.getStateVal("clans", M.getLastChapterVanquished())}, M.getLastChapterVanquished()).highlightOn("Orange")
end
function M.presentStrandsOfTimeToVanquished()
  M.presentDeck({"StrandsOfTime"}, M.getLastChapterVanquished(), G.tableSpots.strandsOfTime, {spread = -2.5})
end
function M.presentStrandsOfTimeToMiddle()
	local color = M.getLastChapterMiddle()
	local thirdChildeZone = getObjectFromGUID(G.zones[color].bloodline[2][3])
	local pos = thirdChildeZone.getPosition()
	pos.y = 1
  M.presentDeck({"StrandsOfTime"}, color, pos, {spread = -2.5})
end

function M.hideUnusedStrandsOfTime(usedGuid)
  local round, turn = M.getRoundAndTurn()
  if (round ~= 0) then return end
  local strandObjs = getObjectsWithTag("StrandsOfTime")
  local cardPos = getObjectFromGUID(G.decks.unusedStrandsOfTime).getPosition()
  cardPos.y = cardPos.y + 1
  for _, card in pairs(strandObjs) do
    if card.guid ~= usedGuid then
      card.setRotation({x = 0, y = 180, z = 0})
      card.setPosition(cardPos)
    end
  end
end




function M.ignorePlayerTurn(currentTurnColor)
  local round, turn = M.getRoundAndTurn()
    if (round == 0) then return true end
    local turnOrder = M.getTurnOrder()
    local curColor = turnOrder[turn] or "NULL"
    if (M.getTurnOrder()[turn] == currentTurnColor) then return true end
    return false
end

function M.setCamera(player, zoomTarget)
	if player == nil or player == "ALL" then return U.forEach(C.Colors, function(color) M.setCamera(color, zoomTarget) end) end
	if type(player) == "string" then player = Player[player] end
  Player[player.color].setCameraMode("ThirdPerson")
  Player[player.color].lookAt(C.CameraAngles[zoomTarget])
  Wait.time(function() Player[player.color].setCameraMode("ThirdPerson") end, 0.5)
end

function M.askTraitsUpdate()
  local hostPlayer = U.getHost()
  local playerOptions = {"Gaius Marcellus", "Baron Samedi", "Jalan-Aayav"}
  local traitOptions = {"Kindred", "Mortals", "Wealth", "Subterfuge", "Warfare", "Occult", "Cruelty", "Mercy", "Detachment", "Camarilla", "Sabbat", "Anarchs", "Animalism", "Auspex", "Celerity", "Dominate", "Fortitude", "Obfuscate", "Oblivion", "Potence", "Presence", "Protean", "Blood_Sorcery"}
  hostPlayer.showOptionsDialog("Whose trait is increasing?", playerOptions, 1,
    function (playerName, _)
      hostPlayer.showOptionsDialog("What trait has increased?", traitOptions, 1,
        function (trait, index)
          local color
          if (playerName == "Gaius Marcellus") then color = "Red" end
          if (playerName == "Baron Samedi") then color = "Yellow" end
          if (playerName == "Jalan-Aayav") then color = "Blue" end
          M.addTraitDot(color, trait)
        end
      )
    end
  )
end

function M.addTraitDot(color, trait, rowNum)
  local playerData = S.getStateVal("traits", color)
  -- log("Player Data for " .. color .. ", Adding to '" .. trait .. "'")
  -- log(playerData)
  for i = 1, 5, 1 do
    -- log(playerData[i])
    for traitName, traitVal in pairs(playerData[i]) do
      -- log("... traitName = " .. traitName .. ", traitVal = " .. traitVal)
      if (trait == traitName) then
        -- log("MATCH!")
        playerData[i][traitName] = playerData[i][traitName] + 1
        S.setStateVal(playerData, "traits", color)
        M.showUpdatedTraits(color)
        return
      end
    end
  end
end

local function parseTraitsToXMLTable(traitsTable)
  local function countTraitRows(ttable)
    local rowCount = 0
    for _, rowData in pairs(ttable) do
      if (U.count(U.filter(rowData, function(tVal) return tVal > 0 end)) > 0) then
        rowCount = rowCount + 1
      end
    end
    return rowCount
  end

  local XMLTable = {
    {
      tag = "Defaults",
      children = {
        {
          tag = "Panel",
          attributes = {
            class = "traits",
            color = "#000000",
            height = tostring(countTraitRows(traitsTable) * 60),
            width = "740",
            scale = "0.25 0.25 0.25 0.25",
            position = "45 35 -15",
            rotation = "0 0 180",
            -- active = "false",
            showAnimation = "FadeIn",
            hideAnimation = "FadeOut",
            animationDuration = "2"
          }
        },
        {
          tag = "Text",
          attributes = {
            color = "#999999",
            fontSize = "32",
            fontStyle = "Bold",
            flexibleWidth = "0"
          }
        },
        {
          tag = "Text",
          attributes = {
            class = "gold",
            color = "#FFFF00"
          }
        }
      }
    },
    {
      tag = "Panel",
      attributes = {
        class = "traits"
      },
      children = {
        {
          tag = "VerticalLayout",
          children = {}
        }
      }
    }
  }

  local function parseRow(rowTable, class)
		local hasNonZeroChildren
    local rowXMLTable = {
      tag = "HorizontalLayout",
      children = {}
    }
    if class == nil then class = "" end
    for traitName, traitNum in pairs(rowTable) do
      if (traitNum > 0) then
        hasNonZeroChildren = true
				if C.TraitAbbvs[traitName] ~= nil then
					traitName = C.TraitAbbvs[traitName]
				end
        table.insert(rowXMLTable.children,
          {
            tag = "Text",
            value = string.gsub(traitName, "_", " ") .. " " .. traitNum,
            attributes = {class = class}
          })
      end
    end
    if (hasNonZeroChildren) then return rowXMLTable end
    return false
  end

  for index, rowData in pairs(traitsTable) do
    local class
    if (index < #traitsTable) then
      class = "gold"
    else
      class = ""
    end
    local rowXML = parseRow(rowData, class)
    if (rowXML) then
      table.insert(XMLTable[2].children[1].children, parseRow(rowData, class))
    end
  end

  return XMLTable
end

function M.showUpdatedTraits(playerColor)
	if playerColor == nil then return U.forEach(C.Colors, function(color) M.showUpdatedTraits(color) end) end
  local playerBoard = getObjectFromGUID(G.playerCards[playerColor])
  local playerData = S.getStateVal("traits", playerColor)
  local playerXML = parseTraitsToXMLTable(playerData)
  -- log(JSON.encode_pretty(playerXML))
  playerBoard.UI.setXmlTable(playerXML)
  Wait.time(function() playerBoard.UI.show("traits") end, 1)
end

function M.hideUpdatedTraits(playerColor)
	if playerColor == nil then return U.forEach(C.Colors, function(color) M.hideUpdatedTraits(color) end) end
  local playerBoard = getObjectFromGUID(G.playerCards[playerColor])
  playerBoard.UI.setXmlTable({{}})
end

local function parseStickersToXMLTable(stickerData, playerColor)
	local function parseAbilityStickerRows()
		local vertChildren = {}
		local index = 1
		while stickerData[index] ~= nil do
			local start, finish = index, index + 3
			local vertChild = {
				tag = "HorizontalLayout",
				children = {}
			}
			for i = start, finish do
				if stickerData[i] == nil then break end
				index = index + 1
				local thisElem = {
					tag = "Text",
					value = "",
					attributes = {}
				}
				local thisSticker = stickerData[i]
				local name = string.sub(thisSticker, 1, #thisSticker - 1)
				local val = string.sub(thisSticker, -1)
				thisElem.value = name .. " " .. val
				if C.TraitAbbvs[name] == nil then
					thisElem.attributes.class = "gold"
				end
				table.insert(vertChild.children, thisElem)
			end
			table.insert(vertChildren, vertChild)
		end
		-- log(JSON.encode_pretty(vertChildren))
		return vertChildren
	end
	local function parseClanStickerRow()
		local clan = M.getClans()[playerColor]
		-- log({color = playerColor, clan = clan})
		local clanStickersUsed = S.getStateVal("usedClanStickers", clan)
		local clanStickersAvailable = 6 - clanStickersUsed
		local clanMessage
		if clanStickersAvailable == 1 then
			clanMessage = "There is 1 " .. clan .. " sticker left."
		elseif clanStickersAvailable == 0 then
			clanMessage = "There are no " .. clan .. " stickers left."
		else
			clanMessage = "There are " .. clanStickersAvailable .. " " .. clan .. " stickers left."
		end
		return {
			{
				tag = "Text",
				attributes = {
					color = "#FFFFFF",
					fontSize = "36",
					ignoreLayout = "true",
					height = "50",
					rectAlignment = "LowerCenter"
				},
				value = clanMessage,
				children = {}
			}
		}
	end
	local numRows = 1 + math.ceil(#stickerData / 4) + 1
	local XMLTable = {
    {
      tag = "Defaults",
      children = {
        {
          tag = "Panel",
          attributes = {
            class = "traits",
            color = "#000000",
            height = "400",
            width = "800",
						padding = "0 0 50 50",
            scale = "0.25 0.25 0.25 0.25",
            position = "35 35 -15",
            rotation = "0 0 180",
            -- active = "false",
            showAnimation = "FadeIn",
            hideAnimation = "FadeOut",
            animationDuration = "2",
						-- childAlignment = "UpperCenter",
						-- childForceExpandHeight = "false"
          }
        },
				{
					tag = "VerticalLayout",
					attributes = {
						childAlignment = "UpperCenter",
						childForceExpandHeight = "false"
					}
				},
				{
					tag = "HorizontalLayout",
					attributes = {
						flexibleHeight = "0",
						preferredHeight = "50"
					}
				},
        {
          tag = "Text",
          attributes = {
            color = "#999999",
            fontSize = "32",
            fontStyle = "Bold",
            flexibleWidth = "0",
						flexibleHeight = "0",
						preferredHeight = "50"
          }
        },
        {
          tag = "Text",
          attributes = {
            class = "gold",
            color = "#FFFF00"
          }
        }
      }
    },
    {
      tag = "Panel",
      attributes = {
        class = "traits"
      },
      children = {
        {
          tag = "VerticalLayout",
          children = U.concat(
						U.concat({
							{
								tag = "Text",
								attributes = {
									color = "#FFFFFF",
									fontSize = "36"
								},
								value = "Available Ability Stickers:",
								children = {}
							},
							{
								tag = "Text",
								attributes = {
									color = "#FFFFFF",
									fontSize = "36"
								},
								value = "",
								flexibleHeight = "0",
								preferredHeight = "50",
								children = {}
							}
						},
						parseAbilityStickerRows()),
						parseClanStickerRow()
					)
        }
      }
    }
  }
	return XMLTable
end

function M.showStickerUnlocks(playerColor)
	-- log(playerColor)
	if playerColor == nil then return U.forEach(C.Colors, function(color) M.showStickerUnlocks(color) end) end
	local playerBoard = getObjectFromGUID(G.playerCards[playerColor])
	-- log(playerBoard)
	-- playerBoard.UI.hide("traits")
	local traitStrings = {}
	local playerTraits = S.getStateVal("traits", playerColor)
	U.forEach(playerTraits, function(traitCat)
		U.forEach(traitCat, function(tVal, tName)
			for i = 1, tVal do
				table.insert(traitStrings, tName .. i)
			end
		end)
	end)
	Wait.time(function()
		local availableStickers = U.filter(traitStrings, function(tString)
			return not U.isIn(tString, S.getStateVal("usedAbilityStickers"))
		end)
		Wait.time(function()
			-- log(availableStickers)
			local playerXML = parseStickersToXMLTable(availableStickers, playerColor)
			playerBoard.UI.setXmlTable(playerXML)
			-- Wait.time(function() playerBoard.UI.show("traits") end, 1)
			-- log(availableStickers)
		end, 0.25)
	end, 0.25)
end

return M
