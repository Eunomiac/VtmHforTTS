local M
local G = require("lib.guids")
local U = require("lib.utilities")
local C = require("lib.constants")
local BGE = require("battlegrounds.bgE")

local Z = {}

local uiData = {}
local maxInfamy = 0
local isCheckingSuspicion = false

function Z.onLoad()
	M = Global.getTable("M")
	-- log("[ZONES]: " .. M.getStateVal("gamePhase"))
	Z.refreshUI()
end

local zoneTags = {
	aftermath = {"Obligation"}
}

local function getStateVal(key, subKey)
	return M.getStateVal(key, subKey)
  -- local state = Global.getTable("gameState")
  -- if not state[key] then return state[key] end
  -- if subKey then return state[key][subKey] end
  -- return state[key]
end

local function setStateVal(value, key, subKey)
  local state = Global.getTable("gameState")
  if (subKey) then
      if (state[key] == nil) then state[key] = {} end
      state[key][subKey] = value
  else
      state[key] = value
  end
  Global.setTable("gameState", state)
end

local function isInPhase(phases)
	if type(phases) == "string" then phases = {phases} end
	return U.isIn(getStateVal("gamePhase"), phases)
end

local function getZoneColor(zone)
	if U.isIn(zone.guid, U.flatten(G.zones.Red)) then return "Red"
	elseif U.isIn(zone.guid, U.flatten(G.zones.Yellow)) then return "Yellow"
	elseif U.isIn(zone.guid, U.flatten(G.zones.Blue)) then return "Blue" end
end

local function getZoneBounds(zone)
	local zoneExtent = U.map(zone.getScale(), function(val) return 0.5 * val end)
	local zonePos = zone.getPosition()
	-- log({extent = zoneExtent, pos = zonePos})
	return U.map(zonePos, function(coord, axis) return {min = coord - zoneExtent[axis], max = coord + zoneExtent[axis]} end)
	-- return {
	-- 	x = U.map(zonePos.x, function(coord) return {min = zonePos.x - zoneExtent.x, max = zonePos.x + zoneExtent.x} end),
	-- 	y = U.map(zonePos.y, function(coord) return {min = zonePos.y - zoneExtent.y, max = zonePos.y + zoneExtent.y} end),
	-- 	z = U.map(zonePos.z, function(coord) return {min = zonePos.z - zoneExtent.z, max = zonePos.z + zoneExtent.z} end)
	-- }
end

local function isInside(zone, pos, ignoreY)
	if ignoreY == nil then ignoreY = true end
	-- log({zone = zone, pos = pos})
	local zoneBounds = getZoneBounds(zone)
	-- log({zoneBounds = zoneBounds, pos = pos})
	return pos.x >= zoneBounds.x.min and pos.x <= zoneBounds.x.max
		and (ignoreY or pos.y >= zoneBounds.y.min and pos.y <= zoneBounds.y.max)
		and pos.z >= zoneBounds.z.min and pos.z <= zoneBounds.z.max
end

function Z.getSnapPointsInZone(zone, object)
	if object == nil then object = Global end
	local snapPoints = object.getSnapPoints()
	-- log(snapPoints)
	local validSnapPoints = {}
	for _, point in pairs(snapPoints) do
		-- log({point = point})
		if isInside(zone, object.positionToWorld(point.position)) then
			-- log("IS INSIDE!")
			table.insert(validSnapPoints, point)
		end
	end
	return validSnapPoints
end

function Z.dimBattleground(zone)

	local function dimBG(loc)
		local highlighter = getObjectFromGUID(G.highlighters.bgIndicator[loc])
		highlighter.setPosition(G.tableSpots.highlighters.bgIndicator[loc].inactive)
		highlighter.setInvisibleTo({"Red", "Blue", "Yellow"})
	end
	if U.isIn(zone.guid, G.zones.battlegroundZones.left) then
		dimBG("left")
	elseif U.isIn(zone.guid, G.zones.battlegroundZones.center) then
		dimBG("center")
	elseif U.isIn(zone.guid, G.zones.battlegroundZones.right) then
		dimBG("right")
	end
end

function Z.hideZones()
	local zones = U.filter(getObjects(), function(obj) return obj.type == "Scripting" end)
	setStateVal(true, "allZonesLocked")
	Wait.time(function()
		U.forEach(zones, function(zone)
			local zonePos = zone.getPosition()
			if zonePos.y < 30 then
				zonePos.y = zonePos.y + 50
			end
			zone.setPosition(zonePos)
		end)
	end, 0.25)
end

function Z.activateZones()
	local zones = U.filter(getObjects(), function(obj) return obj.type == "Scripting" end)
	if #zones > 0 and zones[1].getPosition().y > 30 then
		U.forEach(zones, function(zone)
			local zonePos = zone.getPosition()
			zonePos.y = zonePos.y - 50
			zone.setPosition(zonePos)
		end)
	end
	Wait.time(function()
		setStateVal(false, "allZonesLocked")
	end, 0.25)
end

-- *** Events ***
local zoneThrottle = {}
local function throttleZone(zone, func, delay)
	if delay == nil then delay = 0.4 end
	zoneThrottle[zone.guid] = true
	Wait.time(function()
		func()
		zoneThrottle[zone.guid] = nil
	end, delay)
end

local function isThrottled(zone) return zoneThrottle[zone.guid] == true end

function Z.onObjectEnterZone(zone, object)
	if M == nil then return end
	if M.getStateVal("allZonesLocked") == true then return end
	if isThrottled(zone) then return end
	if Z.isPlayerCardZone(zone) then
		if getStateVal("playerZonesLocked") == true then return end
		throttleZone(zone, function()
			Z.alignCard(zone)
			Wait.time(function() Z.refreshUI(zone) end, 0.5)
			if isInPhase("INIT") and object.hasTag("ClanLeader") then
				local color = getZoneColor(zone)
				if color == nil then return end
				M.updateMoralityToken(color)
			end
			if not isInPhase("PLAY") then return end
			if object.type == "Card" then
				getObjectFromGUID(G.charQueue).call("Populate_Queue")
			end
			if isCheckingSuspicion and (object.hasTag("ExhaustTorpor") or object.hasTag("Infamy")) then
				Wait.time(function()
					if Z.isTorpored(zone) or object.hasTag("Infamy") then
						Z.hideSuspicion()
						getObjectFromGUID(G.battlegrounds.d).call("EndTrial")
					end
				end, 1)
			end
		end)
		return
	end
	if Z.isTokenClearZone(zone) then
		if object.hasTag("Power") or object.hasTag("Infamy") or object.hasTag("ExhaustTorpor") then
			object.destruct()
		end
		return
	end
	if not isInPhase("PLAY") then return end
	if Z.isBattlegroundZone(zone) then
		if not U.isIn(object.guid, U.flatten(G.highlighters.bgIndicator)) then
			Z.dimBattleground(zone)
		end
		if object.hasTag("ClassToken") and zone.guid == G.zones.bgDEndZone then
			if getObjectFromGUID(G.battlegrounds.d).call("CheckForTrial") == true then
				Z.showSuspicion()
			end
		end

		-- if object.hasTag("Ankh") and zone.guid == G.zones.bgEZones.Fire then
		-- 	local dir
		-- 	if object.hasTag("North") then dir = "North"
		-- 	elseif object.hasTag("South") then dir = "South"
		-- 	elseif object.hasTag("East") then dir = "East"
		-- 	elseif object.hasTag("West") then dir = "West"
		-- 	end

		-- 	-- Count ankhs in fire. If there are three, burn the fourth and announce it.
		-- 	if BGE.countBurnedAnkhs(dir) == 3 then
		-- 		if dir == "North" then
		-- 			UI.setAttributes("anarchRevoltText", {
		-- 				color = "#000000",
		-- 				outline = "#FFFFFF"
		-- 			})
		-- 			UI.setValue("anarchRevoltText", "London burns to the ground in the North!")
		-- 		elseif dir == "South" then
		-- 			UI.setAttributes("anarchRevoltText", {
		-- 				color = "#FFFFFF",
		-- 				outline = "#555555"
		-- 			})
		-- 			UI.setValue("anarchRevoltText", "Palermo burns to the ground in the South!")
		-- 		elseif dir == "East" then
		-- 			UI.setAttributes("anarchRevoltText", {
		-- 				color = "#D2691E",
		-- 				outline = "#8B4513"
		-- 			})
		-- 			UI.setValue("anarchRevoltText", "Prague burns to the ground in the East!")
		-- 		else
		-- 			UI.setAttributes("anarchRevoltText", {
		-- 				color = "#00FFFF",
		-- 				outline = "#008B8B"
		-- 			})
		-- 			UI.setValue("anarchRevoltText", "Madrid burns to the ground in the West!")
		-- 		end
		-- 		Wait.time(function()
		-- 			U.splashUIElement("anarchRevoltNotice", 3)
		-- 			local unburnedAnkh = BGE.getUnburnedAnkhs(dir)[1]
		-- 			if unburnedAnkh then
		-- 				BGE.burnAnkh(unburnedAnkh)
		-- 			end
		-- 		end, 1)
		-- 	end
		-- end
	end
end

function Z.onObjectLeaveZone(zone, object)
	if M == nil then return end
	if M.getStateVal("allZonesLocked") == true then return end
	if Z.isPlayerCardZone(zone) then
		if object.hasTag("Character") or object.hasTag("ClanLeader") then
			object.removeTag("TopChar")
			object.removeTag("Monstrosity_1")
			object.removeTag("Monstrosity_2")
			object.removeTag("Monstrosity_3")
			object.removeTag("Monstrosity_4")
		end
		if object.hasTag("ClanScheme") then object.setScale({1, 1, 1}) end
		Wait.time(function() Z.refreshUI(zone) end, 0.5)
		return
	end
	if not isInPhase("PLAY") then return end
	if Z.isCharQueueZone(zone) and object.type == "Card" then
		object.setRotation(U.pRotation(object.getRotation(), 180))
	elseif Z.isBattlegroundZone(zone) then
		if not U.isIn(object.guid, U.flatten(G.highlighters.bgIndicator)) then
			Z.dimBattleground(zone)
		end
	end
end

function Z.getPlayerZones(color)
	if color == nil then
		return U.map(G.zones.allPlayer, function(zoneID) return getObjectFromGUID(zoneID) end)
	else
		return U.map(G.zones[color].all, function(zoneID) return getObjectFromGUID(zoneID) end)
	end
end

-- *** Zone Type Checking ***
function Z.isPlayerCardZone(zone) return U.isIn(zone.guid, G.zones.allPlayer) end

function Z.isTokenClearZone(zone) return U.isIn(zone.guid, G.zones.clearZones) end

function Z.isBattlegroundZone(zone) return U.isIn(zone.guid, U.flatten(G.zones.battlegroundZones)) end

function Z.isCharQueueZone(zone) return zone.guid == G.zones.charQueueArea end

-- *** Zone Object Retrieval ***
function Z.getTaggedZoneObjects(zone, tags, requireAll)
	local zoneTags = zone.getTags()
	if type(tags) == "string" then tags = {tags} end
	zone.setTags(tags)
	local zoneObjs = U.filter(zone.getObjects(), function(obj) return U.hasAnyTag(obj, tags) end)
	if requireAll == true then
		zoneObjs = U.filter(zoneObjs, function(obj)
			for _, tag in pairs(tags) do
				if not obj.hasTag(tag) then return false end
			end
			return true
		end)
	end
	zone.setTags(zoneTags)
	return zoneObjs
end
function Z.getZoneObjects(zone, objType)
	return U.filter(zone.getObjects(true), function(obj) return obj.type == objType end)
end

function Z.OLD_getTaggedZoneObjects(zone, tags, requireAll)
	local zoneObjs = zone.getObjects()
	if type(tags) == "string" then return U.filter(zoneObjs, function(obj) return obj.hasTag(tags) end) end
	if requireAll == true then
		return U.filter(zoneObjs, function(obj)
			for _, tag in pairs(tags) do
				if not obj.hasTag(tag) then return false end
			end
			return true
		end
		)
	else
		return U.filter(zoneObjs, function(obj)
			for _, tag in pairs(tags) do
				if obj.hasTag(tag) then return true end
			end
			return false
		end
		)
	end
end

function Z.getCards(zone, tags)
	if tags == nil then tags = {"Character", "ClanLeader"}
	elseif type(tags) == "string" then tags = {tags} end
	return Z.getTaggedZoneObjects(zone, tags, false)
end
-- Z.getCard(zone)
-- returns the top card in zone, if there is one

function Z.getCard(zone)
	local cards = Z.getZoneObjects(zone, "Card")
	if #cards == 0 then return end
	if #cards == 1 then return cards[1] end
	-- table.sort({5, 2, 3, 1}, function(a, b) return b < a end) = {5, 3, 2, 1}

	table.sort(cards, function(a, b) return b.getPosition().y < a.getPosition().y end);

	return cards[1]
end

function Z.hasCard(zone) return Z.getCard(zone) ~= nil end

function Z.getDeck(zone) return Z.getZoneObjects(zone, "Deck")[1] end

function Z.getClanLeader(color)
	local leaderZone = getObjectFromGUID(G.zones[color].bloodline[1][1])
	return Z.getCard(leaderZone)
end

function Z.getAnkhs(zone, dir)
	return Z.getTaggedZoneObjects(zone, { "Ankh", dir }, true)
end

function Z.getPowerTokens(zone) return Z.getTaggedZoneObjects(zone, "Power") end

function Z.getInfamyTokens(zone) return Z.getTaggedZoneObjects(zone, "Infamy") end

function Z.getBoons(zone) return Z.getTaggedZoneObjects(zone, "Boon") end

local function getExhaustionTorporTokens(zone) return Z.getTaggedZoneObjects(zone, "ExhaustTorpor") end

function Z.getExhaustionTokens(zone)
	return U.filter(getExhaustionTorporTokens(zone), function(token) return not U.isFlipped(token) end)
end

function Z.getTorporTokens(zone)
	return U.filter(getExhaustionTorporTokens(zone), function(token) return U.isFlipped(token) end)
end

-- *** Zone Status Checking ***
function Z.isTorpored(zone) return Z.isPlayerCardZone(zone) and Z.hasCard(zone) and #Z.getTorporTokens(zone) > 0 end

function Z.isExhausted(zone) return Z.isPlayerCardZone(zone) and Z.hasCard(zone) and #Z.getExhaustionTokens(zone) > 0 end

function Z.isEnemy(zone) return Z.isPlayerCardZone(zone) and Z.hasCard(zone) and #Z.getTaggedZoneObjects(zone, {"ClanScheme", "Brujah"}, true) > 0 end

function Z.countPower(zone, isCountingTorpored)
	if Z.isPlayerCardZone(zone) and Z.hasCard(zone) then
		if isCountingTorpored or not Z.isTorpored(zone) then
			return #Z.getPowerTokens(zone)
		end
	end
	return 0
end

function Z.countInfamy(zone, isCountingTorpored)
	if Z.isPlayerCardZone(zone) and Z.hasCard(zone) then
		if isCountingTorpored or not Z.isTorpored(zone) then
			local function isIgnoringInfamy(card) return string.find(card.getDescription(), "IgnoreInfamyVP") end
			if #U.filter(Z.getCards(zone), isIgnoringInfamy) > 0 then
				if isInPhase("SCORING") then return 0 end
			end
			return #Z.getInfamyTokens(zone)
		end
	end
	return 0
end

function Z.countBoons(zone, isCountingTorpored)
	if Z.isPlayerCardZone(zone) and Z.hasCard(zone) then
		if isCountingTorpored or not Z.isTorpored(zone) then
			return #Z.getBoons(zone)
		end
	end
	return 0
end

-- *** Scoring Bloodline ***
function Z.scoreZone(zone) return Z.countPower(zone) + Z.countBoons(zone) - Z.countInfamy(zone) end

function Z.scoreBloodline(color)
	local scoreTotal = 0
	for _, zone in pairs(Z.getPlayerZones(color)) do
		scoreTotal = scoreTotal + Z.scoreZone(zone)
	end
	return scoreTotal
end

-- *** Overlays ***
local function initXML(zone)
	if uiData[zone.guid] == nil then uiData[zone.guid] = {} end
end

local function getStatusXML(statusData)
	local XML = {
		tag = "Panel",
		attributes = {
			class = "overlay",
			height = "100",
			padding = "0 0 0 0",
			position = "0 0 15",
			rotation = "0 0 0",
			spacing = "0",
			width = "100",
			color = statusData.color
		},
		children = {}
	}

	if statusData.torpor then
		table.insert(XML.children, {
			tag = "Image",
			attributes = {
				class = "torpor-overlay",
				image = "overlay-torpor",
				color = "rgba(1,1,1,0.95)"
			},
			children = {}
		})
	elseif statusData.exhaustion then
		table.insert(XML.children, {
			tag = "Image",
			attributes = {
				class = "exhaustion-overlay",
				image = "overlay-exhaustion",
				color = "rgba(1,1,1,0.95)"
			},
			children = {}
		})
	end

	if statusData.suspicion then
		XML = {
				tag = "Panel",
				attributes = {
					class = "main",
					height = "1000",
					width = "100",
					padding = "0 0 0 0",
					position = "0 0 -900",
					rotation = "-90 0 0"
				},
				children = {
					{
						tag = "Image",
						attributes = {
							height = "100",
							width = "100",
							scale = "2 2 2",
							image = "overlay-spotlight"
						},
						children = {}
					}
				}
			}
	end

	if statusData.enemy then
		table.insert(XML.children, {
			tag = "Image",
			attributes = {
				class = "enemy-overlay",
				image = "overlay-enemy",
				color = "rgba(1,1,1,1)"
			},
			children = {}
		})


	end

	return XML
end

local function getScoreXML(scoreData)

	scoreData.totalValue = scoreData.power + scoreData.boons - scoreData.infamy

	if scoreData.boons == 0 then
		scoreData.boons = ""
	elseif scoreData.power > 0 then
		scoreData.boons = "+" .. scoreData.boons
	end
	if scoreData.power == 0 then scoreData.power = "" end
	if scoreData.infamy == 0 then scoreData.infamy = "" else scoreData.infamy = "-" .. scoreData.infamy end
	if scoreData.totalValue == 0 then
		scoreData.totalValue = "~"
		if scoreData.infamy == "" and scoreData.power == "" and scoreData.boons == "" then
			return {
				tag = "Panel",
				attributes = {
					class = "main",
					height = "300",
					padding = "0 0 0 0",
					pivot = "0.5 0",
					position = "0 5 -300",
					rotation = "-85 0 0",
					spacing = "1",
					width = "100",
					outline = "#000000",
					outlineSize = "10",
					color = "rgba(0, 0, 0, 0.5)",
					childForceExpandHeight = "true",
					childForceExpandWidth = "true"
				},
				children = {
					{
						tag = "Panel",
						attributes = {
							class = "totalPanel",
							height = "150",
							rectAlignment = "MiddleCenter",
							width = "100",
							 ignoreLayout = "true",
							flexibleWidth="0",
							flexibleHeight="0",
							childForceExpandWidth="false",
							childForceExpandHeight="false"
						},
						children = {
							{
								tag = "Text",
								value = scoreData.totalValue,
									attributes = {
										id="totalCount",
										class = "totalCount",
										scale = "1.5 3 1.5",
										color = "#FFFFFF",
										fontSize = "40",
										fontStyle = "Bold",
										outline = "#FF0000",
										flexibleHeight="0",
										flexibleWidth="0"
									},
								children = {}
							}
						}
					}
				}
			}
		end
	end

	return {
		tag = "Panel",
		attributes = {
			class = "main",
			height = "300",
			padding = "0 0 0 0",
			pivot = "0.5 0",
			position = "0 5 -300",
			rotation = "-85 0 0",
			spacing = "1",
			width = "100",
			outline = "#000000",
			outlineSize = "10",
			color = "rgba(0.2, 0, 0, 0.5)",
			childForceExpandHeight = "true",
			childForceExpandWidth = "true"
		},
		children = {
			{
				tag = "Panel",
				attributes = {
					class = "powerPanel",
					height = "100",
					rectAlignment = "UpperLeft",
					width = "30"
				},
				children = {
					{
						tag = "Text",
						value = scoreData.power,
						attributes = {
							rectAlignment = "UpperRight",
							height = "50",
							class = "powerCount",
							scale = "1 4 1",
							color = "#FF0000",
							fontSize = "25",
							fontStyle = "Bold",
							outline = "#660000",
							id = "powerCount",
							flexibleHeight = "0",
							flexibleWidth = "0"
						},
						children = {}
					}
				}
			},
			{
				tag = "Panel",
				attributes = {
					class = "boonPanel",
					height = "100",
					rectAlignment = "UpperCenter",
					width = "30"
				},
				children = {
					{
						tag = "Text",
						value = "" .. scoreData.boons,
						attributes = {
							rectAlignment = "UpperCenter",
							height = "50",
							class = "boonCount",
							scale = "1 4 1",
							color = "#DDDDDD",
							fontSize = "25",
							fontStyle = "Bold",
							outline = "#999999",
							id = "boonCount",
							flexibleHeight = "0",
							flexibleWidth = "0"
						},
						children = {}
					}
				}
			},
			{
				tag = "Panel",
				attributes = {
					class = "infamyPanel",
					height = "100",
					rectAlignment = "UpperRight",
					width = "35"
				},
				children = {
					{
						tag = "Text",
						value = scoreData.infamy,
						attributes = {
							rectAlignment = "UpperLeft",
							height = "50",
							class = "infamyCount",
							scale = "1 4 1",
							color = "#FFFF00",
							fontSize = "25",
							fontStyle = "Bold",
							outline = "#555500",
							id = "infamyCount",
							flexibleHeight = "0",
							flexibleWidth = "0"
						},
						children = {}
					}
				}
			},
			{
				tag = "Panel",
			  attributes = {
			    class = "totalPanel",
			    height = "150",
			    rectAlignment = "LowerCenter",
			    width = "100",
					 ignoreLayout = "true",
			    flexibleWidth="0",
			    flexibleHeight="0",
			    childForceExpandWidth="false",
			    childForceExpandHeight="false"},
			  children = {
			    {
						tag = "Text",
			      value = scoreData.totalValue,
			        attributes = {
			          id="totalCount",
			          class = "totalCount",
								scale = "1.5 3 1.5",
			          color = "#FFFFFF",
			          fontSize = "40",
			          fontStyle = "Bold",
			          outline = "#FF0000",
			          flexibleHeight="0",
			          flexibleWidth="0"
			        },
			      children = {}
					}
			  }
			}
		}
	}
end

local function refreshStatusXML(zone)
	if isInPhase({"NONE", "SETUP"}) then
		uiData[zone.guid].statusXML = nil
		return
	end

	local statusData = {
		torpor = Z.isTorpored(zone),
		exhaustion = false,
		suspicion = false,
		enemy = Z.isEnemy(zone),
		monstrosity = false,
		color = "clear"
	}

	-- if statusData.torpor then
	-- 	Z.burnAnkhs(zone)
	-- end

	if isInPhase("PLAY") and isCheckingSuspicion and not statusData.torpor then
		statusData.exhaustion = false
		if Z.countInfamy(zone) == maxInfamy then
			Z.getCard(zone).highlightOn({ 1, 1, 1 })
			statusData.suspicion = true
		else
			Z.getCard(zone).highlightOff()
			statusData.color = "rgba(0, 0, 0, 0.98)"
			statusData.suspicion = false
		end
	else
		Z.getCard(zone).highlightOff()
		statusData.suspicion = false
		statusData.exhaustion = not statusData.torpor and isInPhase({"INIT", "PLAY"}) and Z.isExhausted(zone)
	end

	uiData[zone.guid].statusXML = getStatusXML(statusData)
end

local scoreThrottle = false
local function refreshScoreXML(zone)
	-- ONLY if one has already been set
	if uiData[zone.guid].scoreXML == nil then return end

	local scoreData = {
		power = Z.countPower(zone),
		infamy = Z.countInfamy(zone),
		boons = Z.countBoons(zone)
	}

	if scoreThrottle == false then
		scoreThrottle = true
		Wait.time(function() scoreThrottle = false end, 2)
		local victoryBoard = getObjectFromGUID(G.victoryBoard)
		if victoryBoard ~= nil then
			local color
			if U.isIn(zone.guid, G.zones.Red.all) then
				color = "Red"
			elseif U.isIn(zone.guid, G.zones.Yellow.all) then
				color = "Yellow"
			elseif U.isIn(zone.guid, G.zones.Blue.all) then
				color = "Blue"
			else
				return
			end
			Global.getTable("M").updatePlayerScore(color)
		end
	end

	uiData[zone.guid].scoreXML = getScoreXML(scoreData)
end

local function refreshXML(zone)
	if not Z.hasCard(zone) then
		uiData[zone.guid] = {}
		return
	end
	initXML(zone)
	refreshStatusXML(zone)
	refreshScoreXML(zone)
end

local function refreshUI(zone)
	refreshXML(zone)
	if not uiData[zone.guid].statusXML and not uiData[zone.guid].scoreXML then
		zone.UI.setXml("")
		return
	end
	local XML = {}
	if uiData[zone.guid].statusXML then
		table.insert(XML, uiData[zone.guid].statusXML)
	end
	if uiData[zone.guid].scoreXML then
		table.insert(XML, uiData[zone.guid].scoreXML)
	end

	zone.UI.setXmlTable(XML)
end

function Z.refreshUI(zone)
	if zone == nil then
		for _, z in pairs(Z.getPlayerZones()) do
			refreshUI(z)
		end
	else
		refreshUI(zone)
	end
end

function Z.showScores()
	for _, zone in pairs(Z.getPlayerZones()) do
		initXML(zone)
		uiData[zone.guid].scoreXML = {}
	end
	Z.refreshUI()
end

function Z.hideScores()
	for _, zone in pairs(Z.getPlayerZones()) do
		initXML(zone)
		uiData[zone.guid].scoreXML = nil
	end
	Z.refreshUI()
end

local function refreshMaxInfamy()
	maxInfamy = 0
	for _, zone in pairs(Z.getPlayerZones()) do
		local infamyCount = Z.countInfamy(zone)
		if infamyCount > maxInfamy then
			maxInfamy = infamyCount
		end
	end
end
function Z.showSuspicion()
	isCheckingSuspicion = true
	refreshMaxInfamy()
	for var, val in pairs(C.Lighting.suspicion) do
		Lighting[var] = val
	end
	Lighting.apply()
	Z.refreshUI()
end
function Z.hideSuspicion()
	isCheckingSuspicion = false
	maxInfamy = 0
	for var, val in pairs(C.Lighting.standard) do
		Lighting[var] = val
	end
	Lighting.apply()
	Z.refreshUI()
end

function Z.alignCard(zone)
	local monstrosityTags = {"Monstrosity_1", "Monstrosity_2", "Monstrosity_3", "Monstrosity_4"}
	local zonePos = zone.getPosition()
	local function alignCharCard(card)
		if U.hasAnyTag(card, monstrosityTags) then return end
		local cardRot = zone.getRotation()
		cardRot.y = 180
		cardRot.z = U.pAngle(card.getRotation().z, 180)
		card.setRotationSmooth(cardRot)
		card.setPositionSmooth({
			x = zonePos.x,
			y = -0.11,
			z = zonePos.z
		})
		card.addTag("TopChar")
	end
	local function alignEnemySchemeCard(card)
		local zoneBounds = getZoneBounds(zone)
		-- card.setLock(true)
		card.setScale({0.33, 1, 0.33})
		card.setRotation({x = 0, y = 180, z = 0})
		card.setPosition({
			x = zoneBounds.x.max - 0.4,
			y = 0.05,
			z = zoneBounds.z.max - 0.4
		})
	end
	local function alignMonstrosityCards(cards)

	end

	local zoneCharCards = Z.getCards(zone)
	if #zoneCharCards == 1 then
		alignCharCard(zoneCharCards[1])
		local pos = zone.getPosition()
		zone.setPosition({
			x = pos.x,
			y = 0.01,
			z = pos.z
		})
	elseif #zoneCharCards > 1 and #zoneCharCards < 5 then
		local minY = -0.11
		local heightStep = 0.04
		local vertStep = 1
		local topCard = U.find(zoneCharCards, function(card) return card.hasTag("TopChar") end)
		local newCard = U.find(zoneCharCards, function(card) return not U.hasAnyTag(card, U.concat({"TopChar"}, monstrosityTags)) end)
		if topCard ~= nil and newCard ~= nil then
			local monstrosityCards = U.filter(zoneCharCards, function(card) return U.hasAnyTag(card, monstrosityTags) end)
			local thisMonstrosityNum = #monstrosityCards + 1
			newCard.addTag("Monstrosity_" .. thisMonstrosityNum)
			-- lock and elevate the top card
			topCard.setLock(true)
			Wait.time(function() topCard.setLock(false) end, 1)
			local topPos = topCard.getPosition()
			topCard.setPositionSmooth({
				x = topPos.x,
				y = minY + heightStep * (#monstrosityCards + 1),
				z = topPos.z
			})
			local zonePos = zone.getPosition()
			zone.setPosition({
				x = zonePos.x,
				y = 0.01 + heightStep * (#monstrosityCards + 1),
				z = zonePos.z
			})

			for i = 1, #monstrosityCards + 1 do
				local tag = "Monstrosity_" .. i
				local thisCard = U.find(zoneCharCards, function(card) return card.hasTag(tag) end)
				if thisCard ~= nil then
					thisCard.setLock(true)
					thisCard.setPositionSmooth({
						x = topPos.x,
						y = minY + heightStep * (#monstrosityCards + 1 - i),
						z = topPos.z - vertStep * i
					})
					thisCard.setRotation({x = 0, y = 180, z = 0})
					Wait.time(function() thisCard.setLock(false) end, 1)
				end
			end
		end
	end

	local zoneSchemeCards = Z.getTaggedZoneObjects(zone, {"ClanScheme", "Brujah"}, true)
	if #zoneSchemeCards == 0 then return end
	if #zoneCharCards == 0 then
		U.forEach(zoneSchemeCards, Z.discardEnemyScheme)
	else
		alignEnemySchemeCard(table.remove(zoneSchemeCards, 1))
	end
end

function Z.discardEnemyScheme(enemyScheme)
	if enemyScheme == nil then return end
	local pos = enemyScheme.getPosition()
	pos.y = pos.y + 0.5
	enemyScheme.setPosition(pos)
	enemyScheme.setScale({1, 1, 1})
	enemyScheme.setLock(false)
	local playerColor
	local clans = getStateVal("clans")
	if clans == nil then return end
  if clans.Red == "Brujah" then playerColor = "Red"
	elseif clans.Yellow == "Brujah" then playerColor =  "Yellow"
  elseif clans.Blue == "Brujah" then playerColor = "Blue"
	else return end
	local schemeDiscard = getObjectFromGUID(G.playerObjs[playerColor].schemeDiscard)
	pos = schemeDiscard.getPosition()
	pos.y = pos.y + 0.5
	enemyScheme.setPositionSmooth(pos)
end

function Z.discardTorporedVamps()
	local discardPos = getObjectFromGUID(G.decks.characterDiscardSpot).getPosition()
	discardPos.y = discardPos.y + 1
	for _, zone in pairs(Z.getPlayerZones()) do
		if (Z.isTorpored(zone)) then
			for _, obj in pairs(Z.getTaggedZoneObjects(zone, { "Power", "Infamy", "ExhaustTorpor" })) do
				obj.destruct()
			end
			U.forEach(Z.getBoons(zone), function(boon)
				local boonClan = string.gsub(boon.getName(), " Boon", "")
				local clanChest = getObjectFromGUID(G.mainStorage.clanStorage[boonClan])
				clanChest.putObject(boon)
			end)
			U.forEach(Z.getCards(zone), function(card) card.setPosition(discardPos) end)
			local enemyScheme = Z.getEnemyScheme(zone)
			if enemyScheme ~= nil then
				Z.discardEnemyScheme(enemyScheme)
			end
		end
	end
end

function Z.returnAnkhs(dir, isAwardingPower)
	if isAwardingPower == nil then isAwardingPower = true end
	if not isInPhase("PLAY") then isAwardingPower = false end

	for _, zone in pairs(Z.getPlayerZones()) do
		local returningAnkhs = Z.getAnkhs(zone, dir)
		U.forEach(returningAnkhs, function(obj) BGE.sendAnkhHome(obj) end)
		if (isAwardingPower and #returningAnkhs > 0) then
			local powerBox = getObjectFromGUID(G.tokenSources.power);
			local powerPos = zone.getPosition()
			powerPos.y = powerPos.y + 1
			powerBox.takeObject({
				index = 1,
				smooth = false,
				position = powerPos
			})
		end
	end
end

function Z.burnAnkhs(zone)
	U.forEach(Z.getAnkhs(zone), function(obj)
		BGE.burnAnkh(obj)
	end)
end

return Z
